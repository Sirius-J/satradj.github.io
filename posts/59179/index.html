<!DOCTYPE html>
<html lang=zh>
<head>
    <meta charset="utf-8">
    
    <title>spring context源码分析 | 我在万达摆地摊&#39;s blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="开头入口方法在BeanDefinitionParserDelegate.parseCustomElement： 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));">
<meta name="keywords" content="spring">
<meta property="og:type" content="article">
<meta property="og:title" content="spring context源码分析">
<meta property="og:url" content="https://satra.tk/posts/59179/index.html">
<meta property="og:site_name" content="我在万达摆地摊&#39;s blog">
<meta property="og:description" content="开头入口方法在BeanDefinitionParserDelegate.parseCustomElement： 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://satra.tk/posts/59179/Comparator.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/ContextAnnotationAutowireCandidateResolver.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/ConfigurationClassPostProcessor.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/AutowiredAnnotationBeanPostProcessor.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/CommonAnnotationBeanPostProcessor.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/EventListenerMethodProcessor.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/DefaultEventListenerFactory.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/CompositeComponentDefinition.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/context_annotation_stack.png">
<meta property="og:image" content="https://satra.tk/posts/59179/ImportAwareBeanPostProcessor.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/BeanNameGenerator.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/required_test.png">
<meta property="og:image" content="https://satra.tk/posts/59179/ScopeMetadataResolver.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/MetadataReader.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/AnnotationMetadataReadingVisitor.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/ScannedGenericBeanDefinition.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/PropertyOverrideBeanDefinitionParser.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/PropertyOverrideConfigurer.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/PropertySourcesPlaceholderConfigurer.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/LoadTimeWeaver.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/AspectJWeavingEnabler.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/AnnotationBeanConfigurerAspect.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/LoadTimeWeaverAwareProcessor.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/ClassPreProcessorAgentAdapter.jpg">
<meta property="og:image" content="https://satra.tk/posts/59179/aop_xml_parse.png">
<meta property="og:updated_time" content="2018-10-05T09:23:47.730Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="spring context源码分析">
<meta name="twitter:description" content="开头入口方法在BeanDefinitionParserDelegate.parseCustomElement： 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));">
<meta name="twitter:image" content="https://satra.tk/posts/59179/Comparator.jpg">
    

    

    
        <link rel="icon" href="/img/logo.jpg" />
    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/open-sans/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/2.1.3/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
        <script type="text/javascript">
(function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-127037164-1', 'auto');
ga('send', 'pageview');

</script>
    
    
    


</head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                
                <span class="site-title">我在万达摆地摊&#39;s blog</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/.">主页</a>
                
                    <a class="main-nav-link" href="/categories">分类</a>
                
                    <a class="main-nav-link" href="/archives">归档</a>
                
                    <a class="main-nav-link" href="/books">书单</a>
                
                    <a class="main-nav-link" href="/about">关于</a>
                
            </nav>
            
                
                <nav id="sub-nav">
                    <div class="profile" id="profile-nav">
                        <a id="profile-anchor" href="javascript:;">
                            <img class="avatar" src="/img/logo.jpg" />
                            <i class="fa fa-caret-down"></i>
                        </a>
                    </div>
                </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="想要查找什么..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/.">主页</a></td>
                
                    <td><a class="main-nav-link" href="/categories">分类</a></td>
                
                    <td><a class="main-nav-link" href="/archives">归档</a></td>
                
                    <td><a class="main-nav-link" href="/books">书单</a></td>
                
                    <td><a class="main-nav-link" href="/about">关于</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="搜索" />
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
                

<aside id="profile">
    <div class="inner profile-inner">
        <div class="base-info profile-block">
            <img id="avatar" src="/img/logo.jpg" />
            <h2 id="name">我在万达摆地摊</h2>
            <h3 id="title">Java Developer</h3>
            <span id="location"><i class="fa fa-map-marker"></i>ShangHai, China</span>
            <a id="follow" target="_blank" href="https://github.com/satradj/">关注我</a>
        </div>
        <div class="article-info profile-block">
            <div class="article-info-block">
                32
                <span>文章</span>
            </div>
            <div class="article-info-block">
                7
                <span>标签</span>
            </div>
        </div>
        
        <div class="profile-block social-links">
            <table>
                <tr>
                    
                    
                    <td>
                        <a href="https://github.com/satradj/" target="_blank" title="github" class=tooltip>
                            <i class="fa fa-github"></i>
                        </a>
                    </td>
                    
                </tr>
            </table>
        </div>
        
    </div>
</aside>

            
            <section id="main"><article id="post-spring-context源码分析" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
            spring context源码分析
        </h1>
    

                
                    <div class="article-meta">
                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/posts/59179/">
            <time datetime="2018-06-06T15:19:43.000Z" itemprop="datePublished">2018-06-06</time>
        </a>
    </div>


                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/spring/">spring</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/spring/">spring</a>
    </div>

                    </div>
                
            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
            
            <h1 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h1><p>入口方法在BeanDefinitionParserDelegate.parseCustomElement：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> findParserForElement(element, parserContext).parse(element, parserContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> BeanDefinitionParser <span class="title">findParserForElement</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    String localName = parserContext.getDelegate().getLocalName(element);</span><br><span class="line">    BeanDefinitionParser parser = <span class="keyword">this</span>.parsers.get(localName);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) &#123;</span><br><span class="line">        parserContext.getReaderContext().fatal(</span><br><span class="line">            <span class="string">"Cannot locate BeanDefinitionParser for element ["</span> + localName + <span class="string">"]"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>localName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。</p>
<h1 id="annotation-config"><a href="#annotation-config" class="headerlink" title="annotation-config"></a>annotation-config</h1><p>AnnotationConfigBeanDefinitionParser.parse:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//返回null</span></span><br><span class="line">    Object source = parserContext.extractSource(element);</span><br><span class="line">    <span class="comment">// Obtain bean definitions for all relevant BeanPostProcessors.</span></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; processorDefinitions =</span><br><span class="line">            AnnotationConfigUtils.</span><br><span class="line">                registerAnnotationConfigProcessors(parserContext.getRegistry(), source);</span><br><span class="line">    <span class="comment">// Register component for the surrounding &lt;context:annotation-config&gt; element.</span></span><br><span class="line">    CompositeComponentDefinition compDefinition = </span><br><span class="line">        <span class="keyword">new</span> CompositeComponentDefinition(element.getTagName(), source);</span><br><span class="line">    parserContext.pushContainingComponent(compDefinition);</span><br><span class="line">    <span class="comment">// Nest the concrete beans in the surrounding component.</span></span><br><span class="line">    <span class="keyword">for</span> (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123;</span><br><span class="line">        parserContext.registerComponent(<span class="keyword">new</span> BeanComponentDefinition(processorDefinition));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Finally register the composite component.</span></span><br><span class="line">    <span class="comment">// 空实现</span></span><br><span class="line">    parserContext.popAndRegisterContainingComponent();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BeanPostProcessor注册"><a href="#BeanPostProcessor注册" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h2><p>AnnotationConfigUtils.registerAnnotationConfigProcessors源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第一个参数其实就是DefaultListableBeanFactory,第二个参数为null</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">registerAnnotationConfigProcessors</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        BeanDefinitionRegistry registry, Object source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将registery强转为DefaultListableBeanFactory类型</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry);</span><br><span class="line">    <span class="keyword">if</span> (beanFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getDependencyComparator() <span class="keyword">instanceof</span> AnnotationAwareOrderComparator)) &#123;</span><br><span class="line">            beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!(beanFactory.getAutowireCandidateResolver() <span class="keyword">instanceof</span> </span><br><span class="line">            ContextAnnotationAutowireCandidateResolver)) &#123;</span><br><span class="line">            beanFactory.setAutowireCandidateResolver(<span class="keyword">new</span> ContextAnnotationAutowireCandidateResolver());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefs = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ConfigurationClassPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(CommonAnnotationBeanPostProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor.</span></span><br><span class="line">    <span class="keyword">if</span> (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">        def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME,</span><br><span class="line">                AnnotationConfigUtils.class.getClassLoader()));</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(EventListenerMethodProcessor.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(DefaultEventListenerFactory.class);</span><br><span class="line">        def.setSource(source);</span><br><span class="line">        beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> beanDefs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AnnotationAwareOrderComparator"><a href="#AnnotationAwareOrderComparator" class="headerlink" title="AnnotationAwareOrderComparator"></a>AnnotationAwareOrderComparator</h3><p>其继承体系如下:</p>
<p><img src="Comparator.jpg" alt="Comparator继承体系"></p>
<p>其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考:</p>
<p><a href="http://www.tuicool.com/articles/VnqUv2" target="_blank" rel="noopener">Spring 4.2新特性-使用@Order调整配置类加载顺序</a></p>
<h3 id="ContextAnnotationAutowireCandidateResolver"><a href="#ContextAnnotationAutowireCandidateResolver" class="headerlink" title="ContextAnnotationAutowireCandidateResolver"></a>ContextAnnotationAutowireCandidateResolver</h3><p>此类用以决定一个bean是否可以当作一个依赖的候选者。其类图:</p>
<p><img src="ContextAnnotationAutowireCandidateResolver.jpg" alt="ContextAnnotationAutowireCandidateResolver类图"></p>
<h3 id="ConfigurationClassPostProcessor"><a href="#ConfigurationClassPostProcessor" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>此类用于处理标注了@Configuration注解的类。类图:</p>
<p><img src="ConfigurationClassPostProcessor.jpg" alt="ConfigurationClassPostProcessor类图"></p>
<h3 id="AutowiredAnnotationBeanPostProcessor"><a href="#AutowiredAnnotationBeanPostProcessor" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>此类便用于对标注了@Autowire等注解的bean或是方法进行注入。</p>
<p><img src="AutowiredAnnotationBeanPostProcessor.jpg" alt="AutowiredAnnotationBeanPostProcessor类图"></p>
<h3 id="RequiredAnnotationBeanPostProcessor"><a href="#RequiredAnnotationBeanPostProcessor" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。</p>
<h3 id="CommonAnnotationBeanPostProcessor"><a href="#CommonAnnotationBeanPostProcessor" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jsr250Present =</span><br><span class="line">    ClassUtils.isPresent(<span class="string">"javax.annotation.Resource"</span>, AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<p>此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图:</p>
<p><img src="CommonAnnotationBeanPostProcessor.jpg" alt="CommonAnnotationBeanPostProcessor类图"></p>
<h3 id="PersistenceAnnotationBeanPostProcessor"><a href="#PersistenceAnnotationBeanPostProcessor" class="headerlink" title="PersistenceAnnotationBeanPostProcessor"></a>PersistenceAnnotationBeanPostProcessor</h3><p>用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> jpaPresent =	</span><br><span class="line">    ClassUtils.isPresent(<span class="string">"javax.persistence.EntityManagerFactory"</span>, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader()) &amp;&amp;</span><br><span class="line">    <span class="comment">//org.springframework.orm包</span></span><br><span class="line">    ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, </span><br><span class="line">        AnnotationConfigUtils.class.getClassLoader());</span><br></pre></td></tr></table></figure>
<p>rt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。</p>
<h3 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系:</p>
<p><img src="EventListenerMethodProcessor.jpg" alt="EventListenerMethodProcessor类图"></p>
<h3 id="DefaultEventListenerFactory"><a href="#DefaultEventListenerFactory" class="headerlink" title="DefaultEventListenerFactory"></a>DefaultEventListenerFactory</h3><p>此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图:</p>
<p><img src="DefaultEventListenerFactory.jpg" alt="DefaultEventListenerFactory类图"></p>
<h2 id="逻辑关系整理"><a href="#逻辑关系整理" class="headerlink" title="逻辑关系整理"></a>逻辑关系整理</h2><p>普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图:</p>
<p><img src="CompositeComponentDefinition.jpg" alt="CompositeComponentDefinition类图"></p>
<p>最终形成的数据结构如下图:</p>
<p><img src="context_annotation_stack.png" alt="数据结构"></p>
<p>不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h3 id="ConfigurationClassPostProcessor-1"><a href="#ConfigurationClassPostProcessor-1" class="headerlink" title="ConfigurationClassPostProcessor"></a>ConfigurationClassPostProcessor</h3><p>本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>
<p>注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。</p>
<h4 id="postProcessBeanDefinitionRegistry"><a href="#postProcessBeanDefinitionRegistry" class="headerlink" title="postProcessBeanDefinitionRegistry"></a>postProcessBeanDefinitionRegistry</h4><p>此方法大体由两部分组成。</p>
<h5 id="BeanPostProcessor注册-1"><a href="#BeanPostProcessor注册-1" class="headerlink" title="BeanPostProcessor注册"></a>BeanPostProcessor注册</h5><p>此部分源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanDefinitionRegistry</span><span class="params">(BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    RootBeanDefinition iabpp = <span class="keyword">new</span> RootBeanDefinition(ImportAwareBeanPostProcessor.class);</span><br><span class="line">    iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp);</span><br><span class="line">    RootBeanDefinition ecbpp = <span class="keyword">new</span> RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class);</span><br><span class="line">    ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="ImportAwareBeanPostProcessor"><a href="#ImportAwareBeanPostProcessor" class="headerlink" title="ImportAwareBeanPostProcessor"></a>ImportAwareBeanPostProcessor</h6><p>是ConfigurationClassPostProcessor的私有内部类。其类图:</p>
<p><img src="ImportAwareBeanPostProcessor.jpg" alt="ImportAwareBeanPostProcessor类图"></p>
<p>此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起:</p>
<p>有一个类负责生成Student bean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentConfig</span> <span class="keyword">implements</span> <span class="title">ImportAware</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        student.setAge(<span class="number">22</span>);</span><br><span class="line">        student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImportMetadata</span><span class="params">(AnnotationMetadata importMetadata)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"importaware"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import</span>(StudentConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBeanConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentConfig studentConfig;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SimpleBean <span class="title">getSimpleBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//bean依赖</span></span><br><span class="line">        SimpleBean simpleBean = <span class="keyword">new</span> SimpleBean(studentConfig.student());</span><br><span class="line">        <span class="keyword">return</span> simpleBean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext context = </span><br><span class="line">        <span class="keyword">new</span> AnnotationConfigApplicationContext(SimpleBeanConfig.class);</span><br><span class="line">    SimpleBean simpleBean = context.getBean(SimpleBean.class);</span><br><span class="line">    System.out.println(simpleBean.getStudent().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以ImportAware接口的作用就是<strong>使被引用的配置类可以获得引用类的相关信息</strong>。</p>
<h6 id="EnhancedConfigurationBeanPostProcessor"><a href="#EnhancedConfigurationBeanPostProcessor" class="headerlink" title="EnhancedConfigurationBeanPostProcessor"></a>EnhancedConfigurationBeanPostProcessor</h6><p>用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。</p>
<h5 id="类解析"><a href="#类解析" class="headerlink" title="类解析"></a>类解析</h5><p>这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。</p>
<h6 id="bean名字生成策略"><a href="#bean名字生成策略" class="headerlink" title="bean名字生成策略"></a>bean名字生成策略</h6><p>对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。</p>
<p>ConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Detect any custom bean name generation strategy supplied through the enclosing application context</span></span><br><span class="line">SingletonBeanRegistry singletonRegistry = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span> (registry <span class="keyword">instanceof</span> SingletonBeanRegistry) &#123;</span><br><span class="line">    singletonRegistry = (SingletonBeanRegistry) registry;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; </span><br><span class="line">        <span class="comment">//org.springframework.context.annotation.internalConfigurationBeanNameGenerator</span></span><br><span class="line">        singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;</span><br><span class="line">            BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry.</span><br><span class="line">            getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);</span><br><span class="line">        <span class="keyword">this</span>.componentScanBeanNameGenerator = generator;</span><br><span class="line">        <span class="keyword">this</span>.importBeanNameGenerator = generator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认是一个AnnotationBeanNameGenerator对象，其类图:</p>
<p><img src="BeanNameGenerator.jpg" alt="BeanNameGenerator类图"></p>
<p>那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: <strong>配置解析、BeanDefinition加载之后，Singleton初始化之前</strong>，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。</p>
<h4 id="postProcessBeanFactory"><a href="#postProcessBeanFactory" class="headerlink" title="postProcessBeanFactory"></a>postProcessBeanFactory</h4><p>此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。简略版的源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enhanceConfigurationClasses</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = </span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap&lt;String, AbstractBeanDefinition&gt;();</span><br><span class="line">    <span class="comment">//寻找@Configuration的BeanDefinition</span></span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">        BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">        <span class="keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123;</span><br><span class="line">            configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configBeanDefs.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// nothing to enhance -&gt; return immediately</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ConfigurationClassEnhancer enhancer = <span class="keyword">new</span> ConfigurationClassEnhancer();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">        AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">        <span class="comment">// If a @Configuration class gets proxied, always proxy the target class</span></span><br><span class="line">        beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// Set enhanced subclass of the user-specified bean class</span></span><br><span class="line">        Class&lt;?&gt; configClass = beanDef.resolveBeanClass(<span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">        <span class="keyword">if</span> (configClass != enhancedClass) &#123;</span><br><span class="line">             <span class="comment">//替换</span></span><br><span class="line">            beanDef.setBeanClass(enhancedClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ConfigurationClassEnhancer.newEnhancer:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Enhancer <span class="title">newEnhancer</span><span class="params">(Class&lt;?&gt; superclass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">    enhancer.setSuperclass(superclass);</span><br><span class="line">    <span class="comment">//这里印证了前面EnhancedConfigurationBeanPostProcessor的说明</span></span><br><span class="line">    enhancer.setInterfaces(<span class="keyword">new</span> Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;);</span><br><span class="line">    enhancer.setUseFactory(<span class="keyword">false</span>);</span><br><span class="line">    enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">    enhancer.setStrategy(<span class="keyword">new</span> BeanFactoryAwareGeneratorStrategy(classLoader));</span><br><span class="line">    <span class="comment">//关键</span></span><br><span class="line">    enhancer.setCallbackFilter(CALLBACK_FILTER);</span><br><span class="line">    enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes());</span><br><span class="line">    <span class="keyword">return</span> enhancer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CALLBACK_FILTER是个什么东西呢:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConditionalCallbackFilter CALLBACK_FILTER = </span><br><span class="line">    <span class="keyword">new</span> ConditionalCallbackFilter(CALLBACKS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Callback[] CALLBACKS = <span class="keyword">new</span> Callback[] &#123;</span><br><span class="line">    <span class="keyword">new</span> BeanMethodInterceptor(),</span><br><span class="line">    <span class="keyword">new</span> BeanFactoryAwareMethodInterceptor(),</span><br><span class="line">    NoOp.INSTANCE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这么做的原因有两个:</p>
<ul>
<li><p>提供Scope支持:</p>
<p>我们可以使用@Scope注解来使用注解的方式配置其Scope:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Student <span class="title">student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    student.setAge(<span class="number">22</span>);</span><br><span class="line">    student.setName(<span class="string">"skywalker"</span>);</span><br><span class="line">    <span class="keyword">return</span> student;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。</p>
</li>
<li><p>实现EnhancedConfiguration接口</p>
</li>
</ul>
<h3 id="AutowiredAnnotationBeanPostProcessor-1"><a href="#AutowiredAnnotationBeanPostProcessor-1" class="headerlink" title="AutowiredAnnotationBeanPostProcessor"></a>AutowiredAnnotationBeanPostProcessor</h3><p>类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。</p>
<h4 id="postProcessMergedBeanDefinition"><a href="#postProcessMergedBeanDefinition" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><h5 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h5><p>其中前者首先被调用，时机是当BeanDefinition被合并(和父Bean)，但是还没有用来创建Bean实例时。回顾下其调用入口:</p>
<p>AbstractAutowireCapableBeanFactory.doCreateBean(简略):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Instantiate the bean.</span></span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">    Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">            mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>applyMergedBeanDefinitionPostProcessors:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyMergedBeanDefinitionPostProcessors</span><span class="params">(RootBeanDefinition mbd, Class&lt;?&gt; beanType, </span></span></span><br><span class="line"><span class="function"><span class="params">    String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> MergedBeanDefinitionPostProcessor) &#123;</span><br><span class="line">            MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp;</span><br><span class="line">            bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	 beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findAutowiringMetadata:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">findAutowiringMetadata</span><span class="params">(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Fall back to class name as cache key, for backwards compatibility with custom callers.</span></span><br><span class="line">    String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName());</span><br><span class="line">    <span class="comment">// Quick check on the concurrent map first, with minimal locking.</span></span><br><span class="line">    InjectionMetadata metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.injectionMetadataCache) &#123;</span><br><span class="line">            metadata = <span class="keyword">this</span>.injectionMetadataCache.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (InjectionMetadata.needsRefresh(metadata, clazz)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (metadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    metadata.clear(pvs);</span><br><span class="line">                &#125;</span><br><span class="line">                metadata = buildAutowiringMetadata(clazz);</span><br><span class="line">                <span class="keyword">this</span>.injectionMetadataCache.put(cacheKey, metadata);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>injectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因:</p>
<ul>
<li>假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。</li>
<li>对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。</li>
</ul>
<p>可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。</p>
<p>@Autowire注解的扫描在buildAutowiringMetadata方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> InjectionMetadata <span class="title">buildAutowiringMetadata</span><span class="params">(<span class="keyword">final</span> Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = </span><br><span class="line">        <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">    Class&lt;?&gt; targetClass = clazz;</span><br><span class="line">    <span class="comment">//循环检测父类</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements =</span><br><span class="line">                <span class="keyword">new</span> LinkedList&lt;InjectionMetadata.InjectedElement&gt;();</span><br><span class="line">        ReflectionUtils.doWithLocalFields(targetClass, <span class="keyword">new</span> ReflectionUtils.FieldCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Field field)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(field);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span>) &#123;</span><br><span class="line">                      <span class="comment">//不支持静态变量</span></span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(field.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredFieldElement(field, required));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        ReflectionUtils.doWithLocalMethods(targetClass, <span class="keyword">new</span> ReflectionUtils.MethodCallback() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWith</span><span class="params">(Method method)</span> <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException </span>&#123;</span><br><span class="line">                Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br><span class="line">                <span class="keyword">if</span> (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod);</span><br><span class="line">                <span class="keyword">if</span> (ann != <span class="keyword">null</span> &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Modifier.isStatic(method.getModifiers())) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                            logger.warn(<span class="string">"Autowired annotation should be used on </span></span><br><span class="line"><span class="string">                                methods with parameters: "</span> + method);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">boolean</span> required = determineRequiredStatus(ann);</span><br><span class="line">                    PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz);</span><br><span class="line">                    currElements.add(<span class="keyword">new</span> AutowiredMethodElement(method, required, pd));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        elements.addAll(<span class="number">0</span>, currElements);</span><br><span class="line">        targetClass = targetClass.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (targetClass != <span class="keyword">null</span> &amp;&amp; targetClass != Object.class);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> InjectionMetadata(clazz, elements);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，<strong>Spring注入注解可以配置在此bean的父类上</strong>。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。</p>
<h5 id="变量扫描"><a href="#变量扫描" class="headerlink" title="变量扫描"></a>变量扫描</h5><p>之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。</p>
<p>ReflectionUtils的实现其实就是访问者模式，其源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doWithLocalFields</span><span class="params">(Class&lt;?&gt; clazz, FieldCallback fc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Field field : getDeclaredFields(clazz)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.doWith(field);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalAccessException ex) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>determineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。</p>
<h5 id="方法扫描"><a href="#方法扫描" class="headerlink" title="方法扫描"></a>方法扫描</h5><h6 id="bridge方法"><a href="#bridge方法" class="headerlink" title="bridge方法"></a>bridge方法</h6><p>就是方法扫描的第一行源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method);</span><br></pre></td></tr></table></figure>
<p>此句代码的作用是<strong>判断method是否是bridge方法，如果是，寻找其真正的方法。</strong>这里的bridge方法并不是所谓的bridge模式。</p>
<p>有这样的demo代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyList</span> <span class="keyword">extends</span> <span class="title">ArrayList</span> </span>&#123;</span><br><span class="line">        <span class="comment">//注意父类的返回类型是Object</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Method method : MyList.class.getDeclaredMethods()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"name: "</span> + method.getName() + <span class="string">", return: "</span> + method.getReturnType());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name: get, return: class java.lang.String</span><br><span class="line">name: get, return: class java.lang.Object</span><br></pre></td></tr></table></figure>
<p>通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns &#123;<span class="doctag">@code</span> true&#125; if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method; returns &#123;<span class="doctag">@code</span> false&#125; otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if and only if this method is a bridge</span></span><br><span class="line"><span class="comment"> * method as defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBridge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getModifiers() &amp; Modifier.BRIDGE) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。</p>
<p>可以参考: <a href="http://ifeve.com/syntethic-and-bridge-methods/" target="_blank" rel="noopener">Java那些不为人知的特殊方法</a></p>
<p>到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。</p>
<h6 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h6><p>用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。</p>
<h4 id="postProcessPropertyValues"><a href="#postProcessPropertyValues" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><h5 id="入口-1"><a href="#入口-1" class="headerlink" title="入口"></a>入口</h5><p>AbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。</p>
<h5 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h5><p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processInjection</span><span class="params">(Object bean)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    Class&lt;?&gt; clazz = bean.getClass();</span><br><span class="line">     <span class="comment">// 查找缓存</span></span><br><span class="line">    InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, <span class="keyword">null</span>);</span><br><span class="line">    metadata.inject(bean, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。</p>
<h6 id="Field注入"><a href="#Field注入" class="headerlink" title="Field注入"></a>Field注入</h6><p>实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。</p>
<h6 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h6><p>实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。</p>
<h3 id="RequiredAnnotationBeanPostProcessor-1"><a href="#RequiredAnnotationBeanPostProcessor-1" class="headerlink" title="RequiredAnnotationBeanPostProcessor"></a>RequiredAnnotationBeanPostProcessor</h3><p>上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。</p>
<h4 id="postProcessMergedBeanDefinition-1"><a href="#postProcessMergedBeanDefinition-1" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>空实现，就是这么任性:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	beanName)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="postProcessPropertyValues-1"><a href="#postProcessPropertyValues-1" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.validatedBeanNames.contains(beanName)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!shouldSkip(<span class="keyword">this</span>.beanFactory, beanName)) &#123;</span><br><span class="line">            List&lt;String&gt; invalidProperties = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (PropertyDescriptor pd : pds) &#123;</span><br><span class="line">                <span class="keyword">if</span> (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123;</span><br><span class="line">                    invalidProperties.add(pd.getName());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!invalidProperties.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(buildExceptionMessage</span><br><span class="line">                    (invalidProperties, beanName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.validatedBeanNames.add(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="结果缓存"><a href="#结果缓存" class="headerlink" title="结果缓存"></a>结果缓存</h5><p>validatedBeanNames是一个Set<string>类型，对于已经检查过的bean，将其name加入Set，防止做无用功。</string></p>
<h5 id="PropertyDescriptor-1"><a href="#PropertyDescriptor-1" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h5><p>从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢?</p>
<p>AbstractAutowireCapableBeanFactory.populateBean相关代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line"><span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">            <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>filterPropertyDescriptorsForDependencyCheck单参数方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) &#123;</span><br><span class="line">    List&lt;PropertyDescriptor&gt; pds =</span><br><span class="line">            <span class="keyword">new</span> LinkedList&lt;PropertyDescriptor&gt;(Arrays.asList(bw.getPropertyDescriptors()));</span><br><span class="line">    <span class="keyword">for</span> (Iterator&lt;PropertyDescriptor&gt; it = pds.iterator(); it.hasNext();) &#123;</span><br><span class="line">        PropertyDescriptor pd = it.next();</span><br><span class="line">        <span class="keyword">if</span> (isExcludedFromDependencyCheck(pd)) &#123;</span><br><span class="line">            it.remove();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pds.toArray(<span class="keyword">new</span> PropertyDescriptor[pds.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢?</p>
<p>BeanWrapperImpl.getPropertyDescriptors:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> PropertyDescriptor[] getPropertyDescriptors() &#123;</span><br><span class="line">    <span class="keyword">return</span> getCachedIntrospectionResults().getPropertyDescriptors();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> CachedIntrospectionResults <span class="title">getCachedIntrospectionResults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Assert.state(getWrappedInstance() != <span class="keyword">null</span>, <span class="string">"BeanWrapper does not hold a bean instance"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.cachedIntrospectionResults == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.cachedIntrospectionResults;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，这时BeanWrapper便会把自己”内省”一遍。这从侧面说明@Reqired注解只对setter方法有效。</p>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><p>有一个bean如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span>(<span class="string">"simpleBean"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span>(required = <span class="keyword">false</span>)</span><br><span class="line">    <span class="keyword">private</span> Student student;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleBean</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">getStudent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Required</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStudent</span><span class="params">(Student student)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.student = student;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果:</p>
<p><img src="required_test.png" alt="@Required测试"></p>
<h3 id="CommonAnnotationBeanPostProcessor-1"><a href="#CommonAnnotationBeanPostProcessor-1" class="headerlink" title="CommonAnnotationBeanPostProcessor"></a>CommonAnnotationBeanPostProcessor</h3><p>从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。</p>
<h4 id="postProcessMergedBeanDefinition-2"><a href="#postProcessMergedBeanDefinition-2" class="headerlink" title="postProcessMergedBeanDefinition"></a>postProcessMergedBeanDefinition</h4><p>此方法的执行入口以及调用时机上面已经说过了。其源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	 beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName);</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InjectionMetadata metadata = findResourceMetadata(beanName, beanType, <span class="keyword">null</span>);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h5><p>可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessMergedBeanDefinition</span><span class="params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String 	 beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beanType != <span class="keyword">null</span>) &#123;</span><br><span class="line">        LifecycleMetadata metadata = findLifecycleMetadata(beanType);</span><br><span class="line">        metadata.checkConfigMembers(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是<strong>遍历所有method寻找初始化和销毁方法标记</strong>。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CommonAnnotationBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setInitAnnotationType(PostConstruct.class);</span><br><span class="line">    setDestroyAnnotationType(PreDestroy.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个标签来自于javax.annotation包。那么怎么自定义呢?</p>
<p>CommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.annotation.CommonAnnotationBeanPostProcessor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initAnnotationType"</span> <span class="attr">value</span>=<span class="string">"annotation.Init"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Init是一个很简单的自定义注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Init &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在自己的bean中使用此注解:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Init</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"Init!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行Spring便可以看到效果。</p>
<p>另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，<strong>Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持</strong>。为了达到只有一个实例的目的，需要为前面的配置加上ID。</p>
<h5 id="子类"><a href="#子类" class="headerlink" title="子类"></a>子类</h5><p>findResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。</p>
<h4 id="postProcessPropertyValues-2"><a href="#postProcessPropertyValues-2" class="headerlink" title="postProcessPropertyValues"></a>postProcessPropertyValues</h4><p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> PropertyValues <span class="title">postProcessPropertyValues</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs);</span><br><span class="line">    metadata.inject(bean, beanName, pvs);</span><br><span class="line">    <span class="keyword">return</span> pvs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>套路很明显了。</p>
<h4 id="postProcessBeforeInitialization"><a href="#postProcessBeforeInitialization" class="headerlink" title="postProcessBeforeInitialization"></a>postProcessBeforeInitialization</h4><p>实现在父类InitDestroyAnnotationBeanPostProcessor：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass());</span><br><span class="line">    metadata.invokeInitMethods(bean, beanName);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>invokeInitMethods:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(Object target, String beanName)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Collection&lt;LifecycleElement&gt; initMethodsToIterate =</span><br><span class="line">            (<span class="keyword">this</span>.checkedInitMethods != <span class="keyword">null</span> ? <span class="keyword">this</span>.checkedInitMethods : <span class="keyword">this</span>.initMethods);</span><br><span class="line">    <span class="keyword">if</span> (!initMethodsToIterate.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (LifecycleElement element : initMethodsToIterate) &#123;</span><br><span class="line">             <span class="comment">// 反射调用</span></span><br><span class="line">            element.invoke(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不过从源码来看应该支持多个init方法。</p>
<h4 id="postProcessBeforeDestruction"><a href="#postProcessBeforeDestruction" class="headerlink" title="postProcessBeforeDestruction"></a>postProcessBeforeDestruction</h4><p>反射调用销毁方法，没啥说的了。</p>
<h3 id="EventListenerMethodProcessor-1"><a href="#EventListenerMethodProcessor-1" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h3><p>就一个值得关注的方法: afterSingletonsInstantiated。</p>
<h5 id="入口-2"><a href="#入口-2" class="headerlink" title="入口"></a>入口</h5><p>DefaultListableBeanFactory.preInstantiateSingletons相关源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">    Object singletonInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">        <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = </span><br><span class="line">            (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="源码-1"><a href="#源码-1" class="headerlink" title="源码"></a>源码</h5><p>略过。</p>
<h1 id="component-scan"><a href="#component-scan" class="headerlink" title="component-scan"></a>component-scan</h1><p>ComponentScanBeanDefinitionParser.parse源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base-package属性</span></span><br><span class="line">    String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE);</span><br><span class="line">    <span class="comment">// 解析占位符</span></span><br><span class="line">    basePackage = parserContext.getReaderContext().getEnvironment()</span><br><span class="line">        .resolvePlaceholders(basePackage);</span><br><span class="line">    <span class="comment">//分割成数据</span></span><br><span class="line">    String[] basePackages = StringUtils.tokenizeToStringArray(basePackage,</span><br><span class="line">            ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);</span><br><span class="line">    <span class="comment">// Actually scan for bean definitions and register them.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages);</span><br><span class="line">    registerComponents(parserContext.getReaderContext(), beanDefinitions, element);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ClassPathBeanDefinitionScanner <span class="title">configureScanner</span><span class="params">(ParserContext parserContext, Element element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> useDefaultFilters = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123;</span><br><span class="line">        useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Delegate bean definition registration to scanner class.</span></span><br><span class="line">    ClassPathBeanDefinitionScanner scanner = createScanner</span><br><span class="line">        (parserContext.getReaderContext(), useDefaultFilters);</span><br><span class="line">    scanner.setResourceLoader(parserContext.getReaderContext().getResourceLoader());</span><br><span class="line">    scanner.setEnvironment(parserContext.getReaderContext().getEnvironment());</span><br><span class="line">    scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults());</span><br><span class="line">    scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123;</span><br><span class="line">        scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE));</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    parseBeanNameGenerator(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseScope(element, scanner);</span><br><span class="line"></span><br><span class="line">    parseTypeFilters(element, scanner, parserContext);</span><br><span class="line">    <span class="keyword">return</span> scanner;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面开始按顺序分部分说明。</p>
<h3 id="use-default-filters"><a href="#use-default-filters" class="headerlink" title="use-default-filters"></a>use-default-filters</h3><p>component-scan注解会默认扫描喜闻乐见的@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。</p>
<h3 id="扫描器-创建-amp-初始化"><a href="#扫描器-创建-amp-初始化" class="headerlink" title="扫描器:创建 &amp; 初始化"></a>扫描器:创建 &amp; 初始化</h3><p>就是createScanner方法和下面那一坨setter方法，没啥好说的。</p>
<h3 id="resource-pattern"><a href="#resource-pattern" class="headerlink" title="resource-pattern"></a>resource-pattern</h3><p>用以配置扫描器扫描的路径，默认<code>**/*.class</code>。</p>
<h3 id="name-generator"><a href="#name-generator" class="headerlink" title="name-generator"></a>name-generator</h3><p>可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。</p>
<h3 id="scope-resolver"><a href="#scope-resolver" class="headerlink" title="scope-resolver"></a>scope-resolver</h3><p>指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图:</p>
<p><img src="ScopeMetadataResolver.jpg" alt="ScopeMetadataResolver类图"></p>
<p>默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。</p>
<h3 id="scoped-proxy"><a href="#scoped-proxy" class="headerlink" title="scoped-proxy"></a>scoped-proxy</h3><p>此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。</p>
<h3 id="exclude-filter-include-filter"><a href="#exclude-filter-include-filter" class="headerlink" title="exclude-filter/include-filter"></a>exclude-filter/include-filter</h3><p>用法示例:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"base"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">"annotation"</span> <span class="attr">expression</span>=<span class="string">"javax.annotation.Resource"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>parseTypeFilters方法负责此部分的解析，只贴部分源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (INCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addIncludeFilter(typeFilter);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (EXCLUDE_FILTER_ELEMENT.equals(localName)) &#123;</span><br><span class="line">    TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext);</span><br><span class="line">    scanner.addExcludeFilter(typeFilter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="annotation-config-1"><a href="#annotation-config-1" class="headerlink" title="annotation-config"></a>annotation-config</h3><p>此属性等同于<context:annotation-config>配置，默认就是true，也就是说，如果配置了context:component-scan其实就没有必要配置annotation-config 了。</context:annotation-config></p>
<h2 id="扫描"><a href="#扫描" class="headerlink" title="扫描"></a>扫描</h2><p>入口方法便是ClassPathBeanDefinitionScanner.doScan:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="title">doScan</span><span class="params">(String... basePackages)</span> </span>&#123;</span><br><span class="line">    Assert.notEmpty(basePackages, <span class="string">"At least one base package must be specified"</span>);</span><br><span class="line">    Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String basePackage : basePackages) &#123;</span><br><span class="line">         <span class="comment">// 逐包扫描</span></span><br><span class="line">        Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition candidate : candidates) &#123;</span><br><span class="line">            ScopeMetadata scopeMetadata = <span class="keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);</span><br><span class="line">            candidate.setScope(scopeMetadata.getScopeName());</span><br><span class="line">            String beanName = <span class="keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="keyword">this</span>.registry);</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">                 <span class="comment">// 为BeanDefinition设置默认的属性</span></span><br><span class="line">                postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (candidate <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">                AnnotationConfigUtils.processCommonDefinitionAnnotations</span><br><span class="line">                    ((AnnotatedBeanDefinition) candidate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (checkCandidate(beanName, candidate)) &#123;</span><br><span class="line">                BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">                definitionHolder = AnnotationConfigUtils.applyScopedProxyMode</span><br><span class="line">                    (scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">                beanDefinitions.add(definitionHolder);</span><br><span class="line">                registerBeanDefinition(definitionHolder, <span class="keyword">this</span>.registry);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="逐包扫描-BeanDefinition解析"><a href="#逐包扫描-BeanDefinition解析" class="headerlink" title="逐包扫描/BeanDefinition解析"></a>逐包扫描/BeanDefinition解析</h3><p>扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图:</p>
<p><img src="MetadataReader.jpg" alt="MetadataReader类图"></p>
<p>对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SimpleMetadataReader(Resource resource, ClassLoader classLoader) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    InputStream is = <span class="keyword">new</span> BufferedInputStream(resource.getInputStream());</span><br><span class="line">    ClassReader classReader;</span><br><span class="line">    classReader = <span class="keyword">new</span> ClassReader(is);</span><br><span class="line"></span><br><span class="line">    AnnotationMetadataReadingVisitor visitor = <span class="keyword">new</span> AnnotationMetadataReadingVisitor(classLoader);</span><br><span class="line">    classReader.accept(visitor, ClassReader.SKIP_DEBUG);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.annotationMetadata = visitor;</span><br><span class="line">    <span class="comment">// (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor)</span></span><br><span class="line">    <span class="keyword">this</span>.classMetadata = visitor;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析的关键便在于AnnotationMetadataReadingVisitor，其类图:</p>
<p><img src="AnnotationMetadataReadingVisitor.jpg" alt="AnnotationMetadataReadingVisitor类图"></p>
<p>核心在于其visitAnnotation方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(<span class="keyword">final</span> String desc, <span class="keyword">boolean</span> visible)</span> </span>&#123;</span><br><span class="line">    String className = Type.getType(desc).getClassName();</span><br><span class="line">    <span class="keyword">this</span>.annotationSet.add(className);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AnnotationAttributesReadingVisitor(</span><br><span class="line">        className, <span class="keyword">this</span>.attributesMap, <span class="keyword">this</span>.metaAnnotationMap, <span class="keyword">this</span>.classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图:</p>
<p><img src="ScannedGenericBeanDefinition.jpg" alt="ScannedGenericBeanDefinition类图"></p>
<h3 id="Scope解析"><a href="#Scope解析" class="headerlink" title="@Scope解析"></a>@Scope解析</h3><p>AnnotationScopeMetadataResolver.resolveScopeMetadata:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ScopeMetadata <span class="title">resolveScopeMetadata</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    ScopeMetadata metadata = <span class="keyword">new</span> ScopeMetadata();</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition;</span><br><span class="line">         <span class="comment">// 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(</span><br><span class="line">                annDef.getMetadata(), <span class="keyword">this</span>.scopeAnnotationType);</span><br><span class="line">        <span class="keyword">if</span> (attributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// @Scope值</span></span><br><span class="line">            metadata.setScopeName(attributes.getString(<span class="string">"value"</span>));</span><br><span class="line">            ScopedProxyMode proxyMode = attributes.getEnum(<span class="string">"proxyMode"</span>);</span><br><span class="line">            <span class="keyword">if</span> (proxyMode == <span class="keyword">null</span> || proxyMode == ScopedProxyMode.DEFAULT) &#123;</span><br><span class="line">                proxyMode = <span class="keyword">this</span>.defaultProxyMode;</span><br><span class="line">            &#125;</span><br><span class="line">            metadata.setScopedProxyMode(proxyMode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metadata;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>proxyMode和xml的scoped-proxy属性是一个概念:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = <span class="string">"singleton"</span>, proxyMode = ScopedProxyMode.DEFAULT)</span><br></pre></td></tr></table></figure>
<p><strong>XML的属性是全局的配置，这个是局部(针对单个bean)的配置</strong>，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。</p>
<h3 id="bean名字生成"><a href="#bean名字生成" class="headerlink" title="bean名字生成"></a>bean名字生成</h3><p>AnnotationBeanNameGenerator.generateBeanName:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">generateBeanName</span><span class="params">(BeanDefinition definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (definition <span class="keyword">instanceof</span> AnnotatedBeanDefinition) &#123;</span><br><span class="line">        String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Explicit bean name found.</span></span><br><span class="line">            <span class="keyword">return</span> beanName;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Fallback: generate a unique default bean name.</span></span><br><span class="line">    <span class="keyword">return</span> buildDefaultBeanName(definition, registry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="根据注解"><a href="#根据注解" class="headerlink" title="根据注解"></a>根据注解</h4><p>默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineBeanNameFromAnnotation</span><span class="params">(AnnotatedBeanDefinition annotatedDef)</span> </span>&#123;</span><br><span class="line">    AnnotationMetadata amd = annotatedDef.getMetadata();</span><br><span class="line">    Set&lt;String&gt; types = amd.getAnnotationTypes();</span><br><span class="line">    String beanName = <span class="keyword">null</span>;</span><br><span class="line">     <span class="comment">// 遍历当前bean拥有的所有类级注解</span></span><br><span class="line">    <span class="keyword">for</span> (String type : types) &#123;</span><br><span class="line">         <span class="comment">// 获取此注解所有的属性</span></span><br><span class="line">        AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type);</span><br><span class="line">        <span class="keyword">if</span> (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) &#123;</span><br><span class="line">            Object value = attributes.get(<span class="string">"value"</span>);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">                String strVal = (String) value;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasLength(strVal)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (beanName != <span class="keyword">null</span> &amp;&amp; !strVal.equals(beanName)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    beanName = strVal;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> beanName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isStereotypeWithNameValue</span><span class="params">(String annotationType,</span></span></span><br><span class="line"><span class="function"><span class="params">        Set&lt;String&gt; metaAnnotationTypes, Map&lt;String, Object&gt; attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// org.springframework.stereotype.Component</span></span><br><span class="line">    <span class="keyword">boolean</span> isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) ||</span><br><span class="line">        (metaAnnotationTypes != <span class="keyword">null</span> &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) ||</span><br><span class="line">        annotationType.equals(<span class="string">"javax.annotation.ManagedBean"</span>) ||</span><br><span class="line">        annotationType.equals(<span class="string">"javax.inject.Named"</span>);</span><br><span class="line">    <span class="keyword">return</span> (isStereotype &amp;&amp; attributes != <span class="keyword">null</span> &amp;&amp; attributes.containsKey(<span class="string">"value"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>metaAnnotationTypes用以判断元注解，针对这种情况:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Controller &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。</p>
<h4 id="默认策略"><a href="#默认策略" class="headerlink" title="默认策略"></a>默认策略</h4><p>如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">buildDefaultBeanName</span><span class="params">(BeanDefinition definition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// base.SimpleBean -&gt; SimpleBean</span></span><br><span class="line">    String shortClassName = ClassUtils.getShortName(definition.getBeanClassName());</span><br><span class="line">    <span class="comment">//SimpleBean -&gt; simpleBean</span></span><br><span class="line">    <span class="keyword">return</span> Introspector.decapitalize(shortClassName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，对于内部类: OuterClassName.InnerClassName -&gt; outerClassName.InnerClassName.</p>
<h3 id="其它注解解析"><a href="#其它注解解析" class="headerlink" title="其它注解解析"></a>其它注解解析</h3><p>入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@DependsOn</span>(<span class="string">"student"</span>)</span><br><span class="line"><span class="meta">@Role</span>(BeanDefinition.ROLE_APPLICATION)</span><br><span class="line"><span class="meta">@Description</span>(<span class="string">"This is a simple bean."</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleBean</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个”hint”，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。</p>
<h3 id="冲突检测"><a href="#冲突检测" class="headerlink" title="冲突检测"></a>冲突检测</h3><p>Spring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">checkCandidate</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有同名的，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.registry.containsBeanDefinition(beanName)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BeanDefinition existingDef = <span class="keyword">this</span>.registry.getBeanDefinition(beanName);</span><br><span class="line">    BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition();</span><br><span class="line">    <span class="keyword">if</span> (originatingDef != <span class="keyword">null</span>) &#123;</span><br><span class="line">        existingDef = originatingDef;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isCompatible(beanDefinition, existingDef)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ConflictingBeanDefinitionException(<span class="string">"冲突啦!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>isCompatible用于判断和之前的BeanDefinition是否兼容:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isCompatible</span><span class="params">(BeanDefinition newDefinition, BeanDefinition existingDefinition)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//// explicitly registered overriding bean</span></span><br><span class="line">    <span class="keyword">return</span> (!(existingDefinition <span class="keyword">instanceof</span> ScannedGenericBeanDefinition) || </span><br><span class="line">            <span class="comment">//// scanned same file twice</span></span><br><span class="line">            newDefinition.getSource().equals(existingDefinition.getSource()) || </span><br><span class="line">            <span class="comment">// scanned equivalent class twice			</span></span><br><span class="line">            newDefinition.equals(existingDefinition));  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<strong>如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的。</strong></p>
<h3 id="代理生成"><a href="#代理生成" class="headerlink" title="代理生成"></a>代理生成</h3><p>入口: ClassPathBeanDefinitionScanner.doScan:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BeanDefinitionHolder definitionHolder = <span class="keyword">new</span> BeanDefinitionHolder(candidate, beanName);</span><br><span class="line">definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="keyword">this</span>.registry);</span><br></pre></td></tr></table></figure>
<p>AnnotationConfigUtils.applyScopedProxyMode:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BeanDefinitionHolder <span class="title">applyScopedProxyMode</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">    ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode();</span><br><span class="line">    <span class="comment">// 基本都是从这里跑了</span></span><br><span class="line">    <span class="keyword">if</span> (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123;</span><br><span class="line">        <span class="keyword">return</span> definition;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS);</span><br><span class="line">    <span class="keyword">return</span> ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点:</p>
<ul>
<li>这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。</li>
<li>被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。</li>
<li>将被代理者以scopedTarget.原名字注册到容器，返回代理者。</li>
<li>代理者和被代理者同时存在于容器中。</li>
</ul>
<p>可以看出，这其实是一个偷天换日的过程。</p>
<p>做个实验:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boostrap</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">        SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">         System.out.println(bean.getClass().getName());</span><br><span class="line">         context.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SimpleBean已开启代理，输出的结果:</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">base.SimpleBean$$EnhancerBySpringCGLIB$$27256c61</span><br></pre></td></tr></table></figure>
<p>那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢?</p>
<p>DefaultListableBeanFactory.getBean(Class<t> requiredType, Object… args)部分源码:</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String[] beanNames = getBeanNamesForType(requiredType);</span><br><span class="line"><span class="comment">//不止一个满足条件(代理者和被代理者)</span></span><br><span class="line"><span class="keyword">if</span> (beanNames.length &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; autowireCandidates = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">         <span class="comment">// here</span></span><br><span class="line">        <span class="keyword">if</span> (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123;</span><br><span class="line">            autowireCandidates.add(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (autowireCandidates.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        beanNames = autowireCandidates.toArray(<span class="keyword">new</span> String[autowireCandidates.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。</p>
<h3 id="BeanDefinition注册"><a href="#BeanDefinition注册" class="headerlink" title="BeanDefinition注册"></a>BeanDefinition注册</h3><p>你懂的。</p>
<h2 id="Component注册"><a href="#Component注册" class="headerlink" title="Component注册"></a>Component注册</h2><p>套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。</p>
<h1 id="property-override"><a href="#property-override" class="headerlink" title="property-override"></a>property-override</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo:</p>
<p>定义如下的属性文件(property.properties):</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">student.name=dog</span><br></pre></td></tr></table></figure>
<p>格式为: bean名字.属性名字=值。由如下的bean:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"skywalker"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"30"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>进行如下的配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"property.properties"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>运行如下的代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"config.xml"</span>);</span><br><span class="line">    SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class));</span><br><span class="line">    System.out.println(bean.getStudent().getName());</span><br><span class="line">    context.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印的便是dog，而不是skywalker。</p>
<h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p>具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下:</p>
<p><img src="PropertyOverrideBeanDefinitionParser.jpg" alt="PropertyOverrideBeanDefinitionParser类图"></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码: </p>
<p>AbstractPropertyLoadingBeanDefinitionParser.doParse:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    String location = element.getAttribute(<span class="string">"location"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(location)) &#123;</span><br><span class="line">        String[] locations = StringUtils.commaDelimitedListToStringArray(location);</span><br><span class="line">        builder.addPropertyValue(<span class="string">"locations"</span>, locations);</span><br><span class="line">    &#125;</span><br><span class="line">    String propertiesRef = element.getAttribute(<span class="string">"properties-ref"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(propertiesRef)) &#123;</span><br><span class="line">        builder.addPropertyReference(<span class="string">"properties"</span>, propertiesRef);</span><br><span class="line">    &#125;</span><br><span class="line">    String fileEncoding = element.getAttribute(<span class="string">"file-encoding"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(fileEncoding)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"fileEncoding"</span>, fileEncoding);</span><br><span class="line">    &#125;</span><br><span class="line">    String order = element.getAttribute(<span class="string">"order"</span>);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(order)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"order"</span>, Integer.valueOf(order));</span><br><span class="line">    &#125;</span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreResourceNotFound"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-resource-not-found"</span>)));</span><br><span class="line">    builder.addPropertyValue(<span class="string">"localOverride"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"local-override"</span>)));</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="properties-ref"><a href="#properties-ref" class="headerlink" title="properties-ref"></a>properties-ref</h3><p>此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span>  <span class="attr">properties-ref</span>=<span class="string">"property"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"property"</span> <span class="attr">class</span>=<span class="string">"java.util.Properties"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"student.name"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样便可以看到结果。</p>
<h3 id="order"><a href="#order" class="headerlink" title="order"></a>order</h3><p>此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。</p>
<h3 id="ignore-resource-not-found"><a href="#ignore-resource-not-found" class="headerlink" title="ignore-resource-not-found"></a>ignore-resource-not-found</h3><p>如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。</p>
<h3 id="ignore-unresolvable"><a href="#ignore-unresolvable" class="headerlink" title="ignore-unresolvable"></a>ignore-unresolvable</h3><p>如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。</p>
<h3 id="local-override"><a href="#local-override" class="headerlink" title="local-override"></a>local-override</h3><p>这个属性让我很迷惑。Spring说是此选项决定”local”的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Properties[] localProperties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set local properties, e.g. via the "props" tag in XML bean definitions.</span></span><br><span class="line"><span class="comment"> * These can be considered defaults, to be overridden by properties</span></span><br><span class="line"><span class="comment"> * loaded from files.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.localProperties = <span class="keyword">new</span> Properties[] &#123;properties&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，这应该就是Spring所说的”local”属性。好，我们来注入一下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span>  <span class="attr">location</span>=<span class="string">"property.properties"</span> <span class="attr">local-override</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"properties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"student.name"</span>&gt;</span>cat<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向”local”注入?(context:property-override不允许子标签存在)</p>
<h3 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图:</p>
<p><img src="PropertyOverrideConfigurer.jpg" alt="PropertyOverrideConfigurer类图"></p>
<h2 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h2><p>入口当然是BeanFactoryPostProcessor.postProcessBeanFactory(PropertyResourceConfigurer):</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 属性加载</span></span><br><span class="line">        Properties mergedProps = mergeProperties();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Convert the merged properties, if necessary.</span></span><br><span class="line">        convertProperties(mergedProps);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Let the subclass process the properties.</span></span><br><span class="line">        processProperties(beanFactory, mergedProps);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanInitializationException(<span class="string">"Could not load properties"</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="属性加载"><a href="#属性加载" class="headerlink" title="属性加载"></a>属性加载</h3><p>PropertiesLoaderSupport.mergeProperties:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Properties <span class="title">mergeProperties</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Properties result = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">        <span class="comment">// Load properties from file upfront, to let local properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.localProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Properties localProp : <span class="keyword">this</span>.localProperties) &#123;</span><br><span class="line">            CollectionUtils.mergePropertiesIntoMap(localProp, result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">        <span class="comment">// Load properties from file afterwards, to let those properties override.</span></span><br><span class="line">        loadProperties(result);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。</p>
<h3 id="属性转换"><a href="#属性转换" class="headerlink" title="属性转换"></a>属性转换</h3><p>convertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。</p>
<h3 id="属性设置"><a href="#属性设置" class="headerlink" title="属性设置"></a>属性设置</h3><p>就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">applyPropertyValue</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ConfigurableListableBeanFactory factory, String beanName, String property, String value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    BeanDefinition bd = factory.getBeanDefinition(beanName);</span><br><span class="line">    <span class="keyword">while</span> (bd.getOriginatingBeanDefinition() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bd = bd.getOriginatingBeanDefinition();</span><br><span class="line">    &#125;</span><br><span class="line">    PropertyValue pv = <span class="keyword">new</span> PropertyValue(property, value);</span><br><span class="line">    pv.setOptional(<span class="keyword">this</span>.ignoreInvalidKeys);</span><br><span class="line">    bd.getPropertyValues().addPropertyValue(pv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>addPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。</p>
<h1 id="property-placeholder"><a href="#property-placeholder" class="headerlink" title="property-placeholder"></a>property-placeholder</h1><p>这个怎么用已经喜闻乐见了</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。</p>
<p>PropertyPlaceholderBeanDefinitionParser.doParse:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.doParse(element, builder);</span><br><span class="line">    builder.addPropertyValue(<span class="string">"ignoreUnresolvablePlaceholders"</span>,</span><br><span class="line">            Boolean.valueOf(element.getAttribute(<span class="string">"ignore-unresolvable"</span>)));</span><br><span class="line">    String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp;</span><br><span class="line">            !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"systemPropertiesModeName"</span>, <span class="string">"SYSTEM_PROPERTIES_MODE_"</span></span><br><span class="line">            + systemPropertiesModeName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"value-separator"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"valueSeparator"</span>, element.getAttribute(<span class="string">"value-separator"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"trim-values"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"trimValues"</span>, element.getAttribute(<span class="string">"trim-values"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(<span class="string">"null-value"</span>)) &#123;</span><br><span class="line">        builder.addPropertyValue(<span class="string">"nullValue"</span>, element.getAttribute(<span class="string">"null-value"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="system-properties-mode"><a href="#system-properties-mode" class="headerlink" title="system-properties-mode"></a>system-properties-mode</h3><p>Spring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。</p>
<h3 id="value-separator"><a href="#value-separator" class="headerlink" title="value-separator"></a>value-separator</h3><p>用于配置默认的值的分隔符:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"base.Student"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"$&#123;student.name:skywalker&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果属性文件里没有student.name，那么就是skywalker。默认就是:。</p>
<h3 id="null-value"><a href="#null-value" class="headerlink" title="null-value"></a>null-value</h3><p>遇到哪些值应该当做空处理，比如可以把空串””设为这个，默认不对任何值进行处理。</p>
<h3 id="trim-values"><a href="#trim-values" class="headerlink" title="trim-values"></a>trim-values</h3><p>是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。</p>
<h3 id="BeanDefinition-1"><a href="#BeanDefinition-1" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h3><p>这次是PropertySourcesPlaceholderConfigurer，其类图:</p>
<p><img src="PropertySourcesPlaceholderConfigurer.jpg" alt="PropertySourcesPlaceholderConfigurer类图"></p>
<h2 id="运行-2"><a href="#运行-2" class="headerlink" title="运行"></a>运行</h2><p>PropertySourcesPlaceholderConfigurer.postProcessBeanFactory：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.propertySources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.propertySources = <span class="keyword">new</span> MutablePropertySources();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.environment != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addLast(</span><br><span class="line">                <span class="keyword">new</span> PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, </span><br><span class="line">                    <span class="keyword">this</span>.environment) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">this</span>.source.getProperty(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        PropertySource&lt;?&gt; localPropertySource =</span><br><span class="line">                <span class="keyword">new</span> PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.localOverride) &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addFirst(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.propertySources.addLast(localPropertySource);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    processProperties(beanFactory, <span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources));</span><br><span class="line">    <span class="keyword">this</span>.appliedPropertySources = <span class="keyword">this</span>.propertySources;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样:</p>
<p>不使用property-placeholder标签，以显式的bean定义代替。</p>
<h3 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h3><p>处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。</p>
<h1 id="load-time-weaver-amp-spring-configured"><a href="#load-time-weaver-amp-spring-configured" class="headerlink" title="load-time-weaver &amp; spring-configured"></a>load-time-weaver &amp; spring-configured</h1><p>这两个配置是紧密相关的，所以在一起说了。</p>
<p>load-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。</p>
<p>可以参考:</p>
<p><a href="http://sexycoding.iteye.com/blog/1062372" target="_blank" rel="noopener">Spring之LoadTimeWeaver——一个需求引发的思考</a></p>
<p><a href="http://www.iteye.com/topic/481813" target="_blank" rel="noopener">Spring LoadTimeWeaver 的那些事儿</a></p>
<h2 id="javaagent"><a href="#javaagent" class="headerlink" title="javaagent"></a>javaagent</h2><p>要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例:</p>
<p>-javaagent:D:\Software\maven-repos\org\springframework\spring-agent\2.5.6.SEC03\spring-agent-2.5.6.SEC03.jar</p>
<p>此jar包的META-INF/MANIFEST.MF文件需要配置如下一行:</p>
<p>Premain-Class: org.springframework.instrument.InstrumentationSavingAge<br> nt</p>
<p>Spring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationSavingAgent</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Instrumentation instrumentation;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span> </span>&#123;</span><br><span class="line">        instrumentation = inst;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instrumentation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。</p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。</p>
<h3 id="LoadTimeWeaver"><a href="#LoadTimeWeaver" class="headerlink" title="LoadTimeWeaver"></a>LoadTimeWeaver</h3><p>此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系:</p>
<p><img src="LoadTimeWeaver.jpg" alt="LoadTimeWeaver继承体系"></p>
<p>LoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">getBeanClassName</span><span class="params">(Element element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果配置了weaver-class属性，那么使用其值</span></span><br><span class="line">    <span class="keyword">if</span> (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">        <span class="keyword">return</span> element.getAttribute(WEAVER_CLASS_ATTRIBUTE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// org.springframework.context.weaving.DefaultContextLoadTimeWeaver</span></span><br><span class="line">    <span class="keyword">return</span> DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个BeanDefinition的id/name又是什么呢?</p>
<p>LoadTimeWeaverBeanDefinitionParser.resolveId:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">resolveId</span><span class="params">(Element element, AbstractBeanDefinition definition, ParserContext 	parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// loadTimeWeaver</span></span><br><span class="line">    <span class="keyword">return</span> ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。</p>
<h3 id="LoadTimeWeaverBeanDefinitionParser"><a href="#LoadTimeWeaverBeanDefinitionParser" class="headerlink" title="LoadTimeWeaverBeanDefinitionParser"></a>LoadTimeWeaverBeanDefinitionParser</h3><p>LoadTimeWeaverBeanDefinitionParser.doParse:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, ParserContext parserContext, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">    builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">    <span class="keyword">if</span> (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) &#123;</span><br><span class="line">            RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME);</span><br><span class="line">            parserContext.registerBeanComponent(</span><br><span class="line">                    <span class="keyword">new</span> BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser().parse(element, parserContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aspectj-weaving"><a href="#aspectj-weaving" class="headerlink" title="aspectj-weaving"></a>aspectj-weaving</h3><p>这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。</p>
<p>此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。</p>
<h3 id="是否开启"><a href="#是否开启" class="headerlink" title="是否开启"></a>是否开启</h3><p>isAspectJWeavingEnabled方法用于判断是否启用:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAspectJWeavingEnabled</span><span class="params">(String value, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"on"</span>.equals(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"off"</span>.equals(value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 寻找aop.xml</span></span><br><span class="line">        ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AspectJWeavingEnabler"><a href="#AspectJWeavingEnabler" class="headerlink" title="AspectJWeavingEnabler"></a>AspectJWeavingEnabler</h3><p>从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图:</p>
<p><img src="AspectJWeavingEnabler.jpg" alt="AspectJWeavingEnabler类图"></p>
<h3 id="SpringConfiguredBeanDefinitionParser"><a href="#SpringConfiguredBeanDefinitionParser" class="headerlink" title="SpringConfiguredBeanDefinitionParser"></a>SpringConfiguredBeanDefinitionParser</h3><p>如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br></pre></td></tr></table></figure>
<p>其parse方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// org.springframework.context.config.internalBeanConfigurerAspect</span></span><br><span class="line">    <span class="keyword">if</span> (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) &#123;</span><br><span class="line">        RootBeanDefinition def = <span class="keyword">new</span> RootBeanDefinition();</span><br><span class="line">         <span class="comment">// org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect</span></span><br><span class="line">        def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME);</span><br><span class="line">        def.setFactoryMethodName(<span class="string">"aspectOf"</span>);</span><br><span class="line">        def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);</span><br><span class="line">        def.setSource(parserContext.extractSource(element));</span><br><span class="line">        parserContext.registerBeanComponent(<span class="keyword">new</span> BeanComponentDefinition</span><br><span class="line">            (def, BEAN_CONFIGURER_ASPECT_BEAN_NAME));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图:</p>
<p><img src="AnnotationBeanConfigurerAspect.jpg" alt="AnnotationBeanConfigurerAspect类图"></p>
<p>AnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。</p>
<p>下面就去aj文件中看看到底定义了哪些pointcut以及advise。</p>
<p>语法可以参考:</p>
<p><a href="http://jinnianshilongnian.iteye.com/blog/1415606" target="_blank" rel="noopener">Spring 之AOP AspectJ切入点详解</a></p>
<h4 id="切点-pointcut"><a href="#切点-pointcut" class="headerlink" title="切点(pointcut)"></a>切点(pointcut)</h4><h5 id="inConfigurableBean"><a href="#inConfigurableBean" class="headerlink" title="inConfigurableBean"></a>inConfigurableBean</h5><p>在AnnotationBeanConfigurerAspect中定义，源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">inConfigurableBean</span><span class="params">()</span> : @<span class="title">this</span><span class="params">(Configurable)</span></span>;</span><br></pre></td></tr></table></figure>
<p>@this没找到相关说明，结合@以及this的语义，猜测是匹配<strong>带有@Configurable注解(以及作为元注解)的类</strong>。</p>
<h5 id="beanConstruction"><a href="#beanConstruction" class="headerlink" title="beanConstruction"></a>beanConstruction</h5><p>源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">beanConstruction</span><span class="params">(Object bean)</span> :</span></span><br><span class="line"><span class="function">            <span class="title">initialization</span><span class="params">(ConfigurableObject+.new(..)</span>) &amp;&amp; <span class="title">this</span><span class="params">(bean)</span></span>;</span><br></pre></td></tr></table></figure>
<p>initialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。</p>
<h5 id="preConstructionCondition"><a href="#preConstructionCondition" class="headerlink" title="preConstructionCondition"></a>preConstructionCondition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> &amp;&amp; <span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>由两个pointcut与运算而来。</p>
<h5 id="leastSpecificSuperTypeConstruction"><a href="#leastSpecificSuperTypeConstruction" class="headerlink" title="leastSpecificSuperTypeConstruction"></a>leastSpecificSuperTypeConstruction</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">leastSpecificSuperTypeConstruction</span><span class="params">()</span> : <span class="title">initialization</span><span class="params">(ConfigurableObject.new(..)</span>)</span>;</span><br></pre></td></tr></table></figure>
<h5 id="preConstructionConfiguration"><a href="#preConstructionConfiguration" class="headerlink" title="preConstructionConfiguration"></a>preConstructionConfiguration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">preConstructionConfiguration</span><span class="params">()</span> : <span class="title">preConstructionConfigurationSupport</span><span class="params">(*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">preConstructionConfigurationSupport</span><span class="params">(Configurable c)</span> : @<span class="title">this</span><span class="params">(c)</span> &amp;&amp; <span class="title">if</span> <span class="params">(c.preConstruction()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>preConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。</p>
<h5 id="postConstructionCondition"><a href="#postConstructionCondition" class="headerlink" title="postConstructionCondition"></a>postConstructionCondition</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> pointcut <span class="title">postConstructionCondition</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> &amp;&amp; !<span class="title">preConstructionConfiguration</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<p>mostSpecificSubTypeConstruction:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> pointcut <span class="title">mostSpecificSubTypeConstruction</span><span class="params">()</span> :</span></span><br><span class="line"><span class="function">            <span class="title">if</span> <span class="params">(thisJoinPoint.getSignature()</span>.<span class="title">getDeclaringType</span><span class="params">()</span> </span>== thisJoinPoint.getThis().getClass());</span><br></pre></td></tr></table></figure>
<p>advise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。</p>
<h4 id="advise"><a href="#advise" class="headerlink" title="advise"></a>advise</h4><h5 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">before(Object bean) :</span><br><span class="line">    beanConstruction(bean) &amp;&amp; preConstructionCondition() &amp;&amp; inConfigurableBean()  &#123;</span><br><span class="line">    configureBean(bean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行-3"><a href="#运行-3" class="headerlink" title="运行"></a>运行</h2><p>AspectJWeavingEnabler.postProcessBeanFactory:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    enableAspectJWeaving(<span class="keyword">this</span>.loadTimeWeaver, <span class="keyword">this</span>.beanClassLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enableAspectJWeaving:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enableAspectJWeaving</span><span class="params">(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不为空</span></span><br><span class="line">    <span class="keyword">if</span> (weaverToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">            weaverToUse = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(beanClassLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No LoadTimeWeaver available"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    weaverToUse.addTransformer(</span><br><span class="line">            <span class="keyword">new</span> AspectJClassBypassingClassFileTransformer(<span class="keyword">new</span> ClassPreProcessorAgentAdapter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="LoadTimeWeaverAware"><a href="#LoadTimeWeaverAware" class="headerlink" title="LoadTimeWeaverAware"></a>LoadTimeWeaverAware</h3><p>AspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢?</p>
<p>当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// loadTimeWeaver</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">    beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">    <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">    beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，关键在于LoadTimeWeaverAwareProcessor，类图:</p>
<p><img src="LoadTimeWeaverAwareProcessor.jpg" alt="LoadTimeWeaverAwareProcessor类图"></p>
<p>postProcessBeforeInitialization方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> LoadTimeWeaverAware) &#123;</span><br><span class="line">        LoadTimeWeaver ltw = <span class="keyword">this</span>.loadTimeWeaver;</span><br><span class="line">        <span class="keyword">if</span> (ltw == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>,</span><br><span class="line">                <span class="string">"BeanFactory required if no LoadTimeWeaver explicitly specified"</span>);</span><br><span class="line">             <span class="comment">// 去容器找 </span></span><br><span class="line">            ltw = <span class="keyword">this</span>.beanFactory.getBean(</span><br><span class="line">                ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class);</span><br><span class="line">        &#125;</span><br><span class="line">        ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。</p>
<p>BeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点:</p>
<p>BeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的:</p>
<p>AbstractApplicationContext.refresh:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"><span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br></pre></td></tr></table></figure>
<p>那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的?</p>
<p>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span> </span>&#123;</span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        result = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>getBeanPostProcessors:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;BeanPostProcessor&gt; <span class="title">getBeanPostProcessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.beanPostProcessors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br></pre></td></tr></table></figure>
<p>直接将实例添加到BeanFactory中，所以可以得出结论:</p>
<p><strong>我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加</strong>。</p>
<h3 id="BeanClassLoaderAware"><a href="#BeanClassLoaderAware" class="headerlink" title="BeanClassLoaderAware"></a>BeanClassLoaderAware</h3><h4 id="入口-3"><a href="#入口-3" class="headerlink" title="入口"></a>入口</h4><p>DefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢?</p>
<p>AbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="setBeanClassLoader"><a href="#setBeanClassLoader" class="headerlink" title="setBeanClassLoader"></a>setBeanClassLoader</h4><p>这个方法很关键，对instrument的获取就是在这里。源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanClassLoader</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (serverSpecificLoadTimeWeaver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = serverSpecificLoadTimeWeaver;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> InstrumentationLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loadTimeWeaver = <span class="keyword">new</span> ReflectiveLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显分为三部分。</p>
<h5 id="服务器agent"><a href="#服务器agent" class="headerlink" title="服务器agent"></a>服务器agent</h5><p>Spring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器:</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>createServerSpecificLoadTimeWeaver源码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> LoadTimeWeaver <span class="title">createServerSpecificLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String name = classLoader.getClass().getName();</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"weblogic"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebLogicLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.glassfish"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GlassFishLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.apache.catalina"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TomcatLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"org.jboss"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JBossLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"com.ibm"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WebSphereLoadTimeWeaver(classLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，<strong>对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现</strong>。</p>
<p>这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。</p>
<h5 id="Spring-agent"><a href="#Spring-agent" class="headerlink" title="Spring agent"></a>Spring agent</h5><p>这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isInstrumentationAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getInstrumentation() != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AGENT_CLASS_PRESENT) &#123;</span><br><span class="line">        <span class="keyword">return</span> InstrumentationAccessor.getInstrumentation();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。</p>
<p>InstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstrumentationAccessor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstrumentationSavingAgent.getInstrumentation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。</p>
<h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><p>在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW…)，检测的源码位于ReflectiveLoadTimeWeaver的构造器:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(ClassUtils.getDefaultClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveLoadTimeWeaver</span><span class="params">(ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(classLoader, <span class="string">"ClassLoader must not be null"</span>);</span><br><span class="line">    <span class="keyword">this</span>.classLoader = classLoader;</span><br><span class="line">    <span class="keyword">this</span>.addTransformerMethod = ClassUtils.getMethodIfAvailable(</span><br><span class="line">            <span class="keyword">this</span>.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.addTransformerMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档:</p>
<p><a href="http://www.eclipse.org/aspectj/doc/released/devguide/ltw-configuration.html#enabling-load-time-weaving" target="_blank" rel="noopener">Chapter 5. Load-Time Weaving</a></p>
<h3 id="ClassFileTransformer"><a href="#ClassFileTransformer" class="headerlink" title="ClassFileTransformer"></a>ClassFileTransformer</h3><p>从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。</p>
<p>AspectJClassBypassingClassFileTransformer.transform:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined,</span><br><span class="line">        ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) &#123;</span><br><span class="line">    <span class="comment">// aspectj自身的类无需检测(织入)，直接跳过</span></span><br><span class="line">    <span class="keyword">if</span> (className.startsWith(<span class="string">"org.aspectj"</span>) || className.startsWith(<span class="string">"org/aspectj"</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.delegate.transform(loader, className, classBeingRedefined, </span><br><span class="line">        protectionDomain, classfileBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>delegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图:</p>
<p><img src="ClassPreProcessorAgentAdapter.jpg" alt="ClassPreProcessorAgentAdapter类图"></p>
<p>根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4.</p>
<h3 id="Aj"><a href="#Aj" class="headerlink" title="Aj"></a>Aj</h3><p>Aj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><p>Aj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。</p>
<h4 id="WeavingAdaptor初始化"><a href="#WeavingAdaptor初始化" class="headerlink" title="WeavingAdaptor初始化"></a>WeavingAdaptor初始化</h4><p>初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。</p>
<h5 id="aop-xml"><a href="#aop-xml" class="headerlink" title="aop.xml"></a>aop.xml</h5><h6 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h6><p>aop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的:</p>
<p>以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.AnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.AnnotationCacheAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"org.springframework.cache.aspectj.JCacheCacheAspect"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么解析后的结果:</p>
<p><img src="aop_xml_parse.png" alt="aop.xml解析结果"></p>
<h6 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h6><p>入口方法在ClassLoaderWeavingAdaptor.registerDefinitions:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">registerDefinitions</span><span class="params">(<span class="keyword">final</span> BcelWeaver weaver, <span class="keyword">final</span> ClassLoader loader, List&lt;Definition&gt; definitions)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对应&lt;weaver options="-verbose"&gt;</span></span><br><span class="line">    registerOptions(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;exclude&gt;标签</span></span><br><span class="line">    registerAspectExclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;include&gt;标签</span></span><br><span class="line">    registerAspectInclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">// &lt;aspect&gt;</span></span><br><span class="line">    success = registerAspects(weaver, loader, definitions);</span><br><span class="line">    registerIncludeExclude(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//对应&lt;dump&gt;标签</span></span><br><span class="line">    registerDump(weaver, loader, definitions);</span><br><span class="line">    <span class="comment">//忽略返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>Spring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。</p>
<h1 id="申明"><a href="#申明" class="headerlink" title="申明"></a>申明</h1><p>本文转载自seaswalker的<a href="https://github.com/seaswalker/Spring" target="_blank" rel="noopener">github</a>，<a href="https://github.com/seaswalker/Spring/issues/1" target="_blank" rel="noopener">转载授权</a>，由<a href="https://satra.tk/">我在万达摆地摊</a>整理发布。</p>

            
            

            
                <div class="article-copyright">
                    <p>本文首发于<a href="https://satra.tk/posts/59179/index.html">我在万达摆地摊&#39;s blog</a>，转载请注明来源</p>
                </div>
            
        
        </div>
        <footer class="article-footer">
            <div class="share-container">



</div>

            
    

        </footer>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/posts/24249/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">上一篇</strong>
            <div class="article-nav-title">
                
                    spring task源码分析
                
            </div>
        </a>
    
    
        <a href="/posts/46171/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">下一篇</strong>
            <div class="article-nav-title">spring aop源码分析</div>
        </a>
    
</nav>


    
</article>


    
    

</section>
            
                
<aside id="sidebar">
   
        
    <div class="widget-wrap">
        <h3 class="widget-title">最新文章</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/spring/">spring</a></p>
                            <p class="item-title"><a href="/posts/15220/" class="title">spring mvc源码分析</a></p>
                            <p class="item-date"><time datetime="2018-10-05T07:03:57.000Z" itemprop="datePublished">2018-10-05</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/spring/">spring</a></p>
                            <p class="item-title"><a href="/posts/3531/" class="title">spring transaction源码分析</a></p>
                            <p class="item-date"><time datetime="2018-10-05T06:57:50.000Z" itemprop="datePublished">2018-10-05</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/spring/">spring</a></p>
                            <p class="item-title"><a href="/posts/24249/" class="title">spring task源码分析</a></p>
                            <p class="item-date"><time datetime="2018-10-05T06:40:31.000Z" itemprop="datePublished">2018-10-05</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/spring/">spring</a></p>
                            <p class="item-title"><a href="/posts/59179/" class="title">spring context源码分析</a></p>
                            <p class="item-date"><time datetime="2018-06-06T15:19:43.000Z" itemprop="datePublished">2018-06-06</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/spring/">spring</a></p>
                            <p class="item-title"><a href="/posts/46171/" class="title">spring aop源码分析</a></p>
                            <p class="item-date"><time datetime="2018-06-06T04:08:31.000Z" itemprop="datePublished">2018-06-06</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">分类</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java容器/">Java容器</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发/">Java并发</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java虚拟机/">Java虚拟机</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/spring/">spring</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据分析/">数据分析</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构与算法/">数据结构与算法</a><span class="category-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">归档</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">十月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">六月 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">四月 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">十二月 2017</a><span class="archive-list-count">1</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签</h3>
        <div class="widget">
            <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java容器/">Java容器</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java并发/">Java并发</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java虚拟机/">Java虚拟机</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/spring/">spring</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据分析/">数据分析</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构与算法/">数据结构与算法</a><span class="tag-list-count">2</span></li></ul>
        </div>
    </div>

    
        
    <div class="widget-wrap">
        <h3 class="widget-title">标签云</h3>
        <div class="widget tagcloud">
            <a href="/tags/Java/" style="font-size: 10px;">Java</a> <a href="/tags/Java容器/" style="font-size: 14px;">Java容器</a> <a href="/tags/Java并发/" style="font-size: 20px;">Java并发</a> <a href="/tags/Java虚拟机/" style="font-size: 16px;">Java虚拟机</a> <a href="/tags/spring/" style="font-size: 18px;">spring</a> <a href="/tags/数据分析/" style="font-size: 10px;">数据分析</a> <a href="/tags/数据结构与算法/" style="font-size: 12px;">数据结构与算法</a>
        </div>
    </div>

    
        
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">链接</h3>
        <div class="widget">
            <ul>
                
                    <li>
                        <a href="http://woquanke.com/">全科</a>
                    </li>
                
            </ul>
        </div>
    </div>


    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>

            
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            &copy; 2018 我在万达摆地摊
        </div>
    </div>
</footer>
        


    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>