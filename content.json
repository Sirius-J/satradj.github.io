{"meta":{"title":"我在万达摆地摊's blog","subtitle":"欢迎来到'我在万达摆地摊'的博客","description":"一位在靠在万达摆地摊才能勉强存活的码农","author":"我在万达摆地摊","url":"https://satra.tk"},"pages":[{"title":"我的书单","date":"2018-02-06T12:13:17.390Z","updated":"2018-02-06T12:13:17.390Z","comments":true,"path":"books/index.html","permalink":"https://satra.tk/books/index.html","excerpt":"","text":"对于我们程序员而言，最好的提升自己的方式就是看技术类书籍。毕竟看视频学习一个知识点与看书学习一个知识点相比太费时间；网上虽然有较多的博客文章类资源，但是相比书籍而言，缺乏系统性，而有些博客文章只是简单的复制粘贴，其内容正确与否完全不顾。所以，读一本好书，对于程序员的提升毋庸置疑的。 我在这里贴出我的个人书单供大家参考交流，书单不定期更新。 Java语言类Java基础 《Java编程思想（第4版）》 《Effective java 中文版（第2版）》 Java并发 《Java并发编程实战》 《Java并发编程的艺术》 Java虚拟机 《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 《Java性能优化权威指南》 软件工程设计模式 《Head First 设计模式（中文版）》 《重构》 算法 《算法（第4版）》 架构 《Netty实战》 《大型网站技术架构》 机器学习 《数学之美》 《机器学习实战》 数据库 《高性能MySQL》 《MySQL技术内幕-InnoDB存储引擎》"},{"title":"About","date":"2018-02-04T08:58:33.085Z","updated":"2018-02-04T08:58:33.085Z","comments":true,"path":"about/index.html","permalink":"https://satra.tk/about/index.html","excerpt":"","text":"网名来源：我在万达摆地摊，一位靠着在万达摆地摊才能勉强维持生计，生活在水生火热之中的码农。 我的技能IT技能：会一点Java和python，玩过几天大数据，了解一点点机器学习，会写一丢丢前端页面。 其他技能：会用PS，会一点点PR剪辑视频，懂得AE套模板。"},{"title":"Categories","date":"2018-01-24T06:53:10.927Z","updated":"2018-01-24T06:53:10.927Z","comments":true,"path":"categories/index.html","permalink":"https://satra.tk/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"spring mvc源码分析","slug":"spring-mvc源码分析","date":"2018-10-05T07:03:57.000Z","updated":"2018-10-05T09:24:01.307Z","comments":true,"path":"posts/15220/","link":"","permalink":"https://satra.tk/posts/15220/","excerpt":"初始化spring-mvc的核心便是DispatcherServlet，所以初始化也是围绕其展开的。类图: Servlet标准定义了init方法是其生命周期的初始化方法。","text":"初始化spring-mvc的核心便是DispatcherServlet，所以初始化也是围绕其展开的。类图: Servlet标准定义了init方法是其生命周期的初始化方法。 HttpServletBean.init: 123456789101112131415@Overridepublic final void init() throws ServletException &#123; // Set bean properties from init parameters. PropertyValues pvs = new ServletConfigPropertyValues(getServletConfig(), this.requiredProperties); //包装DispatcherServlet，准备放入容器 BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(this); //用以加载spring-mvc配置文件 ResourceLoader resourceLoader = new ServletContextResourceLoader(getServletContext()); bw.registerCustomEditor(Resource.class, new ResourceEditor(resourceLoader, getEnvironment())); //没有子类实现此方法 initBeanWrapper(bw); bw.setPropertyValues(pvs, true); // Let subclasses do whatever initialization they like. initServletBean();&#125; 主要逻辑一目了然。注意setPropertyValues方法会导致对DispatcherServlet相关setter方法的调用，所以当进行容器初始化时从init-param中读取的参数已被设置到DispatcherServlet的相关字段(Field)中。 容器初始化FrameworkServlet.initServletBean简略版源码: 123456@Overrideprotected final void initServletBean() &#123; this.webApplicationContext = initWebApplicationContext(); //空实现，且没有子类覆盖 initFrameworkServlet()&#125; FrameworkServlet.initWebApplicationContext: 12345678910111213141516171819202122232425262728293031323334protected WebApplicationContext initWebApplicationContext() &#123; //根容器查找 WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(getServletContext()); WebApplicationContext wac = null; if (this.webApplicationContext != null) &#123; //有可能DispatcherServlet被作为Spring bean初始化，且webApplicationContext已被注入进来 wac = this.webApplicationContext; if (wac instanceof ConfigurableWebApplicationContext) &#123; ConfigurableWebApplicationContext cwac = (ConfigurableWebApplicationContext) wac; if (!cwac.isActive()) &#123; if (cwac.getParent() == null) &#123; cwac.setParent(rootContext); &#125; configureAndRefreshWebApplicationContext(cwac); &#125; &#125; &#125; if (wac == null) &#123; //是否已经存在于ServletContext中 wac = findWebApplicationContext(); &#125; if (wac == null) &#123; wac = createWebApplicationContext(rootContext); &#125; if (!this.refreshEventReceived) &#123; onRefresh(wac); &#125; if (this.publishContext) &#123; String attrName = getServletContextAttributeName(); getServletContext().setAttribute(attrName, wac); &#125; return wac;&#125; 下面分部分展开。 根容器查找spring-mvc支持Spring容器与MVC容器共存，此时，Spring容器即根容器，mvc容器将根容器视为父容器。 Spring容器(根容器)以下列形式进行配置(web.xml): 123&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 根据Servlet规范，各组件的加载 顺序如下: listener -&gt; filter -&gt; servlet WebApplicationContextUtils.getWebApplicationContext: 1234String ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE = WebApplicationContext.class.getName() + \".ROOT\";public static WebApplicationContext getWebApplicationContext(ServletContext sc) &#123; return getWebApplicationContext(sc, WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);&#125; 两参数方法: 1234567public static WebApplicationContext getWebApplicationContext(ServletContext sc, String attrName) &#123; Object attr = sc.getAttribute(attrName); if (attr == null) &#123; return null; &#125; return (WebApplicationContext) attr;&#125; 可以得出结论: 如果Spring根容器存在，那么它被保存在ServletContext中，其key为WebApplicationContext.class.getName() + &quot;.ROOT&quot;。 容器创建FrameworkServlet.createWebApplicationContext: 12345678910111213protected WebApplicationContext createWebApplicationContext(ApplicationContext parent) &#123; Class&lt;?&gt; contextClass = getContextClass(); if (!ConfigurableWebApplicationContext.class.isAssignableFrom(contextClass)) &#123; throw new ApplicationContextException(); &#125; ConfigurableWebApplicationContext wac = (ConfigurableWebApplicationContext) BeanUtils.instantiateClass(contextClass); wac.setEnvironment(getEnvironment()); wac.setParent(parent); wac.setConfigLocation(getContextConfigLocation()); configureAndRefreshWebApplicationContext(wac); return wac;&#125; 通过对getContextClass方法的调用，Spring允许我们自定义容器的类型，即我们可以在web.xml中如下配置: 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置文件位置 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 容器类型 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextClass&lt;/param-name&gt; &lt;param-value&gt;java.lang.Object&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; configureAndRefreshWebApplicationContext核心源码: 1234protected void configureAndRefreshWebApplicationContext(ConfigurableWebApplicationContext wac) &#123; applyInitializers(wac); wac.refresh();&#125; ApplicationContextInitializerApplicationContextInitializer允许我们在Spring(mvc)容器初始化之前干点坏事，可以通过init-param传入: 1234&lt;init-param&gt; &lt;param-name&gt;contextInitializerClasses&lt;/param-name&gt; &lt;param-value&gt;坏事儿&lt;/param-value&gt;&lt;/init-param&gt; applyInitializers方法正是要触发这些坏事儿。类图: 配置解析“配置”指的便是spring-servlet.xml: 1234567891011&lt;context:component-scan base-package=\"controller\"/&gt;&lt;mvc:annotation-driven/&gt;&lt;!-- 启用对静态资源使用默认servlet处理，非REST方式不需要 --&gt;&lt;mvc:default-servlet-handler/&gt;&lt;!-- 配置视图 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt; &lt;!-- viewClass属性必不可少 --&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"&gt;&lt;/property&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt; 而解析的入口便在于对refresh方法的调用，此方法位于AbstractApplicationContext，这一点在spring-core时已经见过了，下面我们重点关注不同于spring-core的地方。 对于spring-mvc来说，其容器默认为XmlWebApplicationContext，部分类图: XmlWebApplicationContext通过重写loadBeanDefinitions方法改变了bean加载行为，使其指向spring-servlet.xml。 spring-servlet.xml中不同于spring-core的地方便在于引入了mvc命名空间，正如spring-core中笔记中所说的那样，Spring用过jar包/META-INFO中的.handlers文件定义针对不同的命名空间所使用的解析器。 mvc命名空间的解析器为MvcNamespaceHandler，部分源码: 12345678@Overridepublic void init() &#123; registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser()); registerBeanDefinitionParser(\"default-servlet-handler\", new DefaultServletHandlerBeanDefinitionParser()); registerBeanDefinitionParser(\"interceptors\", new IanterceptorsBeanDefinitionParser()); registerBeanDefinitionParser(\"view-resolvers\", new ViewResolversBeanDefinitionParser());&#125; 老样子，按部分展开。 注解驱动其parse方法负责向Sprng容器注册一些必要的组件，整理如下图: 静态资源处理即: 1&lt;mvc:default-servlet-handler/&gt; DefaultServletHandlerBeanDefinitionParser.parse负责向容器注册以下三个组件: DefaultServletHttpRequestHandler SimpleUrlHandlerMapping HttpRequestHandlerAdapter 拦截器InterceptorsBeanDefinitionParser.parse方法负责将每一项mvc:interceptor配置解析为一个MappedInterceptor bean并注册到容器中。 视图有两种方式向Spring容器注册视图: 以前采用较土的方式: 123456&lt;bean class=\"org.springframework.web.servlet.view.UrlBasedViewResolver\"&gt; &lt;!-- viewClass属性必不可少 --&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"&gt;&lt;/property&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt; 通过特定的标签: 123&lt;mvc:view-resolvers&gt; &lt;mvc:jsp view-class=\"\" /&gt;&lt;/mvc:view-resolvers&gt; 从这里可以推测出: 拦截器同样支持第一种方式，Spring在查找时应该会查询某一接口的子类。 ViewResolversBeanDefinitionParser.parse方法的作用便是将每一个视图解析为ViewResolver并注册到容器。 Scope/处理器注册AbstractRefreshableWebApplicationContext.postProcessBeanFactory: 12345678910@Overrideprotected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; beanFactory.addBeanPostProcessor( new ServletContextAwareProcessor(this.servletContext, this.servletConfig)); beanFactory.ignoreDependencyInterface(ServletContextAware.class); beanFactory.ignoreDependencyInterface(ServletConfigAware.class); WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext); WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);&#125; ServletContextAwareProcessor用以向实现了ServletContextAware的bean注册ServletContext。 registerWebApplicationScopes用以注册”request”, “session”, “globalSession”, “application”四种scope，scope是个什么东西以及如何自定义，在spring-core中已经进行过说明了。 registerEnvironmentBeans用以将servletContext、servletConfig以及各种启动参数注册到Spring容器中。 MVC初始化入口位于DispatcherServlet的initStrategies方法(经由onRefresh调用): 1234567891011protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context);&#125; 显然，这里就是spring-mvc的核心了。 文件上传支持initMultipartResolver核心源码: 12345678private void initMultipartResolver(ApplicationContext context) &#123; try &#123; this.multipartResolver = context.getBean(MULTIPART_RESOLVER_BEAN_NAME, MultipartResolver.class); &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Default is no multipart resolver. this.multipartResolver = null; &#125;&#125; MultipartResolver用于开启Spring MVC文件上传功能，其类图: 也就是说，如果我们要使用文件上传功能，须在容器中注册一个MultipartResolver bean。当然，默认是没有的。 地区解析器LocaleResolver接口定义了Spring MVC如何获取客户端(浏览器)的地区，initLocaleResolver方法在容器中寻找此bean，如果没有，注册AcceptHeaderLocaleResolver，即根据request的请求头Accept-Language获取地区。 spring-mvc采用了属性文件的方式配置默认策略(即bean)，此文件位于spring-mvc的jar包的org.springframework.web.servlet下。 主题解析器ThemeResolver接口配合Spring标签库使用可以通过动态决定使用的css以及图片的方式达到换肤的效果，其类图: 如果容器中不存在叫做themeResolver的bean，initThemeResolver方法将向容器中注册FixedThemeResolver，此bean只能提供一套默认的主题，名为theme。 HandlerMapping检查initHandlerMappings方法用于确保容器中至少含有一个HandlerMapping对象。从前面配置解析-注解驱动一节中可以看出，注解驱动导致已经注册了两个此对象。 如果没有开启注解驱动，那么将会使用默认的HandlerMapping，相关源码: 123456if (this.handlerMappings == null) &#123; this.handlerMappings = getDefaultStrategies(context, HandlerMapping.class); if (logger.isDebugEnabled()) &#123; logger.debug(\"No HandlerMappings found in servlet '\" + getServletName() + \"': using default\"); &#125;&#125; 前面提到了，默认的策略由DispatcherServlet.properties决定，目前是BeanNameUrlHandlerMapping和DefaultAnnotationHandlerMapping。 HandlerAdapter检查套路和上面完全一样，默认使用HttpRequestHandlerAdapter、SimpleControllerHandlerAdapter和AnnotationMethodHandlerAdapter。 HandlerExceptionResolver检查套路和上面完全一样，默认使用AnnotationMethodHandlerExceptionResolver、ResponseStatusExceptionResolver、DefaultHandlerExceptionResolver。 RequestToViewNameTranslatorinitRequestToViewNameTranslator方法回向容器中注册一个DefaultRequestToViewNameTranslator对象，此接口用以完成从HttpServletRequest到视图名的解析，其使用场景是给定的URL无法匹配任何控制器时。 DefaultRequestToViewNameTranslator的转换例子: http://localhost:8080/gamecast/display.html -&gt; display(视图) 其类图: ViewResolver检查熟悉的套路，默认使用InternalResourceViewResolver。 FlashMapManagerinitFlashMapManager方法会向容器注册SessionFlashMapManager对象，类图: 此接口和FlashMap搭配使用，用于在请求重定向时保存/传递参数。 HandlerMapping初始化此接口用以根据请求的URL寻找合适的处理器。从前面配置解析一节可以看出，我们的容器中有三个HandlerMapping实现，下面以RequestMappingHandlerMapping位代表进行说明。 RequestMappingHandlerMapping此实现根据@Controller和@RequestMapping注解完成解析。类图(忽略部分接口): 初始化的入口位于AbstractHandlerMethodMapping的afterPropertiesSet方法和AbstractHandlerMapping的initApplicationContext方法，afterPropertiesSet调用了initHandlerMethods: 123456789101112131415161718protected void initHandlerMethods() &#123; //获取容器中所有的bean String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ? BeanFactoryUtils.beanNamesForTypeIncludingAncestors(getApplicationContext(), Object.class) :getApplicationContext().getBeanNamesForType(Object.class)); for (String beanName : beanNames) &#123; if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123; Class&lt;?&gt; beanType = null; beanType = getApplicationContext().getType(beanName); //isHandler方法的原理: //判断类上有没有@Controller注解或者是@RequestMapping注解 if (beanType != null &amp;&amp; isHandler(beanType)) &#123; detectHandlerMethods(beanName); &#125; &#125; &#125; //空实现 handlerMethodsInitialized(getHandlerMethods());&#125; detectHandlerMethods方法将反射遍历类中所有的public方法，如果方法上含有@RequestMapping注解，那么将方法上的路径与类上的基础路径(如果有)进行合并，之后将映射(匹配关系)注册到MappingRegistry中。 注意，类上的@RequestMapping注解只能作为基路径存在，也就是说，如果类里面没有任何的方法级@RequestMapping注解，那么类上的注解是没有意义的。这一点可以从实验和源码上得到证实。 下面我们关注一下映射关系是如何保存(注册)的。 内部类AbstractHandlerMethodMapping.MappingRegistry是映射的载体，类图: 其register方法简略版源码: 12345678910111213141516171819public void register(T mapping, Object handler, Method method) &#123; //包装bean和方法 HandlerMethod handlerMethod = createHandlerMethod(handler, method); this.mappingLookup.put(mapping, handlerMethod); List&lt;String&gt; directUrls = getDirectUrls(mapping); for (String url : directUrls) &#123; this.urlLookup.add(url, mapping); &#125; String name = null; if (getNamingStrategy() != null) &#123; name = getNamingStrategy().getName(handlerMethod, mapping); addMappingName(name, handlerMethod); &#125; CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping); if (corsConfig != null) &#123; this.corsLookup.put(handlerMethod, corsConfig); &#125; this.registry.put(mapping, new MappingRegistration&lt;T&gt;(mapping, handlerMethod, directUrls, name));&#125; mapping其实是一个RequestMappingInfo对象，可以将其看做是@RequestMapping注解各种属性的一个封装。最终由RequestMappingInfo.createRequestMappingInfo方法创建，源码: 1234567891011121314protected RequestMappingInfo createRequestMappingInfo( RequestMapping requestMapping, RequestCondition&lt;?&gt; customCondition) &#123; return RequestMappingInfo .paths(resolveEmbeddedValuesInPatterns(requestMapping.path())) .methods(requestMapping.method()) .params(requestMapping.params()) .headers(requestMapping.headers()) .consumes(requestMapping.consumes()) .produces(requestMapping.produces()) .mappingName(requestMapping.name()) .customCondition(customCondition) .options(this.config) .build();&#125; 这就很明显了，具体每种属性什么意义可以参考@RequestMapping源码。 register方法中urlLookup其实就是将paths属性中的每个path都与处理器做映射。 getNamingStrategy方法得到的是一个HandlerMethodMappingNamingStrategy接口的实例，此接口用以根据HandlerMethod得到一个名字，类图: 比如对于我们的控制器,SimpleController.echo方法，最终得到的名字将是SC#echo。 跨域请求spring-mvc自4.2开启加入了跨域请求Cors的支持，主要有两种配置方式: xml: 123&lt;mvc:cors&gt; &lt;mvc:mapping path=\"\"/&gt;&lt;/mvc:cors&gt; @CrossOrigin注解。 Cors的原理可以参考: 探讨跨域请求资源的几种方式 而initCorsConfiguration方法的作用便是将@CrossOrigin注解的各种属性封装在CorsConfiguration中。 拦截器初始化AbstractHandlerMapping.initApplicationContext: 1234@Overrideprotected void initApplicationContext() throws BeansException &#123; detectMappedInterceptors(this.adaptedInterceptors);&#125; 作用就是从容器中获取所有MappedInterceptor bean并放到adaptedInterceptors中，前面提到过了，我们使用mvc:interceptor定义的拦截器其实就是MappedInterceptor对象。类图: HandlerAdapter初始化同样，我们以RequestMappingHandlerAdapter为例进行说明，类图: 显然，入口在afterPropertiesSet方法: 1234567891011121314151617181920@Overridepublic void afterPropertiesSet() &#123; // Do this first, it may add ResponseBody advice beans initControllerAdviceCache(); if (this.argumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultArgumentResolvers(); this.argumentResolvers = new HandlerMethodArgumentResolverComposite() .addResolvers(resolvers); &#125; if (this.initBinderArgumentResolvers == null) &#123; List&lt;HandlerMethodArgumentResolver&gt; resolvers = getDefaultInitBinderArgumentResolvers(); this.initBinderArgumentResolvers = new HandlerMethodArgumentResolverComposite() .addResolvers(resolvers); &#125; if (this.returnValueHandlers == null) &#123; List&lt;HandlerMethodReturnValueHandler&gt; handlers = getDefaultReturnValueHandlers(); this.returnValueHandlers = new HandlerMethodReturnValueHandlerComposite() .addHandlers(handlers); &#125;&#125; @ControllerAdviceinitControllerAdviceCache方法用以解析并存储标注了@ControllerAdvice的bean，这东西是干什么的参考： Spring3.2新注解@ControllerAdvice 参数解析器HandlerMethodArgumentResolver即参数解析器，负责从request中解析、得到Controller方法所需的参数。afterPropertiesSet方法设置了一组默认的解析器。具体是哪些参考getDefaultArgumentResolvers方法。类图: @InitBinder支持此注解定义的其实是自定义类型转换器。使用方法参考: springMVC @initBinder 使用 getDefaultInitBinderArgumentResolvers返回了一组默认使用的转换器，不过其实这里的转换器和上面的参数解析器其实是一个类型的，这里留个坑。 返回结果解析器HandlerMethodReturnValueHandler接口用以处理方法调用(Controller方法)的返回值，类图: getDefaultReturnValueHandlers方法便返回了一坨这东西。 请求响应我们先来看一下入口在哪。众所周知，Servlet标准定义了所有请求先由service方法处理，如果是get或post方法，那么再交由doGet或是doPost方法处理。 FrameworkServlet覆盖了service方法: 123456789@Overrideprotected void service(HttpServletRequest request, HttpServletResponse response) &#123; HttpMethod httpMethod = HttpMethod.resolve(request.getMethod()); if (HttpMethod.PATCH == httpMethod || httpMethod == null) &#123; processRequest(request, response); &#125; else &#123; super.service(request, response); &#125;&#125; Spring要覆盖此方法的目的在于拦截PATCH请求，PATCH请求与PUT类似，不同在于PATCH是局部更新，而后者是全部更新。可以参考: PATCH和PUT方法的区别？ FrameworkServlet同样也覆盖了doGet和doPost方法，两者只是调用processRequest方法。 请求上下文Spring MVC会在请求分发之前进行上下文的准备工作，含两部分: 将地区(Locale)和请求属性以ThreadLocal的方法与当前线程进行关联，分别可以通过LocaleContextHolder和RequestContextHolder进行获取。 将WebApplicationContext、FlashMap等组件放入到Request属性中。 请求分发DispatcherServlet.doDispatch简略版源码: 12345678protected void doDispatch(HttpServletRequest request, HttpServletResponse response) &#123; HandlerExecutionChain mappedHandler = getHandler(processedRequest); HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); applyDefaultViewName(processedRequest, mv); mappedHandler.applyPostHandle(processedRequest, response, mv); processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);&#125; 处理器查找即为请求寻找合适的Controller的过程。DispatcherServlet.getHandler: 123456789protected HandlerExecutionChain getHandler(HttpServletRequest request) &#123; for (HandlerMapping hm : this.handlerMappings) &#123; HandlerExecutionChain handler = hm.getHandler(request); if (handler != null) &#123; return handler; &#125; &#125; return null;&#125; 从这里可以看出，寻找处理器实际上委托给HandlerMapping实现，寻找的过程便是遍历所有的HandlerMapping进行查找，一旦找到，那么不再继续进行遍历。也就是说HandlerMapping之间有优先级的概念，而根据AnnotationDrivenBeanDefinitionParser的注释，RequestMappingHandlerMapping其实有最高的优先级。 AbstractHandlerMapping.getHandler: 1234567891011121314@Overridepublic final HandlerExecutionChain getHandler(HttpServletRequest request) throws Exception &#123; Object handler = getHandlerInternal(request); HandlerExecutionChain executionChain = getHandlerExecutionChain(handler, request); //判断请求头中是否有ORIGIN字段 if (CorsUtils.isCorsRequest(request)) &#123; CorsConfiguration globalConfig = this.corsConfigSource.getCorsConfiguration(request); CorsConfiguration handlerConfig = getCorsConfiguration(handler, request); CorsConfiguration config = (globalConfig != null ? globalConfig.combine(handlerConfig) : handlerConfig); executionChain = getCorsHandlerExecutionChain(request, executionChain, config); &#125; return executionChain;&#125; getHandlerInternal方法便是根据url进行查找的过程，可以参见MVC初始化-HandlerMapping初始化一节。下面重点是执行链的生成。 getHandlerExecutionChain方法的原理就是从adaptedInterceptors中获得所有可以适配当前请求URL的MappedInterceptor并将其添加到HandlerExecutionChain的拦截器列表中。拦截器的顺序其实就是我们定义/注册的顺序。 从getCorsHandlerExecutionChain的源码中可以看出，对于跨域请求其实是向调用链插入了一个CorsInterceptor。 适配器查找DispatcherServlet.getHandlerAdapter: 1234567protected HandlerAdapter getHandlerAdapter(Object handler) &#123; for (HandlerAdapter ha : this.handlerAdapters) &#123; if (ha.supports(handler)) &#123; return ha; &#125; &#125;&#125; 从前面配置解析-注解驱动可以看出，第一个适配器是RequestMappingHandlerAdapter，而其support方法直接返回true，这就导致了使用的适配器总是这一个。 请求处理RequestMappingHandlerAdapter.handleInternal: 123456789101112131415161718192021222324252627282930@Overrideprotected ModelAndView handleInternal(HttpServletRequest request, HttpServletResponse response, HandlerMethod handlerMethod)&#123; ModelAndView mav; // Execute invokeHandlerMethod in synchronized block if required. if (this.synchronizeOnSession) &#123; HttpSession session = request.getSession(false); if (session != null) &#123; Object mutex = WebUtils.getSessionMutex(session); synchronized (mutex) &#123; mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No HttpSession available -&gt; no mutex necessary mav = invokeHandlerMethod(request, response, handlerMethod); &#125; &#125; else &#123; // No synchronization on session demanded at all... mav = invokeHandlerMethod(request, response, handlerMethod); &#125; if (!response.containsHeader(HEADER_CACHE_CONTROL)) &#123; if (getSessionAttributesHandler(handlerMethod).hasSessionAttributes()) &#123; applyCacheSeconds(response, this.cacheSecondsForSessionAttributeHandlers); &#125; else &#123; prepareResponse(response); &#125; &#125; return mav;&#125; Session同步可以看出，如果开启了synchronizeOnSession，那么同一个session的请求将会串行执行，这一选项默认是关闭的，当然我们可以通过注入的方式进行改变。 参数解析策略模式正如前面HandlerAdapter初始化-参数解析器一节提到的，HandlerAdapter内部含有一组解析器负责对各类型的参数进行解析。下面我们就常用的自定义参数和Model为例进行说明。 自定义参数解析由RequestParamMethodArgumentResolver完成。 supportsParameter方法决定了一个解析器可以解析的参数类型，该解析器支持@RequestParam标准的参数或是简单类型的参数，具体参见其注释。为什么此解析器可以同时解析@RequestParam注解和普通参数呢?玄机在于RequestMappingHandlerAdapter方法在初始化参数解析器时其实初始化了两个RequestMappingHandlerAdapter对象，getDefaultArgumentResolvers方法相关源码: 12345private List&lt;HandlerMethodArgumentResolver&gt; getDefaultArgumentResolvers() &#123; resolvers.add(new RequestPartMethodArgumentResolver(getMessageConverters(), this.requestResponseBodyAdvice)); // Catch-all resolvers.add(new RequestParamMethodArgumentResolver(getBeanFactory(), true));&#125; useDefaultResolution参数用于启动对常规类型参数的解析，这里的常规类型指的又是什么呢? 实际上由BeanUtils.isSimpleProperty方法决定: 12345678910111213public static boolean isSimpleProperty(Class&lt;?&gt; clazz) &#123; Assert.notNull(clazz, \"Class must not be null\"); return isSimpleValueType(clazz) || (clazz.isArray() &amp;&amp; isSimpleValueType(clazz.getComponentType()));&#125;public static boolean isSimpleValueType(Class&lt;?&gt; clazz) &#123; return (ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.isEnum() || CharSequence.class.isAssignableFrom(clazz) || Number.class.isAssignableFrom(clazz) || Date.class.isAssignableFrom(clazz) || URI.class == clazz || URL.class == clazz || Locale.class == clazz || Class.class == clazz);&#125; 忽略复杂的调用关系，最核心的实现位于resolveName方法，部分源码: 12345678910@Overrideprotected Object resolveName(String name, MethodParameter parameter, NativeWebRequest request) &#123; if (arg == null) &#123; String[] paramValues = request.getParameterValues(name); if (paramValues != null) &#123; arg = (paramValues.length == 1 ? paramValues[0] : paramValues); &#125; &#125; return arg;&#125; name就是方法的参数名，可以看出，参数解析就是根据参数名去request查找对应属性的过程，在这里参数类型并没有起什么作用。 参数名是从哪里来的方法名获取的入口位于RequestParamMethodArgumentResolver的resolveArgument方法: 12345@Overridepublic final Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; NamedValueInfo namedValueInfo = getNamedValueInfo(parameter);&#125; getNamedValueInfo方法最终完成对MethodParameter的getParameterName方法的调用: 123456789101112public String getParameterName() &#123; ParameterNameDiscoverer discoverer = this.parameterNameDiscoverer; if (discoverer != null) &#123; String[] parameterNames = (this.method != null ? discoverer.getParameterNames(this.method) : discoverer.getParameterNames(this.constructor)); if (parameterNames != null) &#123; this.parameterName = parameterNames[this.parameterIndex]; &#125; this.parameterNameDiscoverer = null; &#125; return this.parameterName;&#125; 显然，参数名的获取由接口ParameterNameDiscoverer完成: 默认采用DefaultParameterNameDiscoverer，但此类其实相当于StandardReflectionParameterNameDiscoverer和LocalVariableTableParameterNameDiscoverer的组合，且前者先于后者进行解析。 StandardReflectionParameterNameDiscoverer.getParameterNames: 12345678910111213@Overridepublic String[] getParameterNames(Method method) &#123; Parameter[] parameters = method.getParameters(); String[] parameterNames = new String[parameters.length]; for (int i = 0; i &lt; parameters.length; i++) &#123; Parameter param = parameters[i]; if (!param.isNamePresent()) &#123; return null; &#125; parameterNames[i] = param.getName(); &#125; return parameterNames;&#125; 此类被注解UsesJava8标注，其原理就是利用的jdk8的-parameters编译参数，只有在加上此选项的情况下才能用反射的方法获得真实的参数名，所以一般情况下StandardReflectionParameterNameDiscoverer是无法成功获取参数名的。 LocalVariableTableParameterNameDiscoverer利用了ASM直接访问class文件中的本地变量表来得到变量名，下面是使用javap -verbose命令得到的本地变量表示例: 但是默认情况下javac compiler是不生成本地变量表这种调试信息的，需要加-g参数才可以，那为什么在我们的测试Controller中却可以获得呢，玄机就在于idea的下列设置: 取消这项设置的勾选再次运行程序便出问题了: Model解析由ModelMethodProcessor完成。 supportsParameter方法很简单: 1234@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; return Model.class.isAssignableFrom(parameter.getParameterType());&#125; 很直白了。 resolveArgument： 12345@Overridepublic Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception &#123; return mavContainer.getModel();&#125; 忽略各种调用关系，Model其实是一个BindingAwareModelMap对象，且每次请求(需要注入Model的前提下)都有一个新的该对象生成。类图: 总结 我们可以通过实现HandlerMethodArgumentResolver接口并将其注册容器的方式实现自定义参数类型的解析。 为了防止出现参数名获取不到的问题，应优先使用@RequestParam注解直接声明需要的参数名称。 返回值解析套路和上面是一样的，通常情况，我们返回的其实是view名，负责处理的是ViewNameMethodReturnValueHandler， supportsReturnType方法: 12345@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; Class&lt;?&gt; paramType = returnType.getParameterType(); return (void.class == paramType || CharSequence.class.isAssignableFrom(paramType));&#125; handleReturnValue: 123456789101112@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) &#123; if (returnValue instanceof CharSequence) &#123; String viewName = returnValue.toString(); mavContainer.setViewName(viewName); // 判断的依据: 是否以redirect:开头 if (isRedirectViewName(viewName)) &#123; mavContainer.setRedirectModelScenario(true); &#125; &#125;&#125; 可见这里并没有进行实际的处理，只是解析得到了最终的视图名称。 视图渲染由DispatcherServlet的processDispatchResult方法完成，源码: 123456789101112131415161718192021private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, HandlerExecutionChain mappedHandler, ModelAndView mv, Exception exception) &#123; boolean errorView = false; if (exception != null) &#123; //一般不会到这个分支 if (exception instanceof ModelAndViewDefiningException) &#123; mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125;&#125; 可以看出，处理根据是否抛出异常分为了两种情况。 如果抛出了异常，那么processHandlerException方法将会遍历所有的HandlerExceptionResolver实例，默认有哪些参考MVC初始化-HandlerExceptionResolver检查一节。默认的处理器用于改变响应状态码、调用标注了@ExceptionHandler的bean进行处理，如果没有@ExceptionHandler的bean或是不能处理此类异常，那么就会导致ModelAndView始终为null，最终Spring MVC将异常向上抛给Tomcat，然后Tomcat就会把堆栈打印出来。 如果我们想将其定向到指定的错误页面，可以这样配置: 123&lt;bean class=\"org.springframework.web.servlet.handler.SimpleMappingExceptionResolver\"&gt; &lt;property name=\"defaultErrorView\" value=\"error\"&gt;&lt;/property&gt;&lt;/bean&gt; 此处理器会返回一个非空的ModelAndView。 ModelAndView回过头来看一下这到底是个什么东西。类图: 很直白。 怎么生成的。RequestMappingHandlerAdapter.getModelAndView相关源码: 12ModelMap model = mavContainer.getModel();ModelAndView mav = new ModelAndView(mavContainer.getViewName(), model, mavContainer.getStatus()); 渲染DispatcherServlet.render简略版源码: 1234567891011121314151617protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) &#123; Locale locale = this.localeResolver.resolveLocale(request); response.setLocale(locale); View view; //判断依据: 是否是String类型 if (mv.isReference()) &#123; // We need to resolve the view name. view = resolveViewName(mv.getViewName(), mv.getModelInternal(), locale, request); &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); &#125; if (mv.getStatus() != null) &#123; response.setStatus(mv.getStatus().value()); &#125; view.render(mv.getModelInternal(), request, response);&#125; resolveViewName方法将会遍历所有的ViewResolver bean，只要有一个解析的结果(View)不为空，即停止遍历。根据MVC初始化-ViewResolver检查一节和我们的配置文件可知，容器中有两个ViewResolver ，分别是: InternalResourceViewResolver和UrlBasedViewResolver。 ViewResolver类图(忽略实现类): resolveViewName方法的源码不再贴出，其实只做了一件事: 用反射创建并初始化我们指定的View，根据我们的配置，就是JstlView。 View类图: 渲染的核心逻辑位于InternalResourceView.renderMergedOutputModel，简略版源码: 123456789101112131415161718@Overrideprotected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) &#123; // 将Model中的属性设置的request中 exposeModelAsRequestAttributes(model, request); // 获取资源(jsp)路径 String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) &#123; response.setContentType(getContentType()); rd.include(request, response); &#125; else &#123; // Note: The forwarded resource is supposed to determine the content type itself. rd.forward(request, response); &#125;&#125; 可以看出，对jsp来说，所谓的渲染其实就是将Model中的属性设置到Request，再利用原生Servlet RequestDispatcher API进行转发的过程。 拾遗@ResponseBody通常我们可以在Controller或方法上标注@ResponseBody注解以表示需要将对象转为JSON并返回给前端，那么Spring MVC是如何自动完成这一过程的呢? 从前面初始化-容器初始化-容器创建-配置解析一节可以看出，Spring MVC采用org.springframework.web.servlet.config.AnnotationDrivenBeanDefinitionParser进行配置的解析，核心的parse方法中完成了对HttpMessageConverter的初始化。 HttpMessageConverterSpring的HttpMessageConverter接口负责HTTP请求-Java对象与Java对象-响应之间的转换。我们以Spring默认使用的Jackson转换器为例，类图: HttpMessageConverter实现的初始化由AnnotationDrivenBeanDefinitionParser的getMessageConverters方法完成，HttpMessageConverter的来源分为自定义和默认。 示例配置: 12345&lt;mvc:annotation-driven&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"test.Converter\" /&gt; &lt;/mvc:message-converters&gt;&lt;/mvc:annotation-driven&gt; 自定义Spring允许我们通过XML配置文件的message-converters元素来进行自定义。 默认当检测到没有配置message-converters元素或者register-defaults=”true”时Spring便会注册默认转换器。这其中便包括MappingJacksonHttpMessageConverter，相关源码: 1234else if (jacksonPresent) &#123; messageConverters.add(createConverterDefinition( org.springframework.http.converter.json.MappingJacksonHttpMessageConverter.class, source));&#125; jacksonPresent声明: 123private static final boolean jacksonPresent = ClassUtils.isPresent(\"org.codehaus.jackson.map.ObjectMapper\", AnnotationDrivenBeanDefinitionParser.class.getClassLoader()) &amp;&amp; ClassUtils.isPresent(\"org.codehaus.jackson.JsonGenerator\", AnnotationDrivenBeanDefinitionParser.class.getClassLoader()); 转换入口位于ServletInvocableHandlerMethod的invokeAndHandle方法对于响应的处理: 1this.returnValueHandlers.handleReturnValue(returnValue, getReturnValueType(returnValue), mavContainer, webRequest); returnValueHandlers其实就是RequestMappingHandlerAdapter内部的returnValueHandlers，后者由RequestMappingHandlerAdapter的afterPropertiesSet方法初始化，关键在于: 1handlers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.contentNegotiationManager)); 对象到JSON的转换正是由RequestResponseBodyMethodProcessor完成，ServletInvocableHandlerMethod通过supportsReturnType方法决定HandlerMethodReturnValueHandler是否可以处理当前返回类型或返回方法，RequestResponseBodyMethodProcessor的实现: 12345@Overridepublic boolean supportsReturnType(MethodParameter returnType) &#123; return ((AnnotationUtils.findAnnotation(returnType.getContainingClass(), ResponseBody.class) != null) || (returnType.getMethodAnnotation(ResponseBody.class) != null));&#125; 核心的handleReturnValue方法: 12345678@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) &#123; mavContainer.setRequestHandled(true); if (returnValue != null) &#123; writeWithMessageConverters(returnValue, returnType, webRequest); &#125;&#125; 这里其实是通过HttpMessageConverter的canRead或canWrite方法来判断给定的转换器是否合适，canWrite方法实现: 1234@Overridepublic boolean canWrite(Class&lt;?&gt; clazz, MediaType mediaType) &#123; return (this.objectMapper.canSerialize(clazz) &amp;&amp; canWrite(mediaType));&#125; 这里剩下的便是Jackson的事情了，注意MappingJacksonHttpMessageConverter中的objectMapper被所有的线程所共享，因为其是线程安全的，但是这样是否有性能问题? 参数解析 &amp; 结果转换Spring MVC中参数到各种类型的转换由HandlerMethodArgumentResolver接口完成，而Controller返回值到真正的响应的转换由HandlerMethodReturnValueHandler接口完成。两者分别负责Spring MVC中数据的输入与输出，可用下图表示: HandlerMethodArgumentResolver接口及其主要实现类如下图: HandlerMethodReturnValueHandler接口以及主要实现类如下: 其实有很多类同时实现了两个接口，比如RequestResponseBodyMethodProcessor，这样的类一般以Processor结尾。 两种转换器的初始化由HandlerAdapter完成，这也很好的体现了HandlerAdapter接口的功能。以喜闻乐见的RequestMappingHandlerAdapter为例，其初始化的HandlerMethodReturnValueHandler列表如下: ModelAndViewMethodReturnValueHandler ModelMethodProcessor HttpEntityMethodProcessor HttpHeadersReturnValueHandler CallableMethodReturnValueHandler DeferredResultMethodReturnValueHandler AsyncTaskMethodReturnValueHandler ListenableFutureReturnValueHandler ModelAttributeMethodProcessor RequestResponseBodyMethodProcessor ViewNameMethodReturnValueHandler MapMethodProcessor ModelAndViewResolverMethodReturnValueHandler 从中也可以推测出我们可以把哪些类型的值(对象)直接”丢给”Spring。 对于HandlerMethodArgumentResolver和HandlerMethodReturnValueHandler来说，HttpMessageConverter像是两者手中用来实现功能的武器。 “纯”对象参数接收假设有如下这样的Controller: 12345@RequestMapping(\"/echoAgain\")public String echo(SimpleModel simpleModel, Model model) &#123; model.addAttribute(\"echo\", \"hello \" + simpleModel.getName() + \", your age is \" + simpleModel.getAge() + \".\"); return \"echo\";&#125; 经过测试可以发现，SimpleModel参数既可以接收get请求，也可以接收post请求。那么在这种情况下请求参数是被哪个参数解析器解析的呢，debug发现: ServletModelAttributeMethodProcessor： 核心的supportsParameter方法由父类ModelAttributeMethodProcessor实现: 12345@Overridepublic boolean supportsParameter(MethodParameter parameter) &#123; return (parameter.hasParameterAnnotation(ModelAttribute.class) || (this.annotationNotRequired &amp;&amp; !BeanUtils.isSimpleProperty(parameter.getParameterType())));&#125; 可以看出，这里支持带有ModelAttribute注解或者是非基本类型的参数解析，同时annotationNotRequired必须设为false，即ModelAttribute注解不必存在，这里是在ServletModelAttributeMethodProcessor的构造器中进行控制的，RequestMappingHandlerAdapter.getDefaultArgumentResolvers部分源码: 1resolvers.add(new ServletModelAttributeMethodProcessor(false)); 此类的作用是对@ModelAttribute注解标注的参数进行解析，假设我们将Controller方法改写成: 123456@RequestMapping(\"/echoAgain\")public String echo(@ModelAttribute SimpleModel simpleModel, Model model) &#123; model.addAttribute(\"echo\", \"hello \" + simpleModel.getName() + \", your age is \" + simpleModel.getAge() + \".\"); System.out.println(model.asMap().get(\"simpleModel\")); return \"echo\";&#125; 首先，Spring会首先反射生成一个SimpleModel对象，之后将从request中获取的参数尝试设置到SimpleModel对象中去，最后将此对象放置到Model中(本质上就是一个Map)，key就是simpleModel.下面我们来看一下具体的解析过程，整个过程可以分为以下三部分: 参数对象构造因为SimpleModel是一个对象类型，所以要想将参数注入到其中，第一步必然是先创建一个对象，创建的入口位于ModelAttributeMethodProcessor的resolveArgument方法，相关源码: 1234//name在这里便是simpleModelString name = ModelFactory.getNameForParameter(parameter);Object attribute = (mavContainer.containsAttribute(name) ? mavContainer.getModel().get(name) : createAttribute(name, parameter, binderFactory, webRequest));//反射实例化 ModelAndViewContainer是个什么东西呢，从名字就可以看出就，它是Spring MVC里两个重要概念Model和View的组合体，用来记录在请求响应过程中Model和View的变化，在这里可以简单理解为去Model中检查有没有叫simpleModel的属性已经存在。 参数绑定这里使用到了DataBinder接口，按照注释的说明，此接口用以向执行的对象中设置属性值，就是这么简单，其继承体系如下图: WebDataBinderFactory接口用以创建WebDataBinder对象，其继承体系如下图: 默认使用的是ServletRequestDataBinderFactory，创建了一个ExtendedServletRequestDataBinder对象: 1234@Overrideprotected ServletRequestDataBinder createBinderInstance(Object target, String objectName, NativeWebRequest request) &#123; return new ExtendedServletRequestDataBinder(target, objectName);&#125; 参数绑定的入口位于ModelAttributeMethodProcessor.resolveArgument方法，相关源码: 123if (!mavContainer.isBindingDisabled(name)) &#123; bindRequestParameters(binder, webRequest);&#125; 接下来由ServletRequestDataBinder的bind方法完成，核心源码: 1234public void bind(ServletRequest request) &#123; MutablePropertyValues mpvs = new ServletRequestParameterPropertyValues(request); doBind(mpvs);&#125; 在ServletRequestParameterPropertyValues构造器中获取了Request中所有的属性对。doBind方法便是调用前面初始化的目标对象的setter方法进行参数设置的过程，不再展开。 参数校验将我们的Controller方法改写为下面这种形式便可以启动Spring MVC的参数校验: 123456@RequestMapping(\"/echoAgain\")public String echo(@Validated SimpleModel simpleModel, Model model) &#123; model.addAttribute(\"echo\", \"hello \" + simpleModel.getName() + \", your age is \" + simpleModel.getAge() + \".\"); System.out.println(model.asMap().get(\"simpleModel\")); return \"echo\";&#125; 在这里@Validated注解可以用@Valid(javax)替换，前者是Spring对java校验标准的扩充，增加了校验组的支持。为什么参数校验要放到参数绑定后面进行说明呢，因为@Validated和@valid注解不会影响Spring MVC参数解析的行为，被这两个注解标注的对象仍是由参数绑定一节提到的解析器进行解析。 当参数校验绑定之后，Spring MVC会尝试对参数进行校验，如果我们设置了校验注解。ModelAttributeMethodProcessor.resolveArgument方法相关源码: 1234567891011121314validateIfApplicable(binder, parameter);protected void validateIfApplicable(WebDataBinder binder, MethodParameter methodParam) &#123; Annotation[] annotations = methodParam.getParameterAnnotations(); for (Annotation ann : annotations) &#123; Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated.class); if (validatedAnn != null || ann.annotationType().getSimpleName().startsWith(\"Valid\")) &#123; Object hints = (validatedAnn != null ? validatedAnn.value() : AnnotationUtils.getValue(ann)); Object[] validationHints = (hints instanceof Object[] ? (Object[]) hints : new Object[] &#123;hints&#125;); binder.validate(validationHints); break; &#125; &#125;&#125; DataBinder.validate: 123456789public void validate(Object... validationHints) &#123; for (Validator validator : getValidators()) &#123; if (!ObjectUtils.isEmpty(validationHints) &amp;&amp; validator instanceof SmartValidator) &#123; ((SmartValidator) validator).validate(getTarget(), getBindingResult(), validationHints); &#125; else if (validator != null) &#123; validator.validate(getTarget(), getBindingResult()); &#125; &#125;&#125; 可见，具体的校验交给了org.springframework.validation.Validator实现，类图: getValidators方法获取的实际上是DataBinder内部的validators字段: 1private final List&lt;Validator&gt; validators = new ArrayList&lt;Validator&gt;(); 根据这里的校验器的来源可以分为以下两种情况。 JSR校验需要引入hibernate-validator到classpath中，回顾最前面配置解析部分，配置: 1&lt;mvc:annotation-driven/&gt; 会利用AnnotationDrivenBeanDefinitionParser进行相关的解析、初始化工作，正是在其parse方法完成了对JSR校验的支持。相关源码: 123456789101112131415161718192021@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; RuntimeBeanReference validator = getValidator(element, source, parserContext);&#125;private RuntimeBeanReference getValidator(Element element, Object source, ParserContext parserContext) &#123; //mvc:annotation-driven配置支持validator属性 if (element.hasAttribute(\"validator\")) &#123; return new RuntimeBeanReference(element.getAttribute(\"validator\")); &#125; else if (javaxValidationPresent) &#123; RootBeanDefinition validatorDef = new RootBeanDefinition( \"org.springframework.validation.beanvalidation.OptionalValidatorFactoryBean\"); validatorDef.setSource(source); validatorDef.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); String validatorName = parserContext.getReaderContext().registerWithGeneratedName(validatorDef); parserContext.registerComponent(new BeanComponentDefinition(validatorDef, validatorName)); return new RuntimeBeanReference(validatorName); &#125; else &#123; return null; &#125;&#125; javaxValidationPresent的定义: 12private static final boolean javaxValidationPresent = ClassUtils.isPresent(\"javax.validation.Validator\", AnnotationDrivenBeanDefinitionParser.class.getClassLoader()); 实现了InitializingBean接口，所以afterPropertiesSet方法是其初始化的入口，具体的校验过程不再展开。 除此之外还有一个有意思的问题，就是上面提到的校验器是如何进入到DataBinder中去的呢?答案是WebDataBinderFactory创建DataBinder对象时会利用WebBindingInitializer对DataBinder进行初始化，正是在这里 将容器中存在的校验器设置到DataBinder中，至于WebBindingInitializer又是从哪里来的，不再探究了，否则这细节实在是太麻烦了，意义不大。 自定义校验器我们可以实现Spring提供的Validator接口，然后在Controller里边这样设置我们要是用的校验器: 12345@InitBinderpublic void initBinder(DataBinder dataBinder) &#123; dataBinder.setValidator(new SimpleModelValidator()); //如果有多个可以使用addValidators方法&#125; 我们的Controller方法依然可以如此定义: 1234@RequestMapping(\"/echoAgain\")public String echo(@Validated SimpleModel simpleModel, Model model) &#123; return \"echo\";&#125; 如果有错误，会直接返回400. 一个有意思的问题如果我们把Controller方法这样定义会怎样? 12@RequestMapping(value = \"/echoAgain\", method = RequestMethod.POST)public String echo(@Validated @RequestBody SimpleModel simpleModel, Model model) &#123;&#125; 答案是@RequestBody注解先于@Validated注解起作用，这样既可以利用@RequestBody注解向Controller传递json串，同时又能够达到校验的目的。从源码的角度来说，这在很大程度上是一个顺序的问题:RequestMappingHandlerAdapter.getDefaultArgumentResolvers相关源码: 12resolvers.add(new ServletModelAttributeMethodProcessor(false));resolvers.add(new RequestResponseBodyMethodProcessor(getMessageConverters(), this.requestResponseBodyAdvice)); 虽然ServletModelAttributeMethodProcessor位于RequestResponseBodyMethodProcessor之前，但构造器参数为false说明了此解析器必须要求参数被@ModelAttribute注解标注，其实在最后还有一个不需要注解的解析器被添加: 12// Catch-allresolvers.add(new ServletModelAttributeMethodProcessor(true)); 至此，真相大白。 申明本文转载自seaswalker的github，转载授权，由我在万达摆地摊整理发布。","categories":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/tags/spring/"}]},{"title":"spring transaction源码分析","slug":"spring-transaction源码分析","date":"2018-10-05T06:57:50.000Z","updated":"2018-10-05T09:24:10.307Z","comments":true,"path":"posts/3531/","link":"","permalink":"https://satra.tk/posts/3531/","excerpt":"配置以最简单的jdbc事务为例: 1234567891011&lt;!-- 数据源以Sping自带为例，每次请求均返回一个新的连接 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driverClassName&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt;","text":"配置以最简单的jdbc事务为例: 1234567891011&lt;!-- 数据源以Sping自带为例，每次请求均返回一个新的连接 --&gt;&lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"$&#123;jdbc.driverClassName&#125;\" /&gt; &lt;property name=\"url\" value=\"$&#123;jdbc.url&#125;\" /&gt; &lt;property name=\"username\" value=\"$&#123;jdbc.username&#125;\" /&gt; &lt;property name=\"password\" value=\"$&#123;jdbc.password&#125;\" /&gt;&lt;/bean&gt;&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"/&gt;&lt;/bean&gt;&lt;tx:annotation-driven transaction-manager=\"transactionManager\"/&gt; 解析TxNamespaceHandler.init: 1234567@Overridepublic void init() &#123; registerBeanDefinitionParser(\"advice\", new TxAdviceBeanDefinitionParser()); registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser()); registerBeanDefinitionParser(\"jta-transaction-manager\", new JtaTransactionManagerBeanDefinitionParser());&#125; 明显解析的入口便在AnnotationDrivenBeanDefinitionParser.parse: 12345678910111213@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; registerTransactionalEventListenerFactory(parserContext); String mode = element.getAttribute(\"mode\"); if (\"aspectj\".equals(mode)) &#123; // mode=\"aspectj\" registerTransactionAspect(element, parserContext); &#125; else &#123; // mode=\"proxy\" AopAutoProxyConfigurer.configureAutoProxyCreator(element, parserContext); &#125; return null;&#125; 下面分部分进行说明。 TransactionalEventListener第一部分用于向Spring容器注册TransactionalEventListener工厂，TransactionalEventListener是Spring4.2引入的新特性，允许我们自定义监听器监听事务的提交或其它动作。 主要组件注册即configureAutoProxyCreator方法，此方法的最终作用便是在Spring容器中加入这样的bean结构: BeanFactoryTransactionAttributeSourceAdvisor-&gt;TransactionInterceptor-&gt;AnnotationTransactionAttributeSource 其中AnnotationTransactionAttributeSource用于解析@Transactional注解的相关属性。 代理类生成与aop模块类似，入口位于configureAutoProxyCreator里注册的bean: InfrastructureAdvisorAutoProxyCreator，其类图: 此类的特殊之处从其名字上可以体现: 只考虑Spring内部使用的基础设施Advisor。 为类创建代理的入口位于AbstractAutoProxyCreator.postProcessAfterInitialization: 12345678910@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; if (bean != null) &#123; Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) &#123; return wrapIfNecessary(bean, beanName, cacheKey); &#125; &#125; return bean;&#125; wrapIfNecessary核心逻辑: 1234567891011protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; // Create proxy if we have advice. Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) &#123; this.advisedBeans.put(cacheKey, Boolean.TRUE); Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125;&#125; Advisor寻找getAdvicesAndAdvisorsForBean用于去容器中寻找适合当前bean的Advisor，其最终调用AbstractAdvisorAutoProxyCreator.findEligibleAdvisors: 12345678910protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123; List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) &#123; //按照@Ordered排序 eligibleAdvisors = sortAdvisors(eligibleAdvisors); &#125; return eligibleAdvisors;&#125; 这个方法在spring-aop中已经详细说明过了，这里再强调一下具体的查找逻辑: 首先去容器找出所有实现了Advisor接口的bean，对应findCandidateAdvisors方法. 逐一判断Advisor是否适用于当前bean，对应findAdvisorsThatCanApply方法，判断逻辑为: 如果Advisor是IntroductionAdvisor，那么判断其ClassFilter是否可以匹配bean的类. 如果Advisor是PointcutAdvisor，那么首先进行ClassFilter匹配，如果匹配失败，那么再获得Advisor的MethodMatcher对象，如果MethodMatcher可以匹配任意方法，那么返回true，否则反射获取给定bean的所有方法逐一进行匹配，只要有一个匹配成功，即返回true. 其它情况，直接返回true. 对于spring事务来说，我们有唯一的Advisor: BeanFactoryTransactionAttributeSourceAdvisor,其类图: 可以看出，BeanFactoryTransactionAttributeSourceAdvisor其实是一个PointcutAdvisor，所以是否可以匹配取决于其Pointcut。此Advisor的pointcut是一个TransactionAttributeSourcePointcut对象，类图: Pointcut的核心在于其ClassFilter和MethodMatcher。 ClassFilter: 位于StaticMethodMatcherPointcut: 1private ClassFilter classFilter = ClassFilter.TRUE; 即: 类检查全部通过。 MethodMatcher: TransactionAttributeSourcePointcut.matches: 123456789@Overridepublic boolean matches(Method method, Class&lt;?&gt; targetClass) &#123; //如果已经是事务代理，那么不应该再次代理 if (TransactionalProxy.class.isAssignableFrom(targetClass)) &#123; return false; &#125; TransactionAttributeSource tas = getTransactionAttributeSource(); return (tas == null || tas.getTransactionAttribute(method, targetClass) != null);&#125; getTransactionAttribute方法使用了缓存的思想，但其核心逻辑位于AbstractFallbackTransactionAttributeSource.computeTransactionAttribute: 123456789101112131415161718192021222324252627282930313233343536protected TransactionAttribute computeTransactionAttribute(Method method, Class&lt;?&gt; targetClass) &#123; // Don't allow no-public methods as required. if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123; return null; &#125; // Ignore CGLIB subclasses - introspect the actual user class. Class&lt;?&gt; userClass = ClassUtils.getUserClass(targetClass); // The method may be on an interface, but we need attributes from the target class. // If the target class is null, the method will be unchanged. Method specificMethod = ClassUtils.getMostSpecificMethod(method, userClass); // If we are dealing with method with generic parameters, find the original method. specificMethod = BridgeMethodResolver.findBridgedMethod(specificMethod); // First try is the method in the target class. TransactionAttribute txAtt = findTransactionAttribute(specificMethod); if (txAtt != null) &#123; return txAtt; &#125; // Second try is the transaction attribute on the target class. txAtt = findTransactionAttribute(specificMethod.getDeclaringClass()); if (txAtt != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123; return txAtt; &#125; if (specificMethod != method) &#123; // Fallback is to look at the original method. txAtt = findTransactionAttribute(method); if (txAtt != null) &#123; return txAtt; &#125; // Last fallback is the class of the original method. txAtt = findTransactionAttribute(method.getDeclaringClass()); if (txAtt != null &amp;&amp; ClassUtils.isUserLevelMethod(method)) &#123; return txAtt; &#125; &#125; return null;&#125; 很明显可以看出，首先去方法上查找是否有相应的事务注解(比如@Transactional)，如果没有，那么再去类上查找。 运行以JDK动态代理为例，JdkDynamicAopProxy.invoke简略版源码: 1234567891011121314@Overridepublic Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass); if (chain.isEmpty()) &#123;. //没有可用的拦截器，直接调用原方法 Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args); retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse); &#125; else &#123; // We need to create a method invocation... invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain); // Proceed to the joinpoint through the interceptor chain. Object retVal = invocation.proceed(); &#125;&#125; 调用链生成即getInterceptorsAndDynamicInterceptionAdvice方法，其原理是: 遍历所有使用的 Advisor，获得其Advice，将Advice转为MethodInterceptor。那么是如何转的呢? 根据Spring的定义，Advice可以是一个MethodInterceptor，也可以是类似于Aspectj的before, after通知。转换由DefaultAdvisorAdapterRegistry.getInterceptors完成: 1234567891011121314151617@Overridepublic MethodInterceptor[] getInterceptors(Advisor advisor) throws UnknownAdviceTypeException &#123; List&lt;MethodInterceptor&gt; interceptors = new ArrayList&lt;MethodInterceptor&gt;(3); Advice advice = advisor.getAdvice(); if (advice instanceof MethodInterceptor) &#123; interceptors.add((MethodInterceptor) advice); &#125; for (AdvisorAdapter adapter : this.adapters) &#123; if (adapter.supportsAdvice(advice)) &#123; interceptors.add(adapter.getInterceptor(advisor)); &#125; &#125; if (interceptors.isEmpty()) &#123; throw new UnknownAdviceTypeException(advisor.getAdvice()); &#125; return interceptors.toArray(new MethodInterceptor[interceptors.size()]);&#125; AdvisorAdapter接口用以支持用户自定义的Advice类型，并将自定义的类型转为拦截器。默认adapters含有MethodBeforeAdviceAdapter、AfterReturningAdviceAdapter和ThrowsAdviceAdapter三种类型，用以分别支持MethodBeforeAdvice、AfterReturningAdvice和ThrowsAdvice。 对于我们的BeanFactoryTransactionAttributeSourceAdvisor来说，有且只有一个拦截器: TransactionInterceptor. 调用链调用ReflectiveMethodInvocation.proceed: 12345678910111213141516171819202122@Overridepublic Object proceed() throws Throwable &#123; if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) &#123; //拦截器执行完毕，调用原本的方法 return invokeJoinpoint(); &#125; Object interceptorOrInterceptionAdvice = this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex); if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) &#123; InterceptorAndDynamicMethodMatcher dm = (InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice; if (dm.methodMatcher.matches(this.method, this.targetClass, this.arguments)) &#123; return dm.interceptor.invoke(this); &#125; else &#123; // Dynamic matching failed. return proceed(); &#125; &#125; else &#123; //调用拦截器的invoke方法 return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this); &#125;&#125; 可以看出，这其实是一个逐个调用拦截器的invoke方法，最终调用原本方法(被代理方法)的过程。所以，事务添加的核心逻辑(入口)在TransactionInterceptor的invoke方法。 TransactionInterceptorinvoke方法: 12345678910111213@Overridepublic Object invoke(final MethodInvocation invocation) throws Throwable &#123; Class&lt;?&gt; targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null); // Adapt to TransactionAspectSupport's invokeWithinTransaction... return invokeWithinTransaction(invocation.getMethod(), targetClass, new InvocationCallback() &#123; @Override public Object proceedWithInvocation() throws Throwable &#123; //事务执行完毕后调用链继续向下执行 return invocation.proceed(); &#125; &#125;);&#125; invokeWithinTransaction简略版源码(仅保留PlatformTransactionManager部分): 1234567891011121314151617181920212223242526protected Object invokeWithinTransaction(Method method, Class&lt;?&gt; targetClass, final InvocationCallback invocation)&#123; // If the transaction attribute is null, the method is non-transactional. final TransactionAttribute txAttr = getTransactionAttributeSource() .getTransactionAttribute(method, targetClass); final PlatformTransactionManager tm = determineTransactionManager(txAttr); //得到方法名 final String joinpointIdentification = methodIdentification(method, targetClass); if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) &#123; // Standard transaction demarcation with getTransaction and commit/rollback calls. TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification); Object retVal = null; try &#123; // This is an around advice: Invoke the next interceptor in the chain. // This will normally result in a target object being invoked. retVal = invocation.proceedWithInvocation(); &#125; catch (Throwable ex) &#123; // target invocation exception completeTransactionAfterThrowing(txInfo, ex); throw ex; &#125; finally &#123; cleanupTransactionInfo(txInfo); &#125; commitTransactionAfterReturning(txInfo); return retVal; &#125;&#125; 事务管理器determineTransactionManager方法用以确定使用的事务管理器: 1234567891011121314151617181920212223protected PlatformTransactionManager determineTransactionManager(TransactionAttribute txAttr) &#123; //如果没有事务属性，那么仅从缓存中查找，找不到返回null if (txAttr == null || this.beanFactory == null) &#123; return getTransactionManager(); &#125; String qualifier = txAttr.getQualifier(); //如果@Transactional注解配置了transactionManager或value属性(用以决定使用哪个事务管理器): //首先查找缓存，找不到再去容器中按名称寻找 if (StringUtils.hasText(qualifier)) &#123; return determineQualifiedTransactionManager(qualifier); &#125; else if (StringUtils.hasText(this.transactionManagerBeanName)) &#123; return determineQualifiedTransactionManager(this.transactionManagerBeanName); &#125; else &#123; //去容器中按类型(Class)查找 PlatformTransactionManager defaultTransactionManager = getTransactionManager(); if (defaultTransactionManager == null) &#123; defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class); this.transactionManagerCache.putIfAbsent( DEFAULT_TRANSACTION_MANAGER_KEY, defaultTransactionManager); &#125; return defaultTransactionManager; &#125;&#125; 对于我们使用的DataSourceTransactionManager，类图: afterPropertiesSet方法只是对dataSource进行了检查。 DataSourceDriverManagerDataSource类图: 其中CommonDataSource、Wrapper、DataSource均位于javax.sql包下。 事务开启invocation.proceedWithInvocation()便是我们的逻辑，而createTransactionIfNecessary便是在逻辑执行前开启事务。 TransactionAspectSupport.createTransactionIfNecessary: 12345678910111213141516171819protected TransactionInfo createTransactionIfNecessary( PlatformTransactionManager tm, TransactionAttribute txAttr, final String joinpointIdentification) &#123; // If no name specified, apply method identification as transaction name. if (txAttr != null &amp;&amp; txAttr.getName() == null) &#123; txAttr = new DelegatingTransactionAttribute(txAttr) &#123; @Override public String getName() &#123; return joinpointIdentification; &#125; &#125;; &#125; TransactionStatus status = null; if (txAttr != null) &#123; if (tm != null) &#123; status = tm.getTransaction(txAttr); &#125; &#125; return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);&#125; 此部分的核心逻辑在getTransaction和prepareTransactionInfo方法，源码较长，下面依然按部分整理。 是否已存在事务目的在于支撑事务的传播性。 源码位于DataSourceTransactionManager.doGetTransaction，核心逻辑在TransactionSynchronizationManager.doGetResource: 1234567891011121314151617private static Object doGetResource(Object actualKey) &#123; Map&lt;Object, Object&gt; map = resources.get(); if (map == null) &#123; return null; &#125; Object value = map.get(actualKey); // Transparently remove ResourceHolder that was marked as void... if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123; map.remove(actualKey); // Remove entire ThreadLocal if empty... if (map.isEmpty()) &#123; resources.remove(); &#125; value = null; &#125; return value;&#125; actualKey实际上是DataSource对象，resources是一个ThreadLocal对象，其声明源码: 12private static final ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources = new NamedThreadLocal&lt;Map&lt;Object, Object&gt;&gt;(\"Transactional resources\"); 从这里可以得出结论: 是否存在事务指的是在当前线程、当前数据源(DataSource)中是否存在处于活动状态的事务。 事务已存在如果检测到已存在事务，那么就要考虑事务的传播特性(行为).此部分源码位于AbstractPlatformTransactionManager.handleExistingTransaction，下面按照不同的传播特性展开。 PROPAGATION_NEVER即当前方法需要在非事务的环境下执行，如果有事务存在，那么抛出异常。相关源码: 1234if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) &#123; throw new IllegalTransactionStateException( \"Existing transaction found for transaction marked with propagation 'never'\");&#125; PROPAGATION_NOT_SUPPORTED与前者的区别在于，如果有事务存在，那么将事务挂起，而不是抛出异常。 123456if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) &#123; Object suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS); return prepareTransactionStatus( definition, null, false, newSynchronization, debugEnabled, suspendedResources);&#125; 事务挂起此部分的核心在于suspend方法，最终调用TransactionSynchronizationManager.doUnbindResource: 12345678910111213141516private static Object doUnbindResource(Object actualKey) &#123; Map&lt;Object, Object&gt; map = resources.get(); if (map == null) &#123; return null; &#125; Object value = map.remove(actualKey); // Remove entire ThreadLocal if empty... if (map.isEmpty()) &#123; resources.remove(); &#125; // Transparently suppress a ResourceHolder that was marked as void... if (value instanceof ResourceHolder &amp;&amp; ((ResourceHolder) value).isVoid()) &#123; value = null; &#125; return value;&#125; 可以看出，所谓的事务挂起其实就是一个移除当前线程、数据源活动事务对象的过程。 同时注意getTransaction方法返回的是一个TransactionStatus对象，被挂起的事务的各种状态都被保存在此对象中。 那么挂起这个操作到底是如何实现(起作用)的呢? DataSourceTransactionManager.doSuspend: 12345678@Overrideprotected Object doSuspend(Object transaction) &#123; DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; txObject.setConnectionHolder(null); ConnectionHolder conHolder = (ConnectionHolder) TransactionSynchronizationManager.unbindResource(this.dataSource); return conHolder;&#125; 其实玄机就在于将ConnectionHolder设为null这一行，因为一个ConnectionHolder对象就代表了一个数据库连接，将ConnectionHolder设为null就意味着我们下次要使用连接时，将重新从连接池获取，而新的连接的自动提交是为true的。 PROPAGATION_REQUIRES_NEW123456789if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) &#123; SuspendedResourcesHolder suspendedResources = suspend(transaction); boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER); DefaultTransactionStatus status = newTransactionStatus( definition, transaction, true, newSynchronization, debugEnabled, suspendedResources); doBegin(transaction, definition); prepareSynchronization(status, definition); return status;&#125; 可以看出，这其实是一个挂起当前活动事务并创建新事务的过程，doBegin方法是事务开启的核心，将在后面进行说明。 PROPAGATION_NESTED其意义: PROPAGATION_NESTED 开始一个 “嵌套的” 事务, 它是已经存在事务的一个真正的子事务. 嵌套事务开始执行时, 它将取得一个 savepoint. 如果这个嵌套事务失败, 我们将回滚到此 savepoint. 嵌套事务是外部事务的一部分, 只有外部事务结束后它才会被提交. 摘自: 解惑 spring 嵌套事务 核心源码(忽略JTA部分): 1234567891011if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123; if (useSavepointForNestedTransaction()) &#123; // Create savepoint within existing Spring-managed transaction, // through the SavepointManager API implemented by TransactionStatus. // Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization. DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null); status.createAndHoldSavepoint(); return status; &#125;&#125; 关键在于如何创建SavePoint, AbstractTransactionStatus.createAndHoldSavepoint: 123public void createAndHoldSavepoint() throws TransactionException &#123; setSavepoint(getSavepointManager().createSavepoint());&#125; DefaultTransactionStatus.getSavepointManager: 12345678@Overrideprotected SavepointManager getSavepointManager() &#123; if (!isTransactionSavepointManager()) &#123; throw new NestedTransactionNotSupportedException( \"Transaction object [\" + getTransaction() + \"] does not support savepoints\"); &#125; return (SavepointManager) getTransaction();&#125; 可以看出，SavepointManager实际上从Transaction强转而来，Transaction在Spring都是用Object引用的，那么这到底是个什么东西? debug环境搭建 安装Mysql数据库(或其它支持jdbc)并正确配置数据库连接. 定义两个bean，代表我们的业务逻辑: TransactionBean: 12345678910111213141516@Componentpublic class TransactionBean &#123; private NestedBean nestedBean; public NestedBean getNestedBean() &#123; return nestedBean; &#125; public void setNestedBean(NestedBean nestedBean) &#123; this.nestedBean = nestedBean; &#125; @Transactional(propagation = Propagation.REQUIRED) public void process() &#123; System.out.println(\"事务执行\"); nestedBean.nest(); &#125;&#125; NestedBean: 1234567@Componentpublic class NestedBean &#123; @Transactional(propagation = Propagation.NESTED) public void nest() &#123; System.out.println(\"嵌套事务\"); &#125;&#125; 配置文件: 1234&lt;bean id=\"nestedBean\" class=\"base.transaction.NestedBean\" /&gt;&lt;bean class=\"base.transaction.TransactionBean\"&gt; &lt;property name=\"nestedBean\" ref=\"nestedBean\" /&gt;&lt;/bean&gt; 入口: 12345public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\"); TransactionBean bean = context.getBean(TransactionBean.class); bean.process();&#125; 这样将断点打在合适的位置便可以得到事务对象究竟是什么。 注意: nest方法必须在一个单独的业务bean中，否则对nest的调用并不会导致事务获取的触发。这是由JDK动态代理的实现机制决定的，调用当前类的方法并不会触发代理逻辑(InvocationHandler)。 这一点可以运行demo:test.proxy.JDKProxy看出。 运行debug可以发现，对于DataSourceTransactionManager，事务对象其实是其内部类DataSourceTransactionObject. 事务对象 DataSourceTransactionObject的类图如下: Savepoint位于java.sql包下，对于Mysql来说，由Mysql驱动提供实现，类图: 下面来看一下Savepoint到底是如何被创建的。 JdbcTransactionObjectSupport.createSavepoint简略版源码: 12345@Overridepublic Object createSavepoint() throws TransactionException &#123; ConnectionHolder conHolder = getConnectionHolderForSavepoint(); return conHolder.createSavepoint();&#125; ConnectionHolder.createSavepoint: 1234public Savepoint createSavepoint() throws SQLException &#123; this.savepointCounter++; return getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter);&#125; 我们可以得出这样的结论: Savepoint由java SQL标准定义，具体实现由数据库完成。从mysql的客户端可以直接执行命令savepoint xx可以看出这一点。 其它略。 事务创建如果之前不存在事务，那么就需要创建了，核心逻辑位于DataSourceTransactionManager.doBegin: 123456789101112131415161718192021222324252627282930313233@Overrideprotected void doBegin(Object transaction, TransactionDefinition definition) &#123; //此时，txObject不为null，只是其核心的ConnectHolder属性为null DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction; Connection con = null; if (txObject.getConnectionHolder() == null || txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123; Connection newCon = this.dataSource.getConnection(); //获得连接，可以看出ConnectionHolder是对Connection的包装 txObject.setConnectionHolder(new ConnectionHolder(newCon), true); &#125; txObject.getConnectionHolder().setSynchronizedWithTransaction(true); con = txObject.getConnectionHolder().getConnection(); //设置是否只读和隔离级别 Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition); txObject.setPreviousIsolationLevel(previousIsolationLevel); // Switch to manual commit if necessary. This is very expensive in some JDBC drivers, // so we don't want to do it unnecessarily (for example if we've explicitly // configured the connection pool to set it already). if (con.getAutoCommit()) &#123; txObject.setMustRestoreAutoCommit(true); con.setAutoCommit(false); &#125; txObject.getConnectionHolder().setTransactionActive(true); int timeout = determineTimeout(definition); if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123; txObject.getConnectionHolder().setTimeoutInSeconds(timeout); &#125; // Bind the session holder to the thread. if (txObject.isNewConnectionHolder()) &#123; TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder()); &#125;&#125; 到这里便可以得出结论: Spring事务的开启实际上是将数据库的自动提交设为false。 事务提交 &amp; 回滚其实就是对jdbc相应方法的封装，不再展开。 总结事务的本质其实是对数据库自动提交的关闭与开启，传播特性是Spring提出、实现、控制的概念，而隔离级别是对数据库实现的封装。 申明本文转载自seaswalker的github，转载授权，由我在万达摆地摊整理发布。","categories":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/tags/spring/"}]},{"title":"spring task源码分析","slug":"spring-task源码分析","date":"2018-10-05T06:40:31.000Z","updated":"2018-10-05T09:24:05.214Z","comments":true,"path":"posts/24249/","link":"","permalink":"https://satra.tk/posts/24249/","excerpt":"开头从功能上来说，spring-task这个组件主要包括了两个/两种功能: 任务的定时调度/执行，对应xml配置的task:scheduler和task:scheduled-tasks标签。 方法异步执行，对应xml配置的task:executor标签。 task:annotation-driven标签被以上两种功能共有。下面就这两种功能分别进行说明。","text":"开头从功能上来说，spring-task这个组件主要包括了两个/两种功能: 任务的定时调度/执行，对应xml配置的task:scheduler和task:scheduled-tasks标签。 方法异步执行，对应xml配置的task:executor标签。 task:annotation-driven标签被以上两种功能共有。下面就这两种功能分别进行说明。 定时器用法以XML作为示例，基于注解的也是一样的。 12345&lt;task:scheduler id=\"scheduler\" pool-size=\"3\" /&gt;&lt;bean id=\"task\" class=\"task.Task\"/&gt;&lt;task:scheduled-tasks scheduler=\"scheduler\"&gt; &lt;task:scheduled ref=\"task\" method=\"print\" cron=\"0/5 * * * * ?\"/&gt;&lt;/task:scheduled-tasks&gt; 定义了一个定时任务，每隔5秒执行Task的print方法，Task: 12345public class Task &#123; public void print() &#123; System.out.println(\"print执行\"); &#125;&#125; 关于cron表达式可以参考: 深入浅出Spring task定时任务 解析注册此部分的解析器注册由TaskNamespaceHandler完成: 1234567@Overridepublic void init() &#123; this.registerBeanDefinitionParser(\"annotation-driven\", new AnnotationDrivenBeanDefinitionParser()); this.registerBeanDefinitionParser(\"executor\", new ExecutorBeanDefinitionParser()); this.registerBeanDefinitionParser(\"scheduled-tasks\", new ScheduledTasksBeanDefinitionParser()); this.registerBeanDefinitionParser(\"scheduler\", new SchedulerBeanDefinitionParser());&#125; schedulerSchedulerBeanDefinitionParser源码: 123456789101112@Overrideprotected String getBeanClassName(Element element) &#123; return \"org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler\";&#125;@Overrideprotected void doParse(Element element, BeanDefinitionBuilder builder) &#123; String poolSize = element.getAttribute(\"pool-size\"); if (StringUtils.hasText(poolSize)) &#123; builder.addPropertyValue(\"poolSize\", poolSize); &#125;&#125; 由于SchedulerBeanDefinitionParser是AbstractSingleBeanDefinitionParser的子类，所以Spring将task:scheduler标签解析为一个BeanDefinition。其beanClass为org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler。 scheduled-tasks其解析的源码较长，在此不再贴出，解析之后形成的BeanDefinition结构如下图: taskScheduler属性即指向task:scheduler标签，如果没有配置，此属性不存在。 Spring将每一个task:scheduled标签解析为一个Task(的子类)，其类图如下: 很明显可以看出，任务的类型是由cron, fixed-delay, fixed-rate, trigger四个属性决定的，fixed-delay和fixed-rate为IntervalTask。 注意一点: 四种任务集合并不是互斥的。比如说一个task:scheduled标签同时配置了cron和trigger属性，那么此标签会导致生成两个beanClass分别为CronTask何TriggerTask的BeanDefinition产生，并分别被放到cronTasksList和triggerTasksList中。 从图中可以看出，task:scheduled的method和ref属性也被包装成了一个BeanDefinition, 其beanClass为org.springframework.scheduling.support.ScheduledMethodRunnable. 调度执行入口便是ContextLifecycleScheduledTaskRegistrar，类图: ContextLifecycleScheduledTaskRegistrar只实现了afterSingletonsInstantiated方法: 1234@Overridepublic void afterSingletonsInstantiated() &#123; scheduleTasks();&#125; ScheduledTaskRegistrar.scheduleTasks: 123456789101112131415161718192021222324252627protected void scheduleTasks() &#123; // shcheduler初始化 if (this.taskScheduler == null) &#123; this.localExecutor = Executors.newSingleThreadScheduledExecutor(); this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor); &#125; if (this.triggerTasks != null) &#123; for (TriggerTask task : this.triggerTasks) &#123; addScheduledTask(scheduleTriggerTask(task)); &#125; &#125; if (this.cronTasks != null) &#123; for (CronTask task : this.cronTasks) &#123; addScheduledTask(scheduleCronTask(task)); &#125; &#125; if (this.fixedRateTasks != null) &#123; for (IntervalTask task : this.fixedRateTasks) &#123; addScheduledTask(scheduleFixedRateTask(task)); &#125; &#125; if (this.fixedDelayTasks != null) &#123; for (IntervalTask task : this.fixedDelayTasks) &#123; addScheduledTask(scheduleFixedDelayTask(task)); &#125; &#125;&#125; scheduler初始化可见，如果没有配置task:scheduler，那么在这里将会进行其初始化工作。 Spring定义了TaskScheduler接口，独立于jdk之外，这样做的目的在于能够同时支持JDK和quartz。对于默认来说，Spring将真正的逻辑全部委托给jdk的Executor。 TaskScheduler类图: ConcurrentTaskExecutor来自另一个继承体系: TaskExecutor，这和spring-task的另一个重要功能，异步执行，这里暂且不表。 任务调度以喜闻乐见的CronTask为例。ScheduledTaskRegistrar.scheduleCronTask: 1234567public ScheduledTask scheduleCronTask(CronTask task) &#123; ScheduledTask scheduledTask = this.unresolvedTasks.remove(task); if (this.taskScheduler != null) &#123; scheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), task.getTrigger()); &#125; return (newTask ? scheduledTask : null);&#125; Trigger可见，Cron也是通过Trigger实现的，在Spring中，Trigger被定义为决定一个任务的下一次执行时间。其类图: 那么问题来了，字符串形式的cron表达式是在何时被解析为Trigger的呢? Cron解析CronTask构造器: 123public CronTask(Runnable runnable, String expression) &#123; this(runnable, new CronTrigger(expression));&#125; CronTrigger构造器: 123public CronTrigger(String expression) &#123; this.sequenceGenerator = new CronSequenceGenerator(expression);&#125; 答案便在CronSequenceGenerator构造器了: 123456789public CronSequenceGenerator(String expression) &#123; this(expression, TimeZone.getDefault());&#125;public CronSequenceGenerator(String expression, TimeZone timeZone) &#123; this.expression = expression; this.timeZone = timeZone; parse(expression);&#125; 具体是如何解析的，不再深入。 ConcurrentTaskScheduler.schedule: 12345@Overridepublic ScheduledFuture&lt;?&gt; schedule(Runnable task, Trigger trigger) &#123; ErrorHandler errorHandler = (this.errorHandler != null ? this.errorHandler : TaskUtils.getDefaultErrorHandler(true)); return new ReschedulingRunnable(task, trigger, this.scheduledExecutor, errorHandler).schedule();&#125; 调度从上面的源码可以看出，调度是通过ReschedulingRunnable来完成的，其类图: schedule方法: 1234567891011public ScheduledFuture&lt;?&gt; schedule() &#123; synchronized (this.triggerContextMonitor) &#123; this.scheduledExecutionTime = this.trigger.nextExecutionTime(this.triggerContext); if (this.scheduledExecutionTime == null) &#123; return null; &#125; long initialDelay = this.scheduledExecutionTime.getTime() - System.currentTimeMillis(); this.currentFuture = this.executor.schedule(this, initialDelay, TimeUnit.MILLISECONDS); return this; &#125;&#125; 可以看出，这里设置了在下一次执行窗口调用this(ReschedulingRunnable)，从类图可以看出，ReschedulingRunnable本身实现了Runnable接口，其run方法: 12345678910111213@Overridepublic void run() &#123; Date actualExecutionTime = new Date(); super.run(); Date completionTime = new Date(); synchronized (this.triggerContextMonitor) &#123; this.triggerContext.update(this.scheduledExecutionTime, actualExecutionTime, completionTime); if (!this.currentFuture.isCancelled()) &#123; //下次调用 schedule(); &#125; &#125;&#125; 对我们自定义逻辑的调用是通过super.run实现的: 1234@Overridepublic void run() &#123; this.delegate.run();&#125; delegate便是前面提到过的ScheduledMethodRunnable，其run方法: 12345@Overridepublic void run() &#123; ReflectionUtils.makeAccessible(this.method); this.method.invoke(this.target);&#125; 当然这只是针对CronTask的实现，而对于IntervalTask就要简单多了，ScheduledTaskRegistrar.scheduleFixedDelayTask部分源码: 1234567891011121314public ScheduledTask scheduleFixedDelayTask(IntervalTask task) &#123; if (this.taskScheduler != null) &#123; if (task.getInitialDelay() &gt; 0) &#123; Date startTime = new Date(System.currentTimeMillis() + task.getInitialDelay()); scheduledTask.future = this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), startTime, task.getInterval()); &#125; else &#123; scheduledTask.future = this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), task.getInterval()); &#125; &#125; return (newTask ? scheduledTask : null);&#125; 总结从上面的说明可以看出，Spring其实将核心逻辑委托给了JDK的Executors.newSingleThreadScheduledExecutor()来实现，那么JDK是如何用一个线程来定时执行多个任务的呢? 异步执行配置必须以注解的方式进行配置，xml: 12&lt;task:executor id=\"executor\" pool-size=\"3\"/&gt;&lt;task:annotation-driven executor=\"executor\"/&gt; 这样在类或方法上加上注解即可: 1234@Async(\"executor\")public void print() &#123; System.out.println(\"print执行\");&#125; 原理猜测: Spring会为带有@Async的组件生成代理子类实现对原生组件的替换，代理子类将异步执行的方法包装为Task(Runnable)提交到jdk的线程池即可。 申明本文转载自seaswalker的github，转载授权，由我在万达摆地摊整理发布。","categories":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/tags/spring/"}]},{"title":"spring context源码分析","slug":"spring-context源码分析","date":"2018-06-06T15:19:43.000Z","updated":"2018-10-05T09:23:47.730Z","comments":true,"path":"posts/59179/","link":"","permalink":"https://satra.tk/posts/59179/","excerpt":"开头入口方法在BeanDefinitionParserDelegate.parseCustomElement： 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));","text":"开头入口方法在BeanDefinitionParserDelegate.parseCustomElement： 1return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd)); parse方法由各种NamespaceHandler的父类NamespaceHandlerSupport实现: 1234@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; return findParserForElement(element, parserContext).parse(element, parserContext);&#125; findParserForElement方法用以寻找适用于此元素的BeanDefinitionParser对象: 123456789private BeanDefinitionParser findParserForElement(Element element, ParserContext parserContext) &#123; String localName = parserContext.getDelegate().getLocalName(element); BeanDefinitionParser parser = this.parsers.get(localName); if (parser == null) &#123; parserContext.getReaderContext().fatal( \"Cannot locate BeanDefinitionParser for element [\" + localName + \"]\", element); &#125; return parser;&#125; localName是个什么东西呢，比如对于context:annotation-config标签就是annotation-config。 annotation-configAnnotationConfigBeanDefinitionParser.parse: 123456789101112131415161718192021@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; //返回null Object source = parserContext.extractSource(element); // Obtain bean definitions for all relevant BeanPostProcessors. Set&lt;BeanDefinitionHolder&gt; processorDefinitions = AnnotationConfigUtils. registerAnnotationConfigProcessors(parserContext.getRegistry(), source); // Register component for the surrounding &lt;context:annotation-config&gt; element. CompositeComponentDefinition compDefinition = new CompositeComponentDefinition(element.getTagName(), source); parserContext.pushContainingComponent(compDefinition); // Nest the concrete beans in the surrounding component. for (BeanDefinitionHolder processorDefinition : processorDefinitions) &#123; parserContext.registerComponent(new BeanComponentDefinition(processorDefinition)); &#125; // Finally register the composite component. // 空实现 parserContext.popAndRegisterContainingComponent(); return null;&#125; BeanPostProcessor注册AnnotationConfigUtils.registerAnnotationConfigProcessors源码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364//第一个参数其实就是DefaultListableBeanFactory,第二个参数为nullpublic static Set&lt;BeanDefinitionHolder&gt; registerAnnotationConfigProcessors( BeanDefinitionRegistry registry, Object source) &#123; //将registery强转为DefaultListableBeanFactory类型 DefaultListableBeanFactory beanFactory = unwrapDefaultListableBeanFactory(registry); if (beanFactory != null) &#123; if (!(beanFactory.getDependencyComparator() instanceof AnnotationAwareOrderComparator)) &#123; beanFactory.setDependencyComparator(AnnotationAwareOrderComparator.INSTANCE); &#125; if (!(beanFactory.getAutowireCandidateResolver() instanceof ContextAnnotationAutowireCandidateResolver)) &#123; beanFactory.setAutowireCandidateResolver(new ContextAnnotationAutowireCandidateResolver()); &#125; &#125; Set&lt;BeanDefinitionHolder&gt; beanDefs = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(4); if (!registry.containsBeanDefinition(CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ConfigurationClassPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def,CONFIGURATION_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(AutowiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, AUTOWIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(RequiredAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, REQUIRED_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // Check for JSR-250 support, and if present add the CommonAnnotationBeanPostProcessor. if (jsr250Present &amp;&amp; !registry.containsBeanDefinition(COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(CommonAnnotationBeanPostProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, COMMON_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; // Check for JPA support, and if present add the PersistenceAnnotationBeanPostProcessor. if (jpaPresent &amp;&amp; !registry.containsBeanDefinition(PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); def.setBeanClass(ClassUtils.forName(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader())); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, PERSISTENCE_ANNOTATION_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(EVENT_LISTENER_PROCESSOR_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(EventListenerMethodProcessor.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_PROCESSOR_BEAN_NAME)); &#125; if (!registry.containsBeanDefinition(EVENT_LISTENER_FACTORY_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(DefaultEventListenerFactory.class); def.setSource(source); beanDefs.add(registerPostProcessor(registry, def, EVENT_LISTENER_FACTORY_BEAN_NAME)); &#125; return beanDefs;&#125; AnnotationAwareOrderComparator其继承体系如下: 其作用是比较标注了@Order或是javax.annotation.Priority @Priority注解的元素的优先级。这两种注解的一个常用功能就是设置配置加载的优先级。例子可以参考: Spring 4.2新特性-使用@Order调整配置类加载顺序 ContextAnnotationAutowireCandidateResolver此类用以决定一个bean是否可以当作一个依赖的候选者。其类图: ConfigurationClassPostProcessor此类用于处理标注了@Configuration注解的类。类图: AutowiredAnnotationBeanPostProcessor此类便用于对标注了@Autowire等注解的bean或是方法进行注入。 RequiredAnnotationBeanPostProcessor对应Spring @Require注解，此注解被用在setter方法上，意味着此setter方法对应的属性必须被Spring所注入，但是不会检查是否是null。其继承体系和上面的AutowiredAnnotationBeanPostProcessor完全一样。 CommonAnnotationBeanPostProcessor用于开启对JSR-250的支持，开启的先决条件是当前classpath中有其类，检测的源码: 12private static final boolean jsr250Present = ClassUtils.isPresent(\"javax.annotation.Resource\", AnnotationConfigUtils.class.getClassLoader()); 此注解就在rt.jar下，所以默认情况下都是开启JSR-250支持的，所以我们就可以使用喜闻乐见的@Resource注解了。其类图: PersistenceAnnotationBeanPostProcessor用于提供JPA支持，开启的先决条件仍然是检测classpath下是否有其类存在，源码: 123456private static final boolean jpaPresent = ClassUtils.isPresent(\"javax.persistence.EntityManagerFactory\", AnnotationConfigUtils.class.getClassLoader()) &amp;&amp; //org.springframework.orm包 ClassUtils.isPresent(PERSISTENCE_ANNOTATION_PROCESSOR_CLASS_NAME, AnnotationConfigUtils.class.getClassLoader()); rt.jar下面并没有JPA的包，所以此Processor默认是没有被注册的。其类图和上面CommonAnnotationBeanPostProcessor如出一辙。 EventListenerMethodProcessor提供对于注解@EventListener的支持，此注解在Spring4.2被添加，用于监听ApplicationEvent事件。其继承体系: DefaultEventListenerFactory此类应该是和上面的配合使用，用以产生EventListener对象，也是从Spring4.2加入，类图: 逻辑关系整理普通的bean元素(XML)其实都有一个BeanDefinition对象与之对应，但是对于context开头的这种的特殊的元素，它所对应的一般不再是普通意义上的BeanDefinition，而是配合起来一起完成某种功能的组件(比如各种BeanPostProcessor)。这种组件Spring抽象成为ComponentDefinition接口，组件的集合表示成为CompositeComponentDefinition，类图: 最终形成的数据结构如下图: 不过这个数据结构貌似也没什么用，因为调用的是XmlBeanDefinitionReader中的eventListener的componentRegistered方法，然而这里的eventListener是EmptyReaderEventListener，也就是空实现。 运行ConfigurationClassPostProcessor本身是一个BeanFactoryPostProcessor对象，其执行入口在AbstractApplicationContext.refresh方法: 1invokeBeanFactoryPostProcessors(beanFactory); 注意，因为ConfigurationClassPostProcessor实现自BeanDefinitionRegistryPostProcessor接口，所以在此处会首先调用其postProcessBeanDefinitionRegistry方法，再调用其postProcessBeanFactory方法。 postProcessBeanDefinitionRegistry此方法大体由两部分组成。 BeanPostProcessor注册此部分源码: 123456789@Overridepublic void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123; RootBeanDefinition iabpp = new RootBeanDefinition(ImportAwareBeanPostProcessor.class); iabpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(IMPORT_AWARE_PROCESSOR_BEAN_NAME, iabpp); RootBeanDefinition ecbpp = new RootBeanDefinition(EnhancedConfigurationBeanPostProcessor.class); ecbpp.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); registry.registerBeanDefinition(ENHANCED_CONFIGURATION_PROCESSOR_BEAN_NAME, ecbpp);&#125; ImportAwareBeanPostProcessor是ConfigurationClassPostProcessor的私有内部类。其类图: 此类用于处理实现了ImportAware接口的类。ImportAware接口是做什么的要从使用java源文件作为Spring配置说起: 有一个类负责生成Student bean: 1234567891011121314@Configurationpublic class StudentConfig implements ImportAware &#123; @Bean public Student student() &#123; Student student = new Student(); student.setAge(22); student.setName(\"skywalker\"); return student; &#125; @Override public void setImportMetadata(AnnotationMetadata importMetadata) &#123; System.out.println(\"importaware\"); &#125;&#125; 生成的bean就以所在的方法名命名。还有一个类负责生成SimpleBean: 123456789101112@Configuration@Import(StudentConfig.class)public class SimpleBeanConfig &#123; @Autowired private StudentConfig studentConfig; @Bean public SimpleBean getSimpleBean() &#123; //bean依赖 SimpleBean simpleBean = new SimpleBean(studentConfig.student()); return simpleBean; &#125;&#125; 启动代码: 123456public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(SimpleBeanConfig.class); SimpleBean simpleBean = context.getBean(SimpleBean.class); System.out.println(simpleBean.getStudent().getName());&#125; 所以ImportAware接口的作用就是使被引用的配置类可以获得引用类的相关信息。 EnhancedConfigurationBeanPostProcessor用于为实现了EnhancedConfiguration接口的类设置BeanFactory对象，所有的@Configuration Cglib子类均实现了此接口，为什么要这么做不太明白。 类解析这里便是对标注了@Configuration注解的类及进行解析，通过调用ConfigurationClassPostProcessor的processConfigBeanDefinitions方法来实现，具体怎么解析就不详细说明了。 bean名字生成策略对于配置类，Spring也会将其当作一个bean放到容器中，这就关系到bean的起名了，其实这部分对于@Component, @Controller等注解都是一样的。 ConfigurationClassPostProcessor.processConfigBeanDefinitions相关代码: 12345678910111213// Detect any custom bean name generation strategy supplied through the enclosing application contextSingletonBeanRegistry singletonRegistry = null;if (registry instanceof SingletonBeanRegistry) &#123; singletonRegistry = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet &amp;&amp; //org.springframework.context.annotation.internalConfigurationBeanNameGenerator singletonRegistry.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123; BeanNameGenerator generator = (BeanNameGenerator) singletonRegistry. getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR); this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; &#125;&#125; 默认是一个AnnotationBeanNameGenerator对象，其类图: 那我们可以通过向Spring容器添加一个自定义BeanNameGenerator对象的方式自定义beanName生成策略吗，答案是不可以，这也是为什么此bean的ID前面以internal开头。从代码上来看，不可以的原因在于BeanFactoryPostProcessor的触发时机: 配置解析、BeanDefinition加载之后，Singleton初始化之前，所以即使配置了此接口的实现，但是此时此bean尚未初始化，所以根本看不到此实例。 postProcessBeanFactory此方法调用了enhanceConfigurationClasses，其实就是将@Configuration的beanClass转换为CGLIB代理子类。简略版的源码: 12345678910111213141516171819202122232425262728public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123; Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;String, AbstractBeanDefinition&gt;(); //寻找@Configuration的BeanDefinition for (String beanName : beanFactory.getBeanDefinitionNames()) &#123; BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName); if (ConfigurationClassUtils.isFullConfigurationClass(beanDef)) &#123; configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef); &#125; &#125; if (configBeanDefs.isEmpty()) &#123; // nothing to enhance -&gt; return immediately return; &#125; ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer(); for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123; AbstractBeanDefinition beanDef = entry.getValue(); // If a @Configuration class gets proxied, always proxy the target class beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE); // Set enhanced subclass of the user-specified bean class Class&lt;?&gt; configClass = beanDef.resolveBeanClass(this.beanClassLoader); Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader); if (configClass != enhancedClass) &#123; //替换 beanDef.setBeanClass(enhancedClass); &#125; &#125;&#125; ConfigurationClassEnhancer.newEnhancer: 12345678910111213private Enhancer newEnhancer(Class&lt;?&gt; superclass, ClassLoader classLoader) &#123; Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(superclass); //这里印证了前面EnhancedConfigurationBeanPostProcessor的说明 enhancer.setInterfaces(new Class&lt;?&gt;[] &#123;EnhancedConfiguration.class&#125;); enhancer.setUseFactory(false); enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE); enhancer.setStrategy(new BeanFactoryAwareGeneratorStrategy(classLoader)); //关键 enhancer.setCallbackFilter(CALLBACK_FILTER); enhancer.setCallbackTypes(CALLBACK_FILTER.getCallbackTypes()); return enhancer;&#125; CALLBACK_FILTER是个什么东西呢: 12345678private static final ConditionalCallbackFilter CALLBACK_FILTER = new ConditionalCallbackFilter(CALLBACKS);private static final Callback[] CALLBACKS = new Callback[] &#123; new BeanMethodInterceptor(), new BeanFactoryAwareMethodInterceptor(), NoOp.INSTANCE&#125;; 这么做的原因有两个: 提供Scope支持: 我们可以使用@Scope注解来使用注解的方式配置其Scope: 12345678@Bean@Scope(\"prototype\")public Student student() &#123; Student student = new Student(); student.setAge(22); student.setName(\"skywalker\"); return student;&#125; Spring正是通过生成CGLIB子类的方式来提供Scope的语义。更确切的说，是上面源码里面的BeanMethodInterceptor。 实现EnhancedConfiguration接口 AutowiredAnnotationBeanPostProcessor类图见上面，由于Adapter的存在，真正实现的是postProcessMergedBeanDefinition和postProcessPropertyValues两个方法。 postProcessMergedBeanDefinition入口其中前者首先被调用，时机是当BeanDefinition被合并(和父Bean)，但是还没有用来创建Bean实例时。回顾下其调用入口: AbstractAutowireCapableBeanFactory.doCreateBean(简略): 12345678910111213141516171819protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); // Allow post-processors to modify the merged bean definition. synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); mbd.postProcessed = true; &#125; &#125;&#125; applyMergedBeanDefinitionPostProcessors: 123456789protected void applyMergedBeanDefinitionPostProcessors(RootBeanDefinition mbd, Class&lt;?&gt; beanType, String beanName) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof MergedBeanDefinitionPostProcessor) &#123; MergedBeanDefinitionPostProcessor bdp = (MergedBeanDefinitionPostProcessor) bp; bdp.postProcessMergedBeanDefinition(mbd, beanType, beanName); &#125; &#125;&#125; 源码12345678@Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; if (beanType != null) &#123; InjectionMetadata metadata = findAutowiringMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); &#125;&#125; findAutowiringMetadata: 12345678910111213141516171819private InjectionMetadata findAutowiringMetadata(String beanName, Class&lt;?&gt; clazz, PropertyValues pvs) &#123; // Fall back to class name as cache key, for backwards compatibility with custom callers. String cacheKey = (StringUtils.hasLength(beanName) ? beanName : clazz.getName()); // Quick check on the concurrent map first, with minimal locking. InjectionMetadata metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; synchronized (this.injectionMetadataCache) &#123; metadata = this.injectionMetadataCache.get(cacheKey); if (InjectionMetadata.needsRefresh(metadata, clazz)) &#123; if (metadata != null) &#123; metadata.clear(pvs); &#125; metadata = buildAutowiringMetadata(clazz); this.injectionMetadataCache.put(cacheKey, metadata); &#125; &#125; &#125; return metadata;&#125; injectionMetadataCache是一个ConcurrentHashMap对象，个人认为设置此缓存有以下几个原因: 假设有多线程同时调用针对某一个bean的getBean方法，那么这样可以保证只有一个线程执行一次@Autowire注解的扫描工作。 对于非singleton(比如prototype)类型的bean，这样同样可以保证只解析一次，防止做无用功。 可以看到，Spring使用了代价更小的ConcurrentHashMap来先做一个预检测，这样尽可能的减小锁的使用以及粒度，值得借鉴。 @Autowire注解的扫描在buildAutowiringMetadata方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private InjectionMetadata buildAutowiringMetadata(final Class&lt;?&gt; clazz) &#123; LinkedList&lt;InjectionMetadata.InjectedElement&gt; elements = new LinkedList&lt;InjectionMetadata.InjectedElement&gt;(); Class&lt;?&gt; targetClass = clazz; //循环检测父类 do &#123; final LinkedList&lt;InjectionMetadata.InjectedElement&gt; currElements = new LinkedList&lt;InjectionMetadata.InjectedElement&gt;(); ReflectionUtils.doWithLocalFields(targetClass, new ReflectionUtils.FieldCallback() &#123; @Override public void doWith(Field field) throws IllegalArgumentException, IllegalAccessException &#123; AnnotationAttributes ann = findAutowiredAnnotation(field); if (ann != null) &#123; //不支持静态变量 if (Modifier.isStatic(field.getModifiers())) &#123; return; &#125; boolean required = determineRequiredStatus(ann); currElements.add(new AutowiredFieldElement(field, required)); &#125; &#125; &#125;); ReflectionUtils.doWithLocalMethods(targetClass, new ReflectionUtils.MethodCallback() &#123; @Override public void doWith(Method method) throws IllegalArgumentException, IllegalAccessException &#123; Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); if (!BridgeMethodResolver.isVisibilityBridgeMethodPair(method, bridgedMethod)) &#123; return; &#125; AnnotationAttributes ann = findAutowiredAnnotation(bridgedMethod); if (ann != null &amp;&amp; method.equals(ClassUtils.getMostSpecificMethod(method, clazz))) &#123; if (Modifier.isStatic(method.getModifiers())) &#123; return; &#125; if (method.getParameterTypes().length == 0) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Autowired annotation should be used on methods with parameters: \" + method); &#125; &#125; boolean required = determineRequiredStatus(ann); PropertyDescriptor pd = BeanUtils.findPropertyForMethod(bridgedMethod, clazz); currElements.add(new AutowiredMethodElement(method, required, pd)); &#125; &#125; &#125;); elements.addAll(0, currElements); targetClass = targetClass.getSuperclass(); &#125; while (targetClass != null &amp;&amp; targetClass != Object.class); return new InjectionMetadata(clazz, elements);&#125; 可以看出，Spring使用了一个do while循环来一直检测其父类，直到Object，这就说明，Spring注入注解可以配置在此bean的父类上。其实，最开始的时候网站的Service层和Dao层一直都是这么做的。 变量扫描之后便是逐一扫描当前类的成员变量，检测是否有@Autowire注解。 ReflectionUtils的实现其实就是访问者模式，其源码: 12345678public static void doWithLocalFields(Class&lt;?&gt; clazz, FieldCallback fc) &#123; for (Field field : getDeclaredFields(clazz)) &#123; try &#123; fc.doWith(field); &#125; catch (IllegalAccessException ex) &#123;&#125; &#125;&#125; determineRequiredStatus方法用以判断是否是必须的，所谓的必须是指: 如果容器里没有需要的bean，那么会抛出异常，否则就忽略了，默认是必须的。原理很简单，不说了。 方法扫描bridge方法就是方法扫描的第一行源码: 1Method bridgedMethod = BridgeMethodResolver.findBridgedMethod(method); 此句代码的作用是判断method是否是bridge方法，如果是，寻找其真正的方法。这里的bridge方法并不是所谓的bridge模式。 有这样的demo代码: 1234567891011121314public class JavaTest &#123; private class MyList extends ArrayList &#123; //注意父类的返回类型是Object @Override public String get(int index) &#123; return \"\"; &#125; &#125; public static void main(String[] args) &#123; for (Method method : MyList.class.getDeclaredMethods()) &#123; System.out.println(\"name: \" + method.getName() + \", return: \" + method.getReturnType()); &#125; &#125;&#125; 子类重写父类的方法但是返回值不同在java语言里是合法的。此程序的输出: 12name: get, return: class java.lang.Stringname: get, return: class java.lang.Object 通过javap反编译命令也可以看到有两个get方法。其中返回Object的便是bridge方法。jdk从1.5开始便提供了方法判断是否是此种方法: Method: 1234567891011/** * Returns &#123;@code true&#125; if this method is a bridge * method; returns &#123;@code false&#125; otherwise. * * @return true if and only if this method is a bridge * method as defined by the Java Language Specification. * @since 1.5 */public boolean isBridge() &#123; return (getModifiers() &amp; Modifier.BRIDGE) != 0;&#125; 可以看出，bridge和static之类一样，在java内部也是有一个修饰符的，只不过只在jvm内部可见。 可以参考: Java那些不为人知的特殊方法 到这里寻找真正方法的原理也好理解了，就是在所有Method中寻找方法名相同、参数列表相同但返回值不同的。 PropertyDescriptor用于描述java bean，如果被标注@Autowire的方法是一个getter或setter方法，那么Spring会保存下来其PropertyDescriptor对象，如果不是，那么就是空。 postProcessPropertyValues入口AbstractAutowireCapableBeanFactory.populateBean方法，执行时机是在bean的属性都已经计算(根据xml配置进行完autowire)完毕，设置到bean实例之前。 注入源码: 123456public void processInjection(Object bean) throws BeansException &#123; Class&lt;?&gt; clazz = bean.getClass(); // 查找缓存 InjectionMetadata metadata = findAutowiringMetadata(clazz.getName(), clazz, null); metadata.inject(bean, null, null);&#125; 根据上面postProcessMergedBeanDefinition一节的说明，解析的结果最终保存为一个InjectionMetadata对象，其内部含有一个InjectionMetadata.InjectedElement类型的List，所以注入的过程实际上便是遍历此List调用每一个InjectionMetadata.InjectedElement的inject的过程。 Field注入实现类是AutowiredFieldElement。注入的原理就是从容器中查找相关的依赖，用反射的方法调用Field的set方法，不在详细说了。 方法注入实现类是AutowiredMethodElement。注入的原理是遍历此方法的参数列表，针对每一个参数都去容器中寻找相应的bean，之后调用Method的invoke方法即可。 RequiredAnnotationBeanPostProcessor上面提到了，此类的类图和上面的邻居类似，所以调用的方法的顺序、时机都是一样，所以不再赘述。 postProcessMergedBeanDefinition空实现，就是这么任性: 123@Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123;&#125; postProcessPropertyValues源码: 123456789101112131415161718192021@Overridepublic PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) throws BeansException &#123; if (!this.validatedBeanNames.contains(beanName)) &#123; if (!shouldSkip(this.beanFactory, beanName)) &#123; List&lt;String&gt; invalidProperties = new ArrayList&lt;String&gt;(); for (PropertyDescriptor pd : pds) &#123; if (isRequiredProperty(pd) &amp;&amp; !pvs.contains(pd.getName())) &#123; invalidProperties.add(pd.getName()); &#125; &#125; if (!invalidProperties.isEmpty()) &#123; throw new BeanInitializationException(buildExceptionMessage (invalidProperties, beanName)); &#125; &#125; this.validatedBeanNames.add(beanName); &#125; return pvs;&#125; 结果缓存validatedBeanNames是一个Set类型，对于已经检查过的bean，将其name加入Set，防止做无用功。 PropertyDescriptor从源码可以看出，校验是通过PropertyDescriptor完成的，那么这个数组是从哪里来的呢? AbstractAutowireCapableBeanFactory.populateBean相关代码: 123456789101112PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);if (hasInstAwareBpps) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125;&#125; filterPropertyDescriptorsForDependencyCheck单参数方法: 1234567891011protected PropertyDescriptor[] filterPropertyDescriptorsForDependencyCheck(BeanWrapper bw) &#123; List&lt;PropertyDescriptor&gt; pds = new LinkedList&lt;PropertyDescriptor&gt;(Arrays.asList(bw.getPropertyDescriptors())); for (Iterator&lt;PropertyDescriptor&gt; it = pds.iterator(); it.hasNext();) &#123; PropertyDescriptor pd = it.next(); if (isExcludedFromDependencyCheck(pd)) &#123; it.remove(); &#125; &#125; return pds.toArray(new PropertyDescriptor[pds.size()]);&#125; 可以看出，最终来自于BeanWrapper。那么BeanWrapper又是从哪里弄来的呢? BeanWrapperImpl.getPropertyDescriptors: 1234567891011@Overridepublic PropertyDescriptor[] getPropertyDescriptors() &#123; return getCachedIntrospectionResults().getPropertyDescriptors();&#125;private CachedIntrospectionResults getCachedIntrospectionResults() &#123; Assert.state(getWrappedInstance() != null, \"BeanWrapper does not hold a bean instance\"); if (this.cachedIntrospectionResults == null) &#123; this.cachedIntrospectionResults = CachedIntrospectionResults.forClass(getWrappedClass()); &#125; return this.cachedIntrospectionResults;&#125; 所以，这时BeanWrapper便会把自己”内省”一遍。这从侧面说明@Reqired注解只对setter方法有效。 测试有一个bean如下: 123456789101112131415161718@Component(\"simpleBean\")public class SimpleBean &#123; @Autowired(required = false) private Student student; public SimpleBean() &#123;&#125; public SimpleBean(Student student) &#123; this.student = student; &#125; public Student getStudent() &#123; return student; &#125; @Required public void setStudent(Student student) &#123; this.student = student; &#125;&#125; 注意先关闭@Autowire的检测，否则用不到@Required注解便会报错。运行之后的结果: CommonAnnotationBeanPostProcessor从其类图可以看出，此类主要是整合了MergedBeanDefinitionPostProcessor和DestructionAwareBeanPostProcessor的功能。其功能体现在以下几个方法，按调用顺序进行说明。 postProcessMergedBeanDefinition此方法的执行入口以及调用时机上面已经说过了。其源码: 12345678@Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; super.postProcessMergedBeanDefinition(beanDefinition, beanType, beanName); if (beanType != null) &#123; InjectionMetadata metadata = findResourceMetadata(beanName, beanType, null); metadata.checkConfigMembers(beanDefinition); &#125;&#125; 父类可以看出，首先调用了其父类InitDestroyAnnotationBeanPostProcessor的postProcessMergedBeanDefinition方法，源码: 1234567@Overridepublic void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName) &#123; if (beanType != null) &#123; LifecycleMetadata metadata = findLifecycleMetadata(beanType); metadata.checkConfigMembers(beanDefinition); &#125;&#125; findLifecycleMetadata的套路和上面运行-AutowiredAnnotationBeanPostProcessor-源码一节中所说完全一样，所不同的是此处是遍历所有method寻找初始化和销毁方法标记。这两个标记很有意思，Spring允许我们自定义是哪两个标记(getter/setter方法)。子类CommonAnnotationBeanPostProcessor在构造器中设置了其值: 1234public CommonAnnotationBeanPostProcessor() &#123; setInitAnnotationType(PostConstruct.class); setDestroyAnnotationType(PreDestroy.class);&#125; 这两个标签来自于javax.annotation包。那么怎么自定义呢? CommonAnnotationBeanPostProcessor本质上是一个BeanPostProcessor，所以我们可以自己注入，配置文件: 123&lt;bean class=\"org.springframework.context.annotation.CommonAnnotationBeanPostProcessor\"&gt; &lt;property name=\"initAnnotationType\" value=\"annotation.Init\" /&gt;&lt;/bean&gt; Init是一个很简单的自定义注解: 123@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.METHOD)public @interface Init &#123;&#125; 在自己的bean中使用此注解: 1234@Initpublic void init() &#123; System.out.println(\"Init!\");&#125; 运行Spring便可以看到效果。 另外注意一点，从前面annotation-config-BeanPostProcessor注册一节的源码中可以看出，Spring在向容器中添加CommonAnnotationBeanPostProcessor时只是检测其ID(org.springframework.context.annotation.internalCommonAnnotationProcessor)是否存在，这就造成了一个问题: 如果按上面所说的配置，那么在容器中实际上有两个CommonAnnotationProcessor存在，也就是说，@PostConstruct和@PreDestroy注解此时依然被支持。为了达到只有一个实例的目的，需要为前面的配置加上ID。 子类findResourceMetadata的套路还是一样，就是在属性和方法上寻找@Resource标签。 postProcessPropertyValues源码: 1234567@Overridepublic PropertyValues postProcessPropertyValues( PropertyValues pvs, PropertyDescriptor[] pds, Object bean, String beanName) &#123; InjectionMetadata metadata = findResourceMetadata(beanName, bean.getClass(), pvs); metadata.inject(bean, beanName, pvs); return pvs;&#125; 套路很明显了。 postProcessBeforeInitialization实现在父类InitDestroyAnnotationBeanPostProcessor： 123456@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) &#123; LifecycleMetadata metadata = findLifecycleMetadata(bean.getClass()); metadata.invokeInitMethods(bean, beanName); return bean;&#125; invokeInitMethods: 12345678910public void invokeInitMethods(Object target, String beanName) throws Throwable &#123; Collection&lt;LifecycleElement&gt; initMethodsToIterate = (this.checkedInitMethods != null ? this.checkedInitMethods : this.initMethods); if (!initMethodsToIterate.isEmpty()) &#123; for (LifecycleElement element : initMethodsToIterate) &#123; // 反射调用 element.invoke(target); &#125; &#125;&#125; 不过从源码来看应该支持多个init方法。 postProcessBeforeDestruction反射调用销毁方法，没啥说的了。 EventListenerMethodProcessor就一个值得关注的方法: afterSingletonsInstantiated。 入口DefaultListableBeanFactory.preInstantiateSingletons相关源码: 12345678910111213141516171819// Trigger post-initialization callback for all applicable beans...for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125;&#125; 源码略过。 component-scanComponentScanBeanDefinitionParser.parse源码: 12345678910111213141516@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; // base-package属性 String basePackage = element.getAttribute(BASE_PACKAGE_ATTRIBUTE); // 解析占位符 basePackage = parserContext.getReaderContext().getEnvironment() .resolvePlaceholders(basePackage); //分割成数据 String[] basePackages = StringUtils.tokenizeToStringArray(basePackage, ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS); // Actually scan for bean definitions and register them. ClassPathBeanDefinitionScanner scanner = configureScanner(parserContext, element); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = scanner.doScan(basePackages); registerComponents(parserContext.getReaderContext(), beanDefinitions, element); return null;&#125; 初始化此部分负责初始化包扫描用到的扫描器，是一个ClassPathBeanDefinitionScanner对象，configureScanner方法源码: 12345678910111213141516171819202122232425protected ClassPathBeanDefinitionScanner configureScanner(ParserContext parserContext, Element element) &#123; boolean useDefaultFilters = true; if (element.hasAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)) &#123; useDefaultFilters = Boolean.valueOf(element.getAttribute(USE_DEFAULT_FILTERS_ATTRIBUTE)); &#125; // Delegate bean definition registration to scanner class. ClassPathBeanDefinitionScanner scanner = createScanner (parserContext.getReaderContext(), useDefaultFilters); scanner.setResourceLoader(parserContext.getReaderContext().getResourceLoader()); scanner.setEnvironment(parserContext.getReaderContext().getEnvironment()); scanner.setBeanDefinitionDefaults(parserContext.getDelegate().getBeanDefinitionDefaults()); scanner.setAutowireCandidatePatterns(parserContext.getDelegate().getAutowireCandidatePatterns()); if (element.hasAttribute(RESOURCE_PATTERN_ATTRIBUTE)) &#123; scanner.setResourcePattern(element.getAttribute(RESOURCE_PATTERN_ATTRIBUTE)); &#125; parseBeanNameGenerator(element, scanner); parseScope(element, scanner); parseTypeFilters(element, scanner, parserContext); return scanner;&#125; 下面开始按顺序分部分说明。 use-default-filterscomponent-scan注解会默认扫描喜闻乐见的@Component、@Repository、@Service和@Controller四大金刚。如果此属性设为false，那么就不会扫描这几个属性。 扫描器:创建 &amp; 初始化就是createScanner方法和下面那一坨setter方法，没啥好说的。 resource-pattern用以配置扫描器扫描的路径，默认**/*.class。 name-generator可以指定命名策略，这个在前面运行-ConfigurationClassPostProcessor-类解析一节中说过。Spring在parseBeanNameGenerator方法会直接使用反射的方法生成其对象。 scope-resolver指定使用的ScopeMetadataResolver。此接口用于解析bean的scope定义，其类图: 默认是AnnotationScopeMetadataResolver，也就是解析@Scope标签。 scoped-proxy此配置的意思应该是是否为检测到的bean生成代理子类，共有三个选项: interfaces, no, targetClasses，默认no。原理应该就像对@Configuration类的处理，Spring自己说是实现proxy style，不知所云。 exclude-filter/include-filter用法示例: 123&lt;context:component-scan base-package=\"base\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"javax.annotation.Resource\" /&gt;&lt;/context:component-scan&gt; parseTypeFilters方法负责此部分的解析，只贴部分源码: 1234567if (INCLUDE_FILTER_ELEMENT.equals(localName)) &#123; TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext); scanner.addIncludeFilter(typeFilter);&#125; else if (EXCLUDE_FILTER_ELEMENT.equals(localName)) &#123; TypeFilter typeFilter = createTypeFilter((Element) node, classLoader, parserContext); scanner.addExcludeFilter(typeFilter);&#125; annotation-config此属性等同于配置，默认就是true，也就是说，如果配置了context:component-scan其实就没有必要配置annotation-config 了。 扫描入口方法便是ClassPathBeanDefinitionScanner.doScan: 1234567891011121314151617181920212223242526272829protected Set&lt;BeanDefinitionHolder&gt; doScan(String... basePackages) &#123; Assert.notEmpty(basePackages, \"At least one base package must be specified\"); Set&lt;BeanDefinitionHolder&gt; beanDefinitions = new LinkedHashSet&lt;BeanDefinitionHolder&gt;(); for (String basePackage : basePackages) &#123; // 逐包扫描 Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage); for (BeanDefinition candidate : candidates) &#123; ScopeMetadata scopeMetadata = this.scopeMetadataResolver.resolveScopeMetadata(candidate); candidate.setScope(scopeMetadata.getScopeName()); String beanName = this.beanNameGenerator.generateBeanName(candidate, this.registry); if (candidate instanceof AbstractBeanDefinition) &#123; // 为BeanDefinition设置默认的属性 postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName); &#125; if (candidate instanceof AnnotatedBeanDefinition) &#123; AnnotationConfigUtils.processCommonDefinitionAnnotations ((AnnotatedBeanDefinition) candidate); &#125; if (checkCandidate(beanName, candidate)) &#123; BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName); definitionHolder = AnnotationConfigUtils.applyScopedProxyMode (scopeMetadata, definitionHolder, this.registry); beanDefinitions.add(definitionHolder); registerBeanDefinition(definitionHolder, this.registry); &#125; &#125; &#125; return beanDefinitions;&#125; 逐包扫描/BeanDefinition解析扫描其实就是在classpath下直接读取class文件。读取到的class文件被Spring用Resource接口表示。之后交由MetadataReader进行解析，其类图: 对class文件的读取、分析是通过ASM完成的，入口在SimpleMetadataReader的构造器: 12345678910111213SimpleMetadataReader(Resource resource, ClassLoader classLoader) throws IOException &#123; InputStream is = new BufferedInputStream(resource.getInputStream()); ClassReader classReader; classReader = new ClassReader(is); AnnotationMetadataReadingVisitor visitor = new AnnotationMetadataReadingVisitor(classLoader); classReader.accept(visitor, ClassReader.SKIP_DEBUG); this.annotationMetadata = visitor; // (since AnnotationMetadataReadingVisitor extends ClassMetadataReadingVisitor) this.classMetadata = visitor; this.resource = resource;&#125; 解析的关键便在于AnnotationMetadataReadingVisitor，其类图: 核心在于其visitAnnotation方法: 1234567@Overridepublic AnnotationVisitor visitAnnotation(final String desc, boolean visible) &#123; String className = Type.getType(desc).getClassName(); this.annotationSet.add(className); return new AnnotationAttributesReadingVisitor( className, this.attributesMap, this.metaAnnotationMap, this.classLoader);&#125; 返回一个AnnotationVisitor表示对此注解的属性感兴趣，用于解析其属性。最终得到的BeanDefinition集合是ScannedGenericBeanDefinition类型，其类图: @Scope解析AnnotationScopeMetadataResolver.resolveScopeMetadata: 1234567891011121314151617181920@Overridepublic ScopeMetadata resolveScopeMetadata(BeanDefinition definition) &#123; ScopeMetadata metadata = new ScopeMetadata(); if (definition instanceof AnnotatedBeanDefinition) &#123; AnnotatedBeanDefinition annDef = (AnnotatedBeanDefinition) definition; // 寻找Scope相关的属性，AnnotationAttributes是LinkedHashMap的子类 AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor( annDef.getMetadata(), this.scopeAnnotationType); if (attributes != null) &#123; // @Scope值 metadata.setScopeName(attributes.getString(\"value\")); ScopedProxyMode proxyMode = attributes.getEnum(\"proxyMode\"); if (proxyMode == null || proxyMode == ScopedProxyMode.DEFAULT) &#123; proxyMode = this.defaultProxyMode; &#125; metadata.setScopedProxyMode(proxyMode); &#125; &#125; return metadata;&#125; proxyMode和xml的scoped-proxy属性是一个概念: 1@Scope(value = \"singleton\", proxyMode = ScopedProxyMode.DEFAULT) XML的属性是全局的配置，这个是局部(针对单个bean)的配置，和XML属性相比对了一个default选项，这个就表示使用XML属性的配置。 bean名字生成AnnotationBeanNameGenerator.generateBeanName: 123456789101112@Overridepublic String generateBeanName(BeanDefinition definition, BeanDefinitionRegistry registry) &#123; if (definition instanceof AnnotatedBeanDefinition) &#123; String beanName = determineBeanNameFromAnnotation((AnnotatedBeanDefinition) definition); if (StringUtils.hasText(beanName)) &#123; // Explicit bean name found. return beanName; &#125; &#125; // Fallback: generate a unique default bean name. return buildDefaultBeanName(definition, registry);&#125; 根据注解默认会首先尝试根据@Component、@Service、@Controller、@Repository、@ManagedBean、@Named的value属性生成，determineBeanNameFromAnnotation: 1234567891011121314151617181920212223protected String determineBeanNameFromAnnotation(AnnotatedBeanDefinition annotatedDef) &#123; AnnotationMetadata amd = annotatedDef.getMetadata(); Set&lt;String&gt; types = amd.getAnnotationTypes(); String beanName = null; // 遍历当前bean拥有的所有类级注解 for (String type : types) &#123; // 获取此注解所有的属性 AnnotationAttributes attributes = AnnotationConfigUtils.attributesFor(amd, type); if (isStereotypeWithNameValue(type, amd.getMetaAnnotationTypes(type), attributes)) &#123; Object value = attributes.get(\"value\"); if (value instanceof String) &#123; String strVal = (String) value; if (StringUtils.hasLength(strVal)) &#123; if (beanName != null &amp;&amp; !strVal.equals(beanName)) &#123; throw new IllegalStateException(); &#125; beanName = strVal; &#125; &#125; &#125; &#125; return beanName;&#125; isStereotypeWithNameValue方法用于判断此注解是否可以用来生成beanName，比如@Scope便不适合: 123456789protected boolean isStereotypeWithNameValue(String annotationType, Set&lt;String&gt; metaAnnotationTypes, Map&lt;String, Object&gt; attributes) &#123; // org.springframework.stereotype.Component boolean isStereotype = annotationType.equals(COMPONENT_ANNOTATION_CLASSNAME) || (metaAnnotationTypes != null &amp;&amp; metaAnnotationTypes.contains(COMPONENT_ANNOTATION_CLASSNAME)) || annotationType.equals(\"javax.annotation.ManagedBean\") || annotationType.equals(\"javax.inject.Named\"); return (isStereotype &amp;&amp; attributes != null &amp;&amp; attributes.containsKey(\"value\"));&#125; metaAnnotationTypes用以判断元注解，针对这种情况: 12@Componentpublic @interface Controller &#123;&#125; 可以看出，判断是否可以用来生成名字的依据便是注解类型是否在上面提到的6种之列并且value属性不为空。 默认策略如果上面提到的条件不满足，那么便会用默认策略生成beanName，buildDefaultBeanName： 123456protected String buildDefaultBeanName(BeanDefinition definition) &#123; // base.SimpleBean -&gt; SimpleBean String shortClassName = ClassUtils.getShortName(definition.getBeanClassName()); //SimpleBean -&gt; simpleBean return Introspector.decapitalize(shortClassName);&#125; 注意，对于内部类: OuterClassName.InnerClassName -&gt; outerClassName.InnerClassName. 其它注解解析入口在AnnotationConfigUtils.processCommonDefinitionAnnotations，其它指的是这几个: 123456@Lazy@Primary@DependsOn(\"student\")@Role(BeanDefinition.ROLE_APPLICATION)@Description(\"This is a simple bean.\")public class SimpleBean &#123;&#125; 这里面就是@Role没见过，默认就是上面那个值，Spring说这是一个”hint”，可能没啥卵用，希望不要被打脸。解析之后设置到BeanDefinition，没啥好说的。 冲突检测Spring会检测容器中是否已经存在同名的BeanDefinition。ClassPathBeanDefinitionScanner.checkCandidate: 123456789101112131415protected boolean checkCandidate(String beanName, BeanDefinition beanDefinition) &#123; // 没有同名的，直接返回 if (!this.registry.containsBeanDefinition(beanName)) &#123; return true; &#125; BeanDefinition existingDef = this.registry.getBeanDefinition(beanName); BeanDefinition originatingDef = existingDef.getOriginatingBeanDefinition(); if (originatingDef != null) &#123; existingDef = originatingDef; &#125; if (isCompatible(beanDefinition, existingDef)) &#123; return false; &#125; throw new ConflictingBeanDefinitionException(\"冲突啦!\");&#125; isCompatible用于判断和之前的BeanDefinition是否兼容: 12345678protected boolean isCompatible(BeanDefinition newDefinition, BeanDefinition existingDefinition) &#123; //// explicitly registered overriding bean return (!(existingDefinition instanceof ScannedGenericBeanDefinition) || //// scanned same file twice newDefinition.getSource().equals(existingDefinition.getSource()) || // scanned equivalent class twice newDefinition.equals(existingDefinition)); &#125; 可以看出，如果已经存在的BeanDefinition不是扫描来的，如果是由同一个class文件解析来的，如果两者equals，Spring都认为是兼容的，即Spring会用新的替换之前的。 代理生成入口: ClassPathBeanDefinitionScanner.doScan: 12BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(candidate, beanName);definitionHolder = AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, this.registry); AnnotationConfigUtils.applyScopedProxyMode: 12345678910static BeanDefinitionHolder applyScopedProxyMode( ScopeMetadata metadata, BeanDefinitionHolder definition, BeanDefinitionRegistry registry) &#123; ScopedProxyMode scopedProxyMode = metadata.getScopedProxyMode(); // 基本都是从这里跑了 if (scopedProxyMode.equals(ScopedProxyMode.NO)) &#123; return definition; &#125; boolean proxyTargetClass = scopedProxyMode.equals(ScopedProxyMode.TARGET_CLASS); return ScopedProxyCreator.createScopedProxy(definition, registry, proxyTargetClass);&#125; 最终调用的是ScopedProxyUtils.createScopedProxy，源码很多，这里说下重点: 这里所做的是生成了一个新的BeanDefinition对象，作为代理者，其属性拷贝自被代理者，代理者的beanClass为ScopedProxyFactoryBean，代理者的名字设置为被代理者的名字，而被代理者的名字改为scopedTarget.原名字，代理者内部有一个targetBeanName属性，就是被代理者的名字。 被代理者的autowireCandidate和primary属性被设为false，不能再当作其它bean的注入候选者。 将被代理者以scopedTarget.原名字注册到容器，返回代理者。 代理者和被代理者同时存在于容器中。 可以看出，这其实是一个偷天换日的过程。 做个实验: 12345678public class Boostrap &#123; public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\"); SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class)); System.out.println(bean.getClass().getName()); context.close(); &#125;&#125; SimpleBean已开启代理，输出的结果: 1base.SimpleBean$$EnhancerBySpringCGLIB$$27256c61 那么问题来了，对于以class寻找的方式，必定会找到两个，那么怎么做出选择呢? DefaultListableBeanFactory.getBean(Class requiredType, Object… args)部分源码: 1234567891011121314String[] beanNames = getBeanNamesForType(requiredType);//不止一个满足条件(代理者和被代理者)if (beanNames.length &gt; 1) &#123; ArrayList&lt;String&gt; autowireCandidates = new ArrayList&lt;String&gt;(); for (String beanName : beanNames) &#123; // here if (!containsBeanDefinition(beanName) || getBeanDefinition(beanName).isAutowireCandidate()) &#123; autowireCandidates.add(beanName); &#125; &#125; if (autowireCandidates.size() &gt; 0) &#123; beanNames = autowireCandidates.toArray(new String[autowireCandidates.size()]); &#125;&#125; 可以看出，是上面提到过的autowireCandidate设为了false的缘故导致了被代理者被pass。 BeanDefinition注册你懂的。 Component注册套路和annotation-config-逻辑关系整理一节完全一样，不再赘述。 property-override作用允许我们使用属性文件(.properties)的形式对bean的属性进行替换。下面是一个简单的demo: 定义如下的属性文件(property.properties): 1student.name=dog 格式为: bean名字.属性名字=值。由如下的bean: 1234&lt;bean id=\"student\" class=\"base.Student\"&gt; &lt;property name=\"name\" value=\"skywalker\" /&gt; &lt;property name=\"age\" value=\"30\" /&gt;&lt;/bean&gt; 进行如下的配置: 1&lt;context:property-override location=\"property.properties\" /&gt; 运行如下的代码: 123456public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\"); SimpleBean bean = SimpleBean.class.cast(context.getBean(SimpleBean.class)); System.out.println(bean.getStudent().getName()); context.close();&#125; 打印的便是dog，而不是skywalker。 类图具体的实现类是PropertyOverrideBeanDefinitionParser，其类图如下: 解析解析的原理是将此配置相关的信息保存到BeanDefinition中，更准确的说是一个GenericBeanDefinition。解析的源码: AbstractPropertyLoadingBeanDefinitionParser.doParse: 12345678910111213141516171819202122232425@Overrideprotected void doParse(Element element, BeanDefinitionBuilder builder) &#123; String location = element.getAttribute(\"location\"); if (StringUtils.hasLength(location)) &#123; String[] locations = StringUtils.commaDelimitedListToStringArray(location); builder.addPropertyValue(\"locations\", locations); &#125; String propertiesRef = element.getAttribute(\"properties-ref\"); if (StringUtils.hasLength(propertiesRef)) &#123; builder.addPropertyReference(\"properties\", propertiesRef); &#125; String fileEncoding = element.getAttribute(\"file-encoding\"); if (StringUtils.hasLength(fileEncoding)) &#123; builder.addPropertyValue(\"fileEncoding\", fileEncoding); &#125; String order = element.getAttribute(\"order\"); if (StringUtils.hasLength(order)) &#123; builder.addPropertyValue(\"order\", Integer.valueOf(order)); &#125; builder.addPropertyValue(\"ignoreResourceNotFound\", Boolean.valueOf(element.getAttribute(\"ignore-resource-not-found\"))); builder.addPropertyValue(\"localOverride\", Boolean.valueOf(element.getAttribute(\"local-override\"))); builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);&#125; properties-ref此属性允许我们直接引用一个java.util.Properties类型的bean作为数据源，示例: 123456789&lt;context:property-override properties-ref=\"property\" /&gt; &lt;bean id=\"property\" class=\"java.util.Properties\"&gt; &lt;constructor-arg&gt; &lt;props&gt; &lt;prop key=\"student.name\"&gt;cat&lt;/prop&gt; &lt;/props&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 这样便可以看到结果。 order此属性用以指定其优先级，假设配置了多个context:property-override并且里面有相同的字段，那么将依赖order决定结果。 ignore-resource-not-found如果设为true，那么对于没有找到的属性文件将会忽略，否则会抛出异常，默认为false，抛异常。 ignore-unresolvable如果设为true，那么对于没有找到对应的key将会忽略，否则抛出异常，默认false。 local-override这个属性让我很迷惑。Spring说是此选项决定”local”的属性是否可以覆盖属性文件中的值。正如下面说的，实际上属性文件被解析到了PropertyOverrideConfigurer对象，其父类PropertiesLoaderSupport有一个字段: 12345678910protected Properties[] localProperties;/** * Set local properties, e.g. via the \"props\" tag in XML bean definitions. * These can be considered defaults, to be overridden by properties * loaded from files. */public void setProperties(Properties properties) &#123; this.localProperties = new Properties[] &#123;properties&#125;;&#125; 可以看出，这应该就是Spring所说的”local”属性。好，我们来注入一下: 1234567891011&lt;context:property-override location=\"property.properties\" local-override=\"false\" /&gt;&lt;bean class=\"org.springframework.beans.factory.config.PropertyOverrideConfigurer\"&gt; &lt;property name=\"properties\"&gt; &lt;array&gt; &lt;props&gt; &lt;prop key=\"student.name\"&gt;cat&lt;/prop&gt; &lt;/props&gt; &lt;/array&gt; &lt;/property&gt;&lt;/bean&gt; 然而Spring在注册PropertyOverrideConfigurer的时候根本没有检查容器中是否已经有此类型的BeanDefinition存在，这就导致容器中会同时存在两个!在此种情况下local-override根本没什么卵用，因为后面的PropertyOverrideConfigurer始终会覆盖前一个，local-override是针对一个PropertyOverrideConfigurer来说的，那么问题来了，除此之外如何通过XML向”local”注入?(context:property-override不允许子标签存在) BeanDefinition保存的BeanDefinition的beanClass为PropertyOverrideConfigurer，其类图: 运行入口当然是BeanFactoryPostProcessor.postProcessBeanFactory(PropertyResourceConfigurer): 12345678910111213141516@Overridepublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; try &#123; // 属性加载 Properties mergedProps = mergeProperties(); // Convert the merged properties, if necessary. convertProperties(mergedProps); // Let the subclass process the properties. processProperties(beanFactory, mergedProps); &#125; catch (IOException ex) &#123; throw new BeanInitializationException(\"Could not load properties\", ex); &#125;&#125; 属性加载PropertiesLoaderSupport.mergeProperties: 1234567891011121314151617protected Properties mergeProperties() throws IOException &#123; Properties result = new Properties(); if (this.localOverride) &#123; // Load properties from file upfront, to let local properties override. loadProperties(result); &#125; if (this.localProperties != null) &#123; for (Properties localProp : this.localProperties) &#123; CollectionUtils.mergePropertiesIntoMap(localProp, result); &#125; &#125; if (!this.localOverride) &#123; // Load properties from file afterwards, to let those properties override. loadProperties(result); &#125; return result;&#125; 可以看出，对local-override的支持是通过改变local和文件两者的加载顺序来实现的。 属性转换convertProperties是个空实现，因为这里并不需要，在bean实际生成的时候才会转换。 属性设置就是逐个属性调用PropertyOverrideConfigurer.applyPropertyValue: 1234567891011protected void applyPropertyValue( ConfigurableListableBeanFactory factory, String beanName, String property, String value) &#123; BeanDefinition bd = factory.getBeanDefinition(beanName); while (bd.getOriginatingBeanDefinition() != null) &#123; bd = bd.getOriginatingBeanDefinition(); &#125; PropertyValue pv = new PropertyValue(property, value); pv.setOptional(this.ignoreInvalidKeys); bd.getPropertyValues().addPropertyValue(pv);&#125; addPropertyValue会遍历PropertyValue链表，找到name相同的进行value替换。 property-placeholder这个怎么用已经喜闻乐见了 解析解析的实现类是PropertyPlaceholderBeanDefinitionParser，此类的父类继承体系和property-override的PropertyOverrideBeanDefinitionParser完全一样，所以整体的处理套路也是基本一致。为什么会一致呢，查看此配置拥有的属性就会发现，和property-override很多都是一样的，所以这里只对不一样的而进行说明。 PropertyPlaceholderBeanDefinitionParser.doParse: 123456789101112131415161718192021@Overrideprotected void doParse(Element element, BeanDefinitionBuilder builder) &#123; super.doParse(element, builder); builder.addPropertyValue(\"ignoreUnresolvablePlaceholders\", Boolean.valueOf(element.getAttribute(\"ignore-unresolvable\"))); String systemPropertiesModeName = element.getAttribute(SYSTEM_PROPERTIES_MODE_ATTRIBUTE); if (StringUtils.hasLength(systemPropertiesModeName) &amp;&amp; !systemPropertiesModeName.equals(SYSTEM_PROPERTIES_MODE_DEFAULT)) &#123; builder.addPropertyValue(\"systemPropertiesModeName\", \"SYSTEM_PROPERTIES_MODE_\" + systemPropertiesModeName); &#125; if (element.hasAttribute(\"value-separator\")) &#123; builder.addPropertyValue(\"valueSeparator\", element.getAttribute(\"value-separator\")); &#125; if (element.hasAttribute(\"trim-values\")) &#123; builder.addPropertyValue(\"trimValues\", element.getAttribute(\"trim-values\")); &#125; if (element.hasAttribute(\"null-value\")) &#123; builder.addPropertyValue(\"nullValue\", element.getAttribute(\"null-value\")); &#125;&#125; system-properties-modeSpring会将java的System.getProperties也当做属性的来源，此配置用于设置系统的和本地文件的同名属性的覆盖方式(谁覆盖谁)，自己看文档去。 value-separator用于配置默认的值的分隔符: 123&lt;bean id=\"student\" class=\"base.Student\"&gt; &lt;property name=\"name\" value=\"$&#123;student.name:skywalker&#125;\" /&gt;&lt;/bean&gt; 如果属性文件里没有student.name，那么就是skywalker。默认就是:。 null-value遇到哪些值应该当做空处理，比如可以把空串””设为这个，默认不对任何值进行处理。 trim-values是否移除开头和结尾的空格，按理说应该是布尔值，但是Spring没有提供可以选择的值，经过测试发现设为true或是false都会把空格干掉，不知道什么鬼。 BeanDefinition这次是PropertySourcesPlaceholderConfigurer，其类图: 运行PropertySourcesPlaceholderConfigurer.postProcessBeanFactory： 123456789101112131415161718192021222324252627@Overridepublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; if (this.propertySources == null) &#123; this.propertySources = new MutablePropertySources(); if (this.environment != null) &#123; this.propertySources.addLast( new PropertySource&lt;Environment&gt;(ENVIRONMENT_PROPERTIES_PROPERTY_SOURCE_NAME, this.environment) &#123; @Override public String getProperty(String key) &#123; return this.source.getProperty(key); &#125; &#125; ); &#125; PropertySource&lt;?&gt; localPropertySource = new PropertiesPropertySource(LOCAL_PROPERTIES_PROPERTY_SOURCE_NAME, mergeProperties()); if (this.localOverride) &#123; this.propertySources.addFirst(localPropertySource); &#125; else &#123; this.propertySources.addLast(localPropertySource); &#125; &#125; processProperties(beanFactory, new PropertySourcesPropertyResolver(this.propertySources)); this.appliedPropertySources = this.propertySources;&#125; 从源码中可以看出，如果其内部的propertySources属性不为空(当然默认是空)，那么属性文件和系统属性都会被忽略。它的使用场景应该是这样: 不使用property-placeholder标签，以显式的bean定义代替。 处理处理的过程就是遍历全部BeanDefinition，替换${}，不再详细进行详细说明。 load-time-weaver &amp; spring-configured这两个配置是紧密相关的，所以在一起说了。 load-time-weaver用以开启aspectj类加载期织入，实际上是利用jdk1.6提供的instrument API实现的，原理就是jvm会在类加载之前将class暴露给我们制定的类，允许我们在此时对类进行修改。aspectj便利用此机会根据我们的配置生成对应的满足需求的子类。 可以参考: Spring之LoadTimeWeaver——一个需求引发的思考 Spring LoadTimeWeaver 的那些事儿 javaagent要想使用此功能需要配置jvm参数javaagent指定代理类的jar包，示例: -javaagent:D:\\Software\\maven-repos\\org\\springframework\\spring-agent\\2.5.6.SEC03\\spring-agent-2.5.6.SEC03.jar 此jar包的META-INF/MANIFEST.MF文件需要配置如下一行: Premain-Class: org.springframework.instrument.InstrumentationSavingAge nt Spring的这个jar包只有这一个类，premain方法便是jvm调用的入口，方法参数是固定的。源码: 123456789101112public class InstrumentationSavingAgent &#123; private static volatile Instrumentation instrumentation; public static void premain(String agentArgs, Instrumentation inst) &#123; instrumentation = inst; &#125; public static Instrumentation getInstrumentation() &#123; return instrumentation; &#125;&#125; 所以，Spring在这里把Instrumentation给暴露了出来，供其它的类使用。 解析解析的实现类是LoadTimeWeaverBeanDefinitionParser，其继承体系和property-override的PropertyOverrideBeanDefinitionParser类似。 LoadTimeWeaver此接口用于向ClassLoader添加ClassFileTransformer对象，其继承体系: LoadTimeWeaverBeanDefinitionParser的父类初始化了一个DefaultContextLoadTimeWeaver类型的BeanDefinition放入容器，类型的决定位于LoadTimeWeaverBeanDefinitionParser.getBeanClassName: 123456789@Overrideprotected String getBeanClassName(Element element) &#123; // 如果配置了weaver-class属性，那么使用其值 if (element.hasAttribute(WEAVER_CLASS_ATTRIBUTE)) &#123; return element.getAttribute(WEAVER_CLASS_ATTRIBUTE); &#125; // org.springframework.context.weaving.DefaultContextLoadTimeWeaver return DEFAULT_LOAD_TIME_WEAVER_CLASS_NAME;&#125; 那么这个BeanDefinition的id/name又是什么呢? LoadTimeWeaverBeanDefinitionParser.resolveId: 12345@Overrideprotected String resolveId(Element element, AbstractBeanDefinition definition, ParserContext parserContext) &#123; // loadTimeWeaver return ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME;&#125; DefaultContextLoadTimeWeaver其实是个包装类，包装了真正的LoadTimeWeaver，使用这层包装的目的就是可以根据外部环境(服务器代理或是Spring自己的代理)确定内部LoadTimeWeaver的实现，具体参见后面运行-BeanClassLoaderAware-setBeanClassLoadery一节。 LoadTimeWeaverBeanDefinitionParserLoadTimeWeaverBeanDefinitionParser.doParse: 1234567891011121314@Overrideprotected void doParse(Element element, ParserContext parserContext, BeanDefinitionBuilder builder) &#123; builder.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); if (isAspectJWeavingEnabled(element.getAttribute(ASPECTJ_WEAVING_ATTRIBUTE), parserContext)) &#123; if (!parserContext.getRegistry().containsBeanDefinition(ASPECTJ_WEAVING_ENABLER_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(ASPECTJ_WEAVING_ENABLER_CLASS_NAME); parserContext.registerBeanComponent( new BeanComponentDefinition(def, ASPECTJ_WEAVING_ENABLER_BEAN_NAME)); &#125; if (isBeanConfigurerAspectEnabled(parserContext.getReaderContext().getBeanClassLoader())) &#123; new SpringConfiguredBeanDefinitionParser().parse(element, parserContext); &#125; &#125;&#125; aspectj-weaving这里便是加载其织入的开关，共有三个选项: on, off, autodect。前两个自不必说，autodect表示自动去检测/META-INF下是否存在aop.xml，如果有，那么开启。 此功能依赖于spring-aspectj包，此jar包下有aop.xml，所以autodect也是开启的。 是否开启isAspectJWeavingEnabled方法用于判断是否启用: 1234567891011protected boolean isAspectJWeavingEnabled(String value, ParserContext parserContext) &#123; if (\"on\".equals(value)) &#123; return true; &#125; else if (\"off\".equals(value)) &#123; return false; &#125; else &#123; // 寻找aop.xml ClassLoader cl = parserContext.getReaderContext().getResourceLoader().getClassLoader(); return (cl.getResource(AspectJWeavingEnabler.ASPECTJ_AOP_XML_RESOURCE) != null); &#125;&#125; AspectJWeavingEnabler从源码中可以看出，Spring向容器放了一个这东西，名字叫org.springframework.context.config.internalAspectJWeavingEnabler。这东西用来向LoadTimeWeaver设置aspectj的ClassPreProcessorAgentAdapter对象。其类图: SpringConfiguredBeanDefinitionParser如果isBeanConfigurerAspectEnabled方法返回true，那么将会生成一个此对象并调用其parse方法，查看ContextNamespaceHandler的init方法源码可以发现，spring-configured对应的解析器其实就是它: 1registerBeanDefinitionParser(\"spring-configured\", new SpringConfiguredBeanDefinitionParser()); 其parse方法: 123456789101112131415@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; // org.springframework.context.config.internalBeanConfigurerAspect if (!parserContext.getRegistry().containsBeanDefinition(BEAN_CONFIGURER_ASPECT_BEAN_NAME)) &#123; RootBeanDefinition def = new RootBeanDefinition(); // org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect def.setBeanClassName(BEAN_CONFIGURER_ASPECT_CLASS_NAME); def.setFactoryMethodName(\"aspectOf\"); def.setRole(BeanDefinition.ROLE_INFRASTRUCTURE); def.setSource(parserContext.extractSource(element)); parserContext.registerBeanComponent(new BeanComponentDefinition (def, BEAN_CONFIGURER_ASPECT_BEAN_NAME)); &#125; return null;&#125; 很明显，把org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect添加到容器里了，这其实是一个切面，其类图: AnnotationBeanConfigurerAspect及其父类其实是由aspectj源文件(.aj)编译而来，所以在spring-aspectj的源码包中看到的是.aj文件而不是.java。 下面就去aj文件中看看到底定义了哪些pointcut以及advise。 语法可以参考: Spring 之AOP AspectJ切入点详解 切点(pointcut)inConfigurableBean在AnnotationBeanConfigurerAspect中定义，源码: 1public pointcut inConfigurableBean() : @this(Configurable); @this没找到相关说明，结合@以及this的语义，猜测是匹配带有@Configurable注解(以及作为元注解)的类。 beanConstruction源码: 12public pointcut beanConstruction(Object bean) : initialization(ConfigurableObject+.new(..)) &amp;&amp; this(bean); initialization表示匹配构造器的调用，ConfigurableObject+表示ConfigurableObject及其子类，这就说明可以用实现ConfigurableObject接口的方式代替@Configurable注解。this(bean)表示this必须满足this instanceof bean，也就是说被代理的对象必须是bean的子类。 preConstructionCondition12private pointcut preConstructionCondition() : leastSpecificSuperTypeConstruction() &amp;&amp; preConstructionConfiguration(); 由两个pointcut与运算而来。 leastSpecificSuperTypeConstruction1public pointcut leastSpecificSuperTypeConstruction() : initialization(ConfigurableObject.new(..)); preConstructionConfiguration12public pointcut preConstructionConfiguration() : preConstructionConfigurationSupport(*);private pointcut preConstructionConfigurationSupport(Configurable c) : @this(c) &amp;&amp; if (c.preConstruction()); preConstruction表示@Configurable注解的preConstruction属性，此属性表示是否注入操作可以发生在构造之前，默认false。 postConstructionCondition12private pointcut postConstructionCondition() : mostSpecificSubTypeConstruction() &amp;&amp; !preConstructionConfiguration(); mostSpecificSubTypeConstruction: 12public pointcut mostSpecificSubTypeConstruction() : if (thisJoinPoint.getSignature().getDeclaringType() == thisJoinPoint.getThis().getClass()); advise可以声明JoinPoint类型的方法参数，thisJoinpoint指的就是这个。此pointcut的目的是匹配接口/抽象类的最具体的实现。 advise前置1234before(Object bean) : beanConstruction(bean) &amp;&amp; preConstructionCondition() &amp;&amp; inConfigurableBean() &#123; configureBean(bean);&#125; 运行AspectJWeavingEnabler.postProcessBeanFactory: 1234@Overridepublic void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException &#123; enableAspectJWeaving(this.loadTimeWeaver, this.beanClassLoader);&#125; enableAspectJWeaving: 12345678910111213public static void enableAspectJWeaving(LoadTimeWeaver weaverToUse, ClassLoader beanClassLoader) &#123; // 不为空 if (weaverToUse == null) &#123; if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123; weaverToUse = new InstrumentationLoadTimeWeaver(beanClassLoader); &#125; else &#123; throw new IllegalStateException(\"No LoadTimeWeaver available\"); &#125; &#125; weaverToUse.addTransformer( new AspectJClassBypassingClassFileTransformer(new ClassPreProcessorAgentAdapter()));&#125; LoadTimeWeaverAwareAspectJWeavingEnabler实现了LoadTimeWeaverAware接口，那么何时由谁进行注入的呢? 当Context初始化时，AbstractApplicationContext.prepareBeanFactory部分源码: 123456// loadTimeWeaverif (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));&#125; 很明显，关键在于LoadTimeWeaverAwareProcessor，类图: postProcessBeforeInitialization方法: 123456789101112131415@Overridepublic Object postProcessBeforeInitialization(Object bean, String beanName) &#123; if (bean instanceof LoadTimeWeaverAware) &#123; LoadTimeWeaver ltw = this.loadTimeWeaver; if (ltw == null) &#123; Assert.state(this.beanFactory != null, \"BeanFactory required if no LoadTimeWeaver explicitly specified\"); // 去容器找 ltw = this.beanFactory.getBean( ConfigurableApplicationContext.LOAD_TIME_WEAVER_BEAN_NAME, LoadTimeWeaver.class); &#125; ((LoadTimeWeaverAware) bean).setLoadTimeWeaver(ltw); &#125; return bean;&#125; 可以看出，如果本地的loadTimeWeaver为空，那么会去容器找，调用了getBean方法，也就是说DefaultContextLoadTimeWeaver就是在这里初始化的。 BeanFactoryPostProcessor也是一个bean，所以它的初始化也会BeanPostProcessor的处理。不过注意一点: BeanPostProcessor的注册是在BeanFactoryPostProcessor的调用之后进行的: AbstractApplicationContext.refresh: 1234// Invoke factory processors registered as beans in the context.invokeBeanFactoryPostProcessors(beanFactory);// Register bean processors that intercept bean creation.registerBeanPostProcessors(beanFactory); 那么BeanFactoryPostProcessor初始化的时候执行处理的BeanPostProcessor是哪里来的? AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization源码: 1234567891011@Overridepublic Object applyBeanPostProcessorsBeforeInitialization(Object existingBean, String beanName) &#123; Object result = existingBean; for (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123; result = beanProcessor.postProcessBeforeInitialization(result, beanName); if (result == null) &#123; return result; &#125; &#125; return result;&#125; getBeanPostProcessors: 123public List&lt;BeanPostProcessor&gt; getBeanPostProcessors() &#123; return this.beanPostProcessors;&#125; 可以看出，并没有查找容器的过程，所以此处并不会导致BeanPostProcessor的初始化。问题的关键就在于LoadTimeWeaverAwareProcessor的添加方式: 1beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); 直接将实例添加到BeanFactory中，所以可以得出结论: 我们自定义的BeanPostProcessor不会对BeanFactoryPostProcessor的初始化造成影响，除非使用调用BeanFactory.addBeanPostProcessor的方式进行添加。 BeanClassLoaderAware入口DefaultContextLoadTimeWeaver同样实现了此接口，那么哪里调用的呢? AbstractAutowireCapableBeanFactory.initializeBean调用了invokeAwareMethods方法，源码: 12345678910111213private void invokeAwareMethods(final String beanName, final Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof BeanNameAware) &#123; ((BeanNameAware) bean).setBeanName(beanName); &#125; if (bean instanceof BeanClassLoaderAware) &#123; ((BeanClassLoaderAware) bean).setBeanClassLoader(getBeanClassLoader()); &#125; if (bean instanceof BeanFactoryAware) &#123; ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.this); &#125; &#125;&#125; setBeanClassLoader这个方法很关键，对instrument的获取就是在这里。源码: 1234567891011@Overridepublic void setBeanClassLoader(ClassLoader classLoader) &#123; LoadTimeWeaver serverSpecificLoadTimeWeaver = createServerSpecificLoadTimeWeaver(classLoader); if (serverSpecificLoadTimeWeaver != null) &#123; this.loadTimeWeaver = serverSpecificLoadTimeWeaver; &#125; else if (InstrumentationLoadTimeWeaver.isInstrumentationAvailable()) &#123; this.loadTimeWeaver = new InstrumentationLoadTimeWeaver(classLoader); &#125; else &#123; this.loadTimeWeaver = new ReflectiveLoadTimeWeaver(classLoader); &#125;&#125; 很明显分为三部分。 服务器agentSpring首先会去检测是否存在服务器的agent代理。按照Spring doc里说的，支持下列服务器: 12&gt; Oracle WebLogic 10,GlassFish 3, Tomcat 6, 7 and 8, JBoss AS 5, 6 and 7, IBM WebSphere 7 and 8.&gt; createServerSpecificLoadTimeWeaver源码: 123456789101112131415protected LoadTimeWeaver createServerSpecificLoadTimeWeaver(ClassLoader classLoader) &#123; String name = classLoader.getClass().getName(); if (name.startsWith(\"weblogic\")) &#123; return new WebLogicLoadTimeWeaver(classLoader); &#125; else if (name.startsWith(\"org.glassfish\")) &#123; return new GlassFishLoadTimeWeaver(classLoader); &#125; else if (name.startsWith(\"org.apache.catalina\")) &#123; return new TomcatLoadTimeWeaver(classLoader); &#125; else if (name.startsWith(\"org.jboss\")) &#123; return new JBossLoadTimeWeaver(classLoader); &#125; else if (name.startsWith(\"com.ibm\")) &#123; return new WebSphereLoadTimeWeaver(classLoader); &#125; return null;&#125; 可以看出，对于服务器的判断是通过检测当前的类加载器来实现的，因为这些服务器都使用了自己的类加载器实现。 这也从侧面说明，如果当前处于以上服务器所在的web应用环境，不需要spring-agent.jar便可以实现LTW(载入期织入)。 Spring agent这个也是测试时使用的。InstrumentationLoadTimeWeaver.isInstrumentationAvailable： 1234567891011public static boolean isInstrumentationAvailable() &#123; return (getInstrumentation() != null);&#125;private static Instrumentation getInstrumentation() &#123; if (AGENT_CLASS_PRESENT) &#123; return InstrumentationAccessor.getInstrumentation(); &#125; else &#123; return null; &#125;&#125; AGENT_CLASS_PRESENT是一个布尔变量，就是判断org.springframework.instrument.InstrumentationSavingAgent是否存在，这个便是spring-agent.jar中唯一的类。 InstrumentationAccessor是InstrumentationLoadTimeWeaver的内部类: 12345private static class InstrumentationAccessor &#123; public static Instrumentation getInstrumentation() &#123; return InstrumentationSavingAgent.getInstrumentation(); &#125;&#125; 这里便是获取spring-agent.jar暴露的Instrumentation对象的地方了。 反射在这种情况中，Spring寄托于当前的ClassLoader实现了LoadTimeWeaver的功能，也就是必须有addTransformer方法，如果有，Spring便会把LoadTimeWeaver的职责委托给ClassLoader，如果没有只能抛异常了(抱歉，我们没法支持LTW…)，检测的源码位于ReflectiveLoadTimeWeaver的构造器: 12345678910111213public ReflectiveLoadTimeWeaver() &#123; this(ClassUtils.getDefaultClassLoader());&#125;public ReflectiveLoadTimeWeaver(ClassLoader classLoader) &#123; Assert.notNull(classLoader, \"ClassLoader must not be null\"); this.classLoader = classLoader; this.addTransformerMethod = ClassUtils.getMethodIfAvailable( this.classLoader.getClass(), ADD_TRANSFORMER_METHOD_NAME, ClassFileTransformer.class); if (this.addTransformerMethod == null) &#123; throw new IllegalStateException(); &#125;&#125; 总结其实可以不用Spring，只使用aspectj自己便可以实现LTW，只需要把代理jar包设为aspect-weaver.jar，并自己编写aop.xml文件以及相应的aspect类即可。可以参考官方文档: Chapter 5. Load-Time Weaving ClassFileTransformer从enableAspectJWeaving方法的源码可以看出，实际上就是向DefaultContextLoadTimeWeaver添加了一个AspectJClassBypassingClassFileTransformer对象。根据java instrument API的定义，每当一个Class被加载的时候都会去调用挂在Instrumentation上的ClassFileTransformer的transform方法。所以LTW的核心便在这里了。 AspectJClassBypassingClassFileTransformer.transform: 12345678910@Overridepublic byte[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) &#123; // aspectj自身的类无需检测(织入)，直接跳过 if (className.startsWith(\"org.aspectj\") || className.startsWith(\"org/aspectj\")) &#123; return classfileBuffer; &#125; return this.delegate.transform(loader, className, classBeingRedefined, protectionDomain, classfileBuffer);&#125; delegate是一个org.aspectj.weaver.loadtime.ClassPreProcessorAgentAdapter对象。这是一个适配器模式，其类图: 根据Aspectj的doc，ClassPreProcessor用于将Aspectj 5对于jdk5依赖代码抽取出来以便可以支持jdk1.3/1.4. AjAj的preProcess方法很长，其实只干了两件事，都是围绕着WeavingAdaptor进行的。对类的处理也转交给WeavingAdaptor的weaveClass方法。 缓存Aj使用了WeavingAdaptor缓存机制，确保一个ClassLoader只有一个WeavingAdaptor对象，因为其初始化的成本很高，缓存利用一个key为AdaptorKey(包装了ClassLoader), value为WeavingAdaptor的HashMap来实现。 WeavingAdaptor初始化初始化就是ClassLoaderWeavingAdaptor.initialize方法，初始化分部分来进行说明。Aspectj部分不再详细展开，只对关键的部分进行说明。 aop.xml解析aop.xml的解析便是在这里进行。解析的过程无非是xml的解析，下面是其结果如何存储的: 以org.aspectj.weaver.loadtime.definition.Definition为载体，我们以spring-aspects.jar下的aop.xml为例: 12345678910&lt;aspectj&gt; &lt;aspects&gt; &lt;aspect name=\"org.springframework.beans.factory.aspectj.AnnotationBeanConfigurerAspect\"/&gt; &lt;aspect name=\"org.springframework.scheduling.aspectj.AnnotationAsyncExecutionAspect\"/&gt; &lt;aspect name=\"org.springframework.transaction.aspectj.AnnotationTransactionAspect\"/&gt; &lt;aspect name=\"org.springframework.transaction.aspectj.JtaAnnotationTransactionAspect\"/&gt; &lt;aspect name=\"org.springframework.cache.aspectj.AnnotationCacheAspect\"/&gt; &lt;aspect name=\"org.springframework.cache.aspectj.JCacheCacheAspect\"/&gt; &lt;/aspects&gt;&lt;/aspectj&gt; 那么解析后的结果: 注册入口方法在ClassLoaderWeavingAdaptor.registerDefinitions: 1234567891011121314private boolean registerDefinitions(final BcelWeaver weaver, final ClassLoader loader, List&lt;Definition&gt; definitions) &#123; //对应&lt;weaver options=\"-verbose\"&gt; registerOptions(weaver, loader, definitions); //对应&lt;exclude&gt;标签 registerAspectExclude(weaver, loader, definitions); //对应&lt;include&gt;标签 registerAspectInclude(weaver, loader, definitions); // &lt;aspect&gt; success = registerAspects(weaver, loader, definitions); registerIncludeExclude(weaver, loader, definitions); //对应&lt;dump&gt;标签 registerDump(weaver, loader, definitions); //忽略返回&#125; 总结Spring将切面以编译过的Aspectj语言形式定义，不过也可以用原生java类。spring-aspectj包定义的是供各个模块进行LTW的切面。Aspectj部分不再继续向下深入探究。 申明本文转载自seaswalker的github，转载授权，由我在万达摆地摊整理发布。","categories":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/tags/spring/"}]},{"title":"spring aop源码分析","slug":"spring-aop源码分析","date":"2018-06-06T04:08:31.000Z","updated":"2018-10-05T09:23:31.980Z","comments":true,"path":"posts/46171/","link":"","permalink":"https://satra.tk/posts/46171/","excerpt":"开头aop部分的解析器由AopNamespaceHandler注册，其init方法: 123456@Overridepublic void init() &#123; registerBeanDefinitionParser(\"config\", new ConfigBeanDefinitionParser()); registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(\"scoped-proxy\", new ScopedProxyBeanDefinitionDecorator());&#125;","text":"开头aop部分的解析器由AopNamespaceHandler注册，其init方法: 123456@Overridepublic void init() &#123; registerBeanDefinitionParser(\"config\", new ConfigBeanDefinitionParser()); registerBeanDefinitionParser(\"aspectj-autoproxy\", new AspectJAutoProxyBeanDefinitionParser()); registerBeanDefinitionDecorator(\"scoped-proxy\", new ScopedProxyBeanDefinitionDecorator());&#125; aop:config此标签用以配置pointcut, advisor, aspect，实例: 12345&lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* exam.service..*.*(..))\" id=\"transaction\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"transaction\"/&gt; &lt;aop:aspect ref=\"\" /&gt;&lt;/aop:config&gt; ConfigBeanDefinitionParser.parse: 12345678910111213141516171819202122@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; CompositeComponentDefinition compositeDef = new CompositeComponentDefinition(element.getTagName(), parserContext.extractSource(element)); parserContext.pushContainingComponent(compositeDef); // 是否生成代理类 configureAutoProxyCreator(parserContext, element); List&lt;Element&gt; childElts = DomUtils.getChildElements(element); for (Element elt: childElts) &#123; String localName = parserContext.getDelegate().getLocalName(elt); if (POINTCUT.equals(localName)) &#123; parsePointcut(elt, parserContext); &#125; else if (ADVISOR.equals(localName)) &#123; parseAdvisor(elt, parserContext); &#125; else if (ASPECT.equals(localName)) &#123; parseAspect(elt, parserContext); &#125; &#125; parserContext.popAndRegisterContainingComponent(); return null;&#125; 解析解析的过程主要分为以下几个部分。 proxy-target-class &amp; expose-proxy对应着aop:config的两个属性，前者代表是否为被代理这生成CGLIB子类，默认false，只为接口生成代理子类(话说如果不生成子类那么怎么拦截?)。后者代表是否将代理bean暴露给用户，如果暴露，可以通过Spring AopContext类获得，默认不暴露。 解析的过程无非就是属性的读取，不再详细说明。 aop:pointcutpointcut的解析是一个生成一个BeanDefinition并将其id, expression等属性保存在BeanDefinition中。注意以下几点: BeanDefinition的ID来自于id属性，如果没有，那么自动生成。 BeanDefinition的class是AspectJExpressionPointcut。 BeanDefinition的scope为prototype。 AspectJExpressionPointcut类图: aop:advisor首先是其所有属性的示例: 1&lt;aop:advisor id=\"\" order=\"\" advice-ref=\"aopAdvice\" pointcut=\"\" pointcut-ref=\"\" /&gt; advisor概念是Spring独有的，来自于上古时代，应该是较早时候的aop概念的实现: AOP Alliance (Java/J2EE AOP standards)。Spring官方的说法: aop-schema-advisors。 其相关的包/类就在spring-aop下: advice-ref是必须的属性，并且这里的advice必须实现org.aopalliance.aop.Advice的子接口。这些子接口指的什么呢，见Spring官方文档: aop-api-advice-types。比如org.aopalliance.intercept.MethodInterceptor。 最常见的用途就是结合事务使用: 123456789101112&lt;tx:advice id=\"txAdvice\" transaction-manager=\"transactionManager\"&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"get*\" read-only=\"true\" propagation=\"NOT_SUPPORTED\"/&gt; &lt;tx:method name=\"find*\" read-only=\"true\" propagation=\"NOT_SUPPORTED\"/&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\"/&gt; &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;aop:config&gt; &lt;aop:pointcut expression=\"execution(* exam.service..*.*(..))\" id=\"transaction\"/&gt; &lt;aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"transaction\"/&gt;&lt;/aop:config&gt; 解析的套路和楼上类似，只不过此处的beanClass是DefaultBeanFactoryPointcutAdvisor，其类图: 另外注意对于pointcut和pointcut-ref两者处理的区别，对于pointcut属性，Spring会同样创建一个AspectJExpressionPointcut类型的BeanDefinition，对于pointcut-ref会生成一个RuntimeBeanReference对象指向原pointcut的引用。此类的类图: 可以看出，这种aop的实现需要实现各种接口，所以不应该再使用此种方式进行aop，除了Spring内部的实现。 aop:aspect配置举例: 12345678910&lt;bean id=\"aopAdvice\" class=\"base.aop.AopDemoAdvice\" /&gt;&lt;!-- 必须配置，因为被代理的对象必须在Spring容器中 --&gt;&lt;bean id=\"aopDemo\" class=\"base.aop.AopDemo\" /&gt;&lt;aop:config&gt; &lt;aop:pointcut id=\"pointcut\" expression=\"execution(* base.aop.AopDemo.send())\" /&gt; &lt;aop:aspect ref=\"aopAdvice\"&gt; &lt;aop:before method=\"beforeSend\" pointcut-ref=\"pointcut\" /&gt; &lt;aop:after method=\"afterSend\" pointcut-ref=\"pointcut\" /&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 解析形成的BeanDefinition结构如下: 1234567891011121314151617181920212223242526272829AspectComponentDefinition beanRefArray RuntimeBeanReference(aop:aspect的ref属性) beanDefArray // 被注册 RootBeanDefinition(aop:declare-parents) beanClass: DeclareParentsAdvisor ConstructorArg implement-interface types-matching default-impl delegate-ref // 被注册 RootBeanDefinition(aop:before,aop:after...) beanClass: AspectJPointcutAdvisor ConstructorArg RootBeanDefinition beanClass: 由子标签决定 ConstructorArg RootBeanDefinition beanClass: MethodLocatingFactoryBean properties targetBeanName: aspectName methodName: method属性 RootBeanDefinition beanClass: SimpleBeanFactoryAwareAspectInstanceFactory properties aspectBeanName: aspectName //还有pointcut定义和引用... 结构图里面的aspectName来自于aop:aspect的ref属性，此属性是必须配置的，因为Spring要知道aop:before等标签指定的方法是哪个bean/类/对象的方法。 aop:declare-parents对于aop:declare-parents子标签，其决定的是代理子类应该实现哪些接口: 1&lt;aop:declare-parents types-matching=\"\" implement-interface=\"\" /&gt; 此标签最终被解析成为beanClass为DeclareParentsAdvisor的BeanDefinition，并注册到容器中。其类图: 其它此处的其它指的是aop:before, aop:after等最核心的标签。其最终被解析为beanClass为AspectJPointcutAdvisor的BeanDefinition，类图: 正如上面结构图里所描述的，其构造参数为一个BeanDefintion，此对象的beanClass是不确定的，由aop:before/after中的before和after决定，代码: 1234567891011121314private Class&lt;?&gt; getAdviceClass(Element adviceElement, ParserContext parserContext) &#123; String elementName = parserContext.getDelegate().getLocalName(adviceElement); if (BEFORE.equals(elementName)) &#123; return AspectJMethodBeforeAdvice.class; &#125; else if (AFTER.equals(elementName)) &#123; return AspectJAfterAdvice.class; &#125; else if (AFTER_RETURNING_ELEMENT.equals(elementName)) &#123; return AspectJAfterReturningAdvice.class; &#125; else if (AFTER_THROWING_ELEMENT.equals(elementName)) &#123; return AspectJAfterThrowingAdvice.class; &#125; else if (AROUND.equals(elementName)) &#123; return AspectJAroundAdvice.class; &#125;&#125; 而此BeanDefintion的构造参数又由以下三个部分组成: MethodLocatingFactoryBean第一个便是beanClass为此类型的BeanDefinition。其内部有一个methodName属性，存储的便是标签的method属性的值。其类图: 这个东西是干什么用的呢?其实是用于在指定的advice(aop:aspect的ref属性)中得到Method对象。入口在setBeanFactory方法: 12345@Overridepublic void setBeanFactory(BeanFactory beanFactory) &#123; Class&lt;?&gt; beanClass = beanFactory.getType(this.targetBeanName); this.method = BeanUtils.resolveSignature(this.methodName, beanClass);&#125; SimpleBeanFactoryAwareAspectInstanceFactory其类图: 此类用于在BeanFactory中定位aspect bean，这个bean指的是谁? 1&lt;bean id=\"aopAdvice\" class=\"base.aop.AopDemoAdvice\" /&gt; 就是它!查找很简单: 1234@Overridepublic Object getAspectInstance() &#123; return this.beanFactory.getBean(this.aspectBeanName);&#125; 总结从整个aop:aspect标签最终被解析为一个AspectJPointcutAdvisor来看，Spring在实现上仍将其作为Advisor的概念。 代理子类生成关键在于AspectJAwareAdvisorAutoProxyCreator，此对象在ConfigBeanDefinitionParser的configureAutoProxyCreator方法中注册，其类图: 那么子类生成的入口在哪里呢? 入口从AspectJAwareAdvisorAutoProxyCreator的类图中可以看出，此类实现了SmartInstantiationAwareBeanPostProcessor接口，所以很容易想到入口应该位于此接口及其父接口(BeanPostProcessor)的相关方法中。实际上确实是这样的。 postProcessBeforeInstantiation调用时机先来回顾一下此方法在Bean创建的过程中的调用时机。 AbstractAutowireCapableBeanFactory.createBean部分源码: 123456//// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.Object bean = resolveBeforeInstantiation(beanName, mbdToUse);if (bean != null) &#123; return bean;&#125;Object beanInstance = doCreateBean(beanName, mbdToUse, args); 可以看出，调用发生在Bean实例的创建之前。 源码AbstractAutoProxyCreator.postProcessBeforeInstantiation: 12345678910111213141516171819202122232425@Overridepublic Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) &#123; Object cacheKey = getCacheKey(beanClass, beanName); if (beanName == null || !this.targetSourcedBeans.contains(beanName)) &#123; if (this.advisedBeans.containsKey(cacheKey)) &#123; return null; &#125; if (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return null; &#125; &#125; if (beanName != null) &#123; TargetSource targetSource = getCustomTargetSource(beanClass, beanName); if (targetSource != null) &#123; this.targetSourcedBeans.add(beanName); Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource); Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; &#125; return null;&#125; 下面分部分对其进行说明。 应该代理 ?Spring首先会对当前的beanClass进行检查(是否应该/可以对其进行代理)。 不应该代理的类分为两种情况: 用于实现AOP的Spring基础类，此种情况在isInfrastructureClass方法中完成检测(单词Infrastructure正是基础设施的意思)。 子类定义的应该跳过的类，默认AbstractAutoProxyCreator的实现直接返回false，即都不应该跳过。 基础类检测AbstractAutoProxyCreator.isInfrastructureClass: 1234567protected boolean isInfrastructureClass(Class&lt;?&gt; beanClass) &#123; boolean retVal = Advice.class.isAssignableFrom(beanClass) || Pointcut.class.isAssignableFrom(beanClass) || Advisor.class.isAssignableFrom(beanClass) || AopInfrastructureBean.class.isAssignableFrom(beanClass); return retVal;&#125; 可以看出，任何Advice、Pointcut、Advisor、AopInfrastructureBean的子类都被当做Spring实现AOP的基础设施类。 跳过类检测即shouldSkip方法。前面提到了，AbstractAutoProxyCreator的默认实现直接返回fasle，这一特性被子类AspectJAwareAdvisorAutoProxyCreator重写: 123456789101112@Overrideprotected boolean shouldSkip(Class&lt;?&gt; beanClass, String beanName) &#123; List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); for (Advisor advisor : candidateAdvisors) &#123; if (advisor instanceof AspectJPointcutAdvisor) &#123; if (((AbstractAspectJAdvice) advisor.getAdvice()).getAspectName().equals(beanName)) &#123; return true; &#125; &#125; &#125; return super.shouldSkip(beanClass, beanName);&#125; 那么此方法跳过的是谁呢？ 其实就是我们通过aop:aspect标签配置的切面，即: 12345&lt;bean id=\"aopAdvice\" class=\"base.aop.AopDemoAdvice\" /&gt;&lt;aop:config&gt; &lt;aop:aspect ref=\"aopAdvice\"&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 里的aopAdvice。 从前面的aop:aspect一节中可以知道，Spring对于aop:config的解析其实是把aop:before/after等标签解析成为了AspectJPointcutAdvisor类型的BeanDefinition，而aopAdvice以AbstractAspectJAdvice的类型保存在其中。 所以可以得出结论: Spring跳过的是适用于当前bean的Advisor的Advice/Aspect对象。 AOP逻辑 那么Spring又是如何找到适用于当前bean的Advisor的呢? Advisor寻找关键便是findCandidateAdvisors方法，此方法将逻辑委托给BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans: 12345678910111213141516171819202122232425public List&lt;Advisor&gt; findAdvisorBeans() &#123; String[] advisorNames = null; synchronized (this) &#123; // 结果缓存 advisorNames = this.cachedAdvisorBeanNames; if (advisorNames == null) &#123; // 去容器中寻找 advisorNames = BeanFactoryUtils.beanNamesForTypeIncludingAncestors( this.beanFactory, Advisor.class, true, false); this.cachedAdvisorBeanNames = advisorNames; &#125; &#125; if (advisorNames.length == 0) &#123; return new LinkedList&lt;Advisor&gt;(); &#125; List&lt;Advisor&gt; advisors = new LinkedList&lt;Advisor&gt;(); for (String name : advisorNames) &#123; if (isEligibleBean(name)) &#123; if (!this.beanFactory.isCurrentlyInCreation(name)) &#123; advisors.add(this.beanFactory.getBean(name, Advisor.class)); &#125; &#125; &#125; return advisors;&#125; 可以看出，首先是从容器中获取到所有的Advisor示例，然后调用isEligibleBean方法逐一判断Advisor是否适用于当前bean。 适用性检测指的便是isEligibleBean方法。最终调用的是AbstractAdvisorAutoProxyCreator的同名方法: 123protected boolean isEligibleAdvisorBean(String beanName) &#123; return true;&#125; 而AbstractAdvisorAutoProxyCreator的子类AspectJAwareAdvisorAutoProxyCreator并没有覆盖此方法，所以此处会对容器中所有的Advisor的Advice进行跳过。 检测结果缓存因为postProcessBeforeInstantiation方法会在每个bean初始化之前被调用，所以没有必要每次都真的进行基础类检测和跳过类检测，Spring使用了advisedBeans作为缓存用以提高性能。 TargetSource从源码中可以看出，对于自定义的TargetSource，Spring会立即执行代理子类的创建。Spring的代理其实是针对TargetSource的，其类图: 关于此接口在此不展开叙述。 postProcessAfterInitializationAbstractAutoProxyCreator.postProcessAfterInitialization: 12345678910@Overridepublic Object postProcessAfterInitialization(Object bean, String beanName) &#123; if (bean != null) &#123; Object cacheKey = getCacheKey(bean.getClass(), beanName); if (!this.earlyProxyReferences.contains(cacheKey)) &#123; return wrapIfNecessary(bean, beanName, cacheKey); &#125; &#125; return bean;&#125; 关键便在于wrapIfNecessary方法: 12345678910111213141516171819202122232425protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) &#123; //自定义TargetSource，已经进行过代理子类生成 if (beanName != null &amp;&amp; this.targetSourcedBeans.contains(beanName)) &#123; return bean; &#125; if (Boolean.FALSE.equals(this.advisedBeans.get(cacheKey))) &#123; return bean; &#125; if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) &#123; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean; &#125; // Create proxy if we have advice. Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null); if (specificInterceptors != DO_NOT_PROXY) &#123; this.advisedBeans.put(cacheKey, Boolean.TRUE); // 创建 Object proxy = createProxy( bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean)); this.proxyTypes.put(cacheKey, proxy.getClass()); return proxy; &#125; this.advisedBeans.put(cacheKey, Boolean.FALSE); return bean;&#125; 可以看出，在此方法的开头又进行了基础类以及跳过类的检测，再次不再赘述。 Advisor寻找即getAdvicesAndAdvisorsForBean方法，这里进行的便是去容器中寻找适用于当前bean的Advisor，最终调用的是 AbstractAdvisorAutoProxyCreator.findEligibleAdvisors: 123456789protected List&lt;Advisor&gt; findEligibleAdvisors(Class&lt;?&gt; beanClass, String beanName) &#123; List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors(); List&lt;Advisor&gt; eligibleAdvisors = findAdvisorsThatCanApply(candidateAdvisors, beanClass, beanName); extendAdvisors(eligibleAdvisors); if (!eligibleAdvisors.isEmpty()) &#123; eligibleAdvisors = sortAdvisors(eligibleAdvisors); &#125; return eligibleAdvisors;&#125; findCandidateAdvisors前面已经说过了。 适用性判断findAdvisorsThatCanApply最终调用AopUtils.findAdvisorsThatCanApply: 12345678910111213141516171819202122public static List&lt;Advisor&gt; findAdvisorsThatCanApply(List&lt;Advisor&gt; candidateAdvisors, Class&lt;?&gt; clazz) &#123; if (candidateAdvisors.isEmpty()) &#123; return candidateAdvisors; &#125; List&lt;Advisor&gt; eligibleAdvisors = new LinkedList&lt;Advisor&gt;(); for (Advisor candidate : candidateAdvisors) &#123; if (candidate instanceof IntroductionAdvisor &amp;&amp; canApply(candidate, clazz)) &#123; eligibleAdvisors.add(candidate); &#125; &#125; boolean hasIntroductions = !eligibleAdvisors.isEmpty(); for (Advisor candidate : candidateAdvisors) &#123; if (candidate instanceof IntroductionAdvisor) &#123; // already processed continue; &#125; if (canApply(candidate, clazz, hasIntroductions)) &#123; eligibleAdvisors.add(candidate); &#125; &#125; return eligibleAdvisors;&#125; 关键在于canApply方法，从源码中可以看出，对于Advisor的判断分为了IntroductionAdvisor以及非IntroductionAdvisor两种情况。 这种分开处理导致了IntroductionAdvisor在Advisor链中总是位于非IntroductionAdvisor前面。 canApply(candidate, clazz)其实等价于canApply(candidate, clazz, false): 12345678910111213public static boolean canApply(Advisor advisor, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123; if (advisor instanceof IntroductionAdvisor) &#123; return ((IntroductionAdvisor) advisor).getClassFilter().matches(targetClass); &#125; else if (advisor instanceof PointcutAdvisor) &#123; PointcutAdvisor pca = (PointcutAdvisor) advisor; return canApply(pca.getPointcut(), targetClass, hasIntroductions); &#125; else &#123; // It doesn't have a pointcut so we assume it applies. return true; &#125;&#125; 很明显，对于引入Advisor与其它Advisor是两种不同的判断方式。 引入引入的概念在下面aop:scoped-proxy中有提到。因为引入的目的在于动态地向一个类添加另一种功能(接口)，所以只要判断给定的类是否是要引入到的类即可。 其它AopUtils.canApply: 12345678910111213141516171819202122232425262728293031public static boolean canApply(Pointcut pc, Class&lt;?&gt; targetClass, boolean hasIntroductions) &#123; //是否Pointcut可以匹配当前类 if (!pc.getClassFilter().matches(targetClass)) &#123; return false; &#125; MethodMatcher methodMatcher = pc.getMethodMatcher(); //是否Pointcut可以匹配所有方法 if (methodMatcher == MethodMatcher.TRUE) &#123; // No need to iterate the methods if we're matching any method anyway... return true; &#125; IntroductionAwareMethodMatcher introductionAwareMethodMatcher = null; if (methodMatcher instanceof IntroductionAwareMethodMatcher) &#123; introductionAwareMethodMatcher = (IntroductionAwareMethodMatcher) methodMatcher; &#125; Set&lt;Class&lt;?&gt;&gt; classes = new LinkedHashSet&lt;Class&lt;?&gt;&gt; (ClassUtils.getAllInterfacesForClassAsSet(targetClass)); classes.add(targetClass); for (Class&lt;?&gt; clazz : classes) &#123; Method[] methods = ReflectionUtils.getAllDeclaredMethods(clazz); for (Method method : methods) &#123; if ((introductionAwareMethodMatcher != null &amp;&amp; introductionAwareMethodMatcher .matches(method, targetClass, hasIntroductions)) || methodMatcher.matches(method, targetClass)) &#123; return true; &#125; &#125; &#125; return false;&#125; Spring的Pointcut由ClassFilter和MethodMatcher两部分组成，其中前者用以判断给定的类是否在Pointcut的匹配范围内，后者用以在ClassFilter匹配满足的情况下判断给定的方法是否在Pointcut匹配的范围内。 从源码中可以看出，如果ClassFilter匹配得到满足并且Pointcut并不能匹配此类的任意方法，便会用反射的方法获取targetClass(被检测类)的全部方法逐一交由Pointcut的MethodMatcher进行检测。 关于Pointcut表达式是如何解析及存储的在此不再展开。 Advisor扩展AbstractAdvisorAutoProxyCreator.extendAdvisors允许子类向Advisor链表中添加自己的Advisor。子类AspectJAwareAdvisorAutoProxyCreator重写了此方法，其逻辑是: 如果Advisor链表中的Advisor含有AspectJ Advice，那么将会把一个ExposeInvocationInterceptor添加到链表的表头，目的在于将MethodInvocation以ThreadLocal的方式暴露给后面所有的Advisor，暂不知道具体的用途。 排序即sortAdvisors方法，用于对实现了Ordered接口的Advisor进行排序。 创建AbstractAutoProxyCreator.createProxy(略去非关键代码): 1234567891011protected Object createProxy( Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource) &#123; ProxyFactory proxyFactory = new ProxyFactory(); proxyFactory.copyFrom(this); //将interceptor适配为Advisor Advisor[] advisors = buildAdvisors(beanName, specificInterceptors); for (Advisor advisor : advisors) &#123; proxyFactory.addAdvisor(advisor); &#125; return proxyFactory.getProxy(getProxyClassLoader());&#125; JDK动态代理 or Cglib由DefaultAopProxyFactory.createAopProxy方法决定使用何种方式创建代理子类。 12345678910111213@Overridepublic AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException &#123; if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123; Class&lt;?&gt; targetClass = config.getTargetClass(); if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123; return new JdkDynamicAopProxy(config); &#125; return new ObjenesisCglibAopProxy(config); &#125; else &#123; return new JdkDynamicAopProxy(config); &#125;&#125; 逻辑很明显，如果指定了(proxy-target-classs设为true)使用Cglib，那么就会使用Cglib的方式，如果没有指定(或为false)，那么先回检测被代理类是否实现了自己的接口，如果实现了，那么就采用JDK动态代理的方式。 JDK动态代理JdkDynamicAopProxy.getProxy: 123456789@Overridepublic Object getProxy(ClassLoader classLoader) &#123; //找到可以用来进行代理的接口 Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true); //用来代理的接口中是否定义了equals或者是hashCode方法? //结果保存在内部equalsDefined和hashCodeDefined两个成员变量中 findDefinedEqualsAndHashCodeMethods(proxiedInterfaces); return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);&#125; 可以看出，关键的InvocationHandler参数其实就是JdkDynamicAopProxy自身。 其invoke方法较长，源码就不贴了，下面进行分部分说明。 equals &amp; hashCode如果被代理类实现了equals或者是hashCode方法，那么生成的代理子类的equals、hashCode方法实际上执行的是JdkDynamicAopProxy相应方法的逻辑。 invoke方法部分源码: 1234if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) &#123; // The target does not implement the equals(Object) method itself. return equals(args[0]);&#125; 链式调用对于切点方法，比如前面aop:aspect示例配置中的beforeSend 1&lt;aop:before method=\"beforeSend\" pointcut-ref=\"pointcut\" /&gt; Spring会创建一个MethodInvocation对象对所有相关的Advisor进行链式调用。invoke相关源码: 123List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);invocation = new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);Object retVal = invocation.proceed(); Cglib同样是对于Advisor的链式调用，不再详细展开。 aop:scoped-proxy此配置一般是这样使用: 123456&lt;bean id=\"userPreferences\" class=\"com.foo.UserPreferences\" scope=\"session\"&gt; &lt;aop:scoped-proxy/&gt;&lt;/bean&gt;&lt;bean id=\"userManager\" class=\"com.foo.UserManager\"&gt; &lt;property name=\"userPreferences\" ref=\"userPreferences\"/&gt;&lt;/bean&gt; 对于ref属性，只会在userManager初始化时注入一次。这会造成什么问题呢?以session的Scope为例，因为只会注入一次，所以，userManager引用的始终是同一个userPreferences对象，即使现在可能已经过时了。此配置便可以使userManager引用的其实是一个对代理的引用，所以可以始终获取到最新的userPreferences。 其作用和注解@ScopedProxy相同。 其解析由ScopedProxyBeanDefinitionDecorator完成，类图: 解析入口从类图可以看出，ScopedProxyBeanDefinitionDecorator和之前的解析器都不同，它的调用入口不同以往: DefaultBeanDefinitionDocumentReader.processBeanDefinition: 1234567protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; // 装饰 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); &#125;&#125; BeanDefinitionParserDelegate.decorateIfRequired: 12345678910111213public BeanDefinitionHolder decorateIfRequired( Node node, BeanDefinitionHolder originalDef, BeanDefinition containingBd) &#123; String namespaceUri = getNamespaceURI(node); if (!isDefaultNamespace(namespaceUri)) &#123; NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver() .resolve(namespaceUri); if (handler != null) &#123; return handler. decorate(node, originalDef, new ParserContext(this.readerContext, this, containingBd)); &#125; &#125; return originalDef;&#125; 一目了然。 这么做(装饰)的原因就是此标签是用在bean内部的，从decorate的方法签名可以看出，第二个便是父(bean)BeanDefinition，所以叫做装饰。 装饰123456789101112131415161718@Overridepublic BeanDefinitionHolder decorate(Node node, BeanDefinitionHolder definition, ParserContext parserContext) &#123; boolean proxyTargetClass = true; if (node instanceof Element) &#123; Element ele = (Element) node; if (ele.hasAttribute(PROXY_TARGET_CLASS)) &#123; proxyTargetClass = Boolean.valueOf(ele.getAttribute(PROXY_TARGET_CLASS)); &#125; &#125; BeanDefinitionHolder holder = ScopedProxyUtils. createScopedProxy(definition, parserContext.getRegistry(), proxyTargetClass); String targetBeanName = ScopedProxyUtils.getTargetBeanName(definition.getBeanName()); // 空实现 parserContext.getReaderContext().fireComponentRegistered( new BeanComponentDefinition(definition.getBeanDefinition(), targetBeanName)); return holder;&#125; 核心便是createScopedProxy方法，其源码较长，但是这个套路之前见识过了，就是一个偷天换日: 创建一个新的BeanDefinition对象，beanName为被代理的bean的名字，被代理的bean名字为scopedTarget.原名字。被代理的bean扔将被注册到容器中。 新的BeanDefintion的beanClass为ScopedProxyFactoryBean，其类图: 代理生成入口便是setBeanFactory方法: 1234567891011121314151617181920212223@Overridepublic void setBeanFactory(BeanFactory beanFactory) &#123; ConfigurableBeanFactory cbf = (ConfigurableBeanFactory) beanFactory; this.scopedTargetSource.setBeanFactory(beanFactory); ProxyFactory pf = new ProxyFactory(); pf.copyFrom(this); pf.setTargetSource(this.scopedTargetSource); Class&lt;?&gt; beanType = beanFactory.getType(this.targetBeanName); if (!isProxyTargetClass() || beanType.isInterface() || Modifier.isPrivate(beanType.getModifiers())) &#123; // JDK动态代理可用的接口 pf.setInterfaces(ClassUtils.getAllInterfacesForClass(beanType, cbf.getBeanClassLoader())); &#125; // Add an introduction that implements only the methods on ScopedObject. ScopedObject scopedObject = new DefaultScopedObject (cbf, this.scopedTargetSource.getTargetBeanName()); pf.addAdvice(new DelegatingIntroductionInterceptor(scopedObject)); // Add the AopInfrastructureBean marker to indicate that the scoped proxy // itself is not subject to auto-proxying! Only its target bean is. pf.addInterface(AopInfrastructureBean.class); this.proxy = pf.getProxy(cbf.getBeanClassLoader());&#125; 这个套路上面也见过了。 Advisor核心的拦截逻辑是通过DelegatingIntroductionInterceptor来完成的，其类图: AdvisedSupport.addAdvice方法将其转化为Advisor: 123456789101112@Overridepublic void addAdvice(int pos, Advice advice) throws AopConfigException &#123; if (advice instanceof IntroductionInfo) &#123; // We don't need an IntroductionAdvisor for this kind of introduction: // It's fully self-describing. addAdvisor(pos, new DefaultIntroductionAdvisor(advice, (IntroductionInfo) advice)); &#125; else if (advice instanceof DynamicIntroductionAdvice) &#123; // We need an IntroductionAdvisor for this kind of introduction. &#125; else &#123; addAdvisor(pos, new DefaultPointcutAdvisor(advice)); &#125;&#125; 显然，DelegatingIntroductionInterceptor被包装为DefaultIntroductionAdvisor对象。 DelegatingIntroductionInterceptor到底是个什么东西呢?这其实就引出了Spring的Introduction(引入)概念。 引入通常意义上的Spring AOP一般是在方法层面上进行逻辑的改变，而引入指的是在不修改类源码的情况下，直接为一个类添加新的功能。下面是一个引入使用的例子: SpringAOP中的IntroductionInterceptor 例子自定义Scope为了便于测试，我们定义一个生存周期仅仅在于一次调用的Scope，源码: 1234567891011public class OneScope implements Scope &#123; private int index = 0; @Override public Object get(String name, ObjectFactory&lt;?&gt; objectFactory) &#123; System.out.println(\"get被调用\"); return new Student(\"skywalker-\" + (index++), index); &#125; //忽略其它方法&#125; 将其注册到容器中，有两种方法: 在代码中: 1context.getBeanFactory().registerScope(\"one\", new OneScope()); 配置文件: 123456789&lt;bean class=\"org.springframework.beans.factory.config.CustomScopeConfigurer\"&gt; &lt;property name=\"scopes\"&gt; &lt;map&gt; &lt;entry key=\"one\"&gt; &lt;bean class=\"base.scope.OneScope\" /&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 配置此时就可以使用我们自己的Scope了: 1234567&lt;bean class=\"base.SimpleBean\" id=\"simpleBean\"&gt; &lt;property name=\"student\" ref=\"student\" /&gt;&lt;/bean&gt;&lt;bean id=\"student\" class=\"base.Student\" scope=\"one\"&gt; &lt;aop:scoped-proxy /&gt;&lt;/bean&gt; 测试执行以下代码: 123SimpleBean simpleBean = context.getBean(SimpleBean.class);System.out.println(simpleBean.getStudent().getName());System.out.println(simpleBean.getStudent().getName()); 可以看到以下输出: 1234get被调用skywalker-0get被调用skywalker-1 可以得出结论: 当调用被代理的bean的方法时才会触发Scoped的语义，只是获得其对象(getStudent)没有效果。 原理doGetBean从根本上来说在于AbstractBeanFactory.doGetBean，部分源码: 123456789101112131415161718//scope非prototype和Singletonelse &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);&#125; scopes是BeanFactory内部的一个 LinkedHashMap类型的对象。scope.get实际上调用的就是我们的OneSocpe的get方法，没有用到ObjectFactory。 所以，每调用一次getBean，就会导致一个新的Sudent被创建并返回。 代理子类还有一个关键的问题，从上面可以知道SimpleBean内部的student引用其实是一个CGLIB代理子类的对象，那么当调用这个代理对象的相应方法(比如getName)时，是怎样导致Student重新创建(或是getBean被调用)的? CallbackFilter &amp; Callback必须首先理解下CGLIB的这两个概念。 CallbackCallback是Cglib所有自定义逻辑(增强)的共同接口。 其简略类图: CallbackFilter在CGLib回调时可以设置对不同方法执行不同的回调逻辑，或者根本不执行回调。 jdk并不支持这么搞，只支持设置一个InvocationHandler处理(拦截)所有的方法。其类图: Cglib的Enhancer可以指定一个Callback数组，而accept方法的返回值是一个int值，其实就是Callback数组的下标，这样便达到了指定回调逻辑的目的。 参考: CGLIB介绍与原理 回调一般的方法使用的是DynamicAdvisedInterceptor作为回调逻辑，其intercept关键源码: 1234@Overridepublic Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) &#123; Object target = getTarget();&#125; target就是被代理对象。 getTarget: 123protected Object getTarget() throws Exception &#123; return this.advised.getTargetSource().getTarget();&#125; TargetSource前面说过了，默认是SimpleBeanTargetSource: 1234@Overridepublic Object getTarget() throws Exception &#123; return getBeanFactory().getBean(getTargetBeanName());&#125; 至此，真相大白。 aop:aspectj-autoproxy此标签用以开启对于@AspectJ注解风格AOP的支持。 属性proxy-target-class你懂的。 expose-proxy是否应该把代理对象暴露给AopContext，默认false。 栗子切面123456789@Aspectpublic class AspectDemo &#123; @Pointcut(\"execution(void base.aop.AopDemo.send(..))\") public void beforeSend() &#123;&#125; @Before(\"beforeSend()\") public void before() &#123; System.out.println(\"send之前\"); &#125;&#125; 被代理类123456789101112public class AopDemo implements AopDemoInter &#123; public void send() &#123; System.out.println(\"send from aopdemo\"); &#125; public void receive() &#123; System.out.println(\"receive from aopdemo\"); &#125; @Override public void inter() &#123; System.out.println(\"inter\"); &#125;&#125; 配置123&lt;aop:aspectj-autoproxy proxy-target-class=\"true\" /&gt;&lt;bean class=\"base.aop.AopDemo\" /&gt;&lt;bean class=\"base.aop.annotation.AspectDemo\" /&gt; 因为AopDemo实现了AopDemoInter接口，但做实验的send方法又不在此接口里定义，所以只能用cglib的方式代理。 可以看出，即使标注了@Aspect注解，仍然需要将切面自己配置到Spring容器中。 解析AspectJAutoProxyBeanDefinitionParser.parse: 1234567@Overridepublic BeanDefinition parse(Element element, ParserContext parserContext) &#123; AopNamespaceUtils. registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element); extendBeanDefinition(element, parserContext); return null;&#125; 注册最终在AopConfigUtils.registerOrEscalateApcAsRequired方法中完成，创建器实际上是一个AnnotationAwareAspectJAutoProxyCreator类的对象，此类是前面AspectJAwareAdvisorAutoProxyCreator的子类。 原理既然是AspectJAwareAdvisorAutoProxyCreator的子类，那么其代理子类的创建等核心逻辑自然是一样的。这里所需要关注的地方自然是所不一样的地方: 即是如何体现其注解的特性的。 前面说过，AspectJAwareAdvisorAutoProxyCreator通过findCandidateAdvisors方法来找到适用于bean的Advisor，所以注解的特性也是通过重写此方法来体现。 AnnotationAwareAspectJAutoProxyCreator.findCandidateAdvisors: 1234567@Overrideprotected List&lt;Advisor&gt; findCandidateAdvisors() &#123; List&lt;Advisor&gt; advisors = super.findCandidateAdvisors(); //这里 advisors.addAll(this.aspectJAdvisorsBuilder.buildAspectJAdvisors()); return advisors;&#125; buildAspectJAdvisors方法所做的便是从容器中得到所有的bean，逐一判断是不是一个Aspect。那么判断Aspect的依据是什么? AbstractAspectJAdvisorFactory.isAspect: 1234@Overridepublic boolean isAspect(Class&lt;?&gt; clazz) &#123; return (hasAspectAnnotation(clazz) &amp;&amp; !compiledByAjc(clazz));&#125; 至于其它的实现细节不再探究。 总结Spring对于AspectJ风格AOP的支持停留在外表(注解)上面，内部的实现仍然是自己的东西。 拾遗AOP切面的坑 定义在private方法上的切面不会被执行，这个很容易理解，毕竟子类不能覆盖父类的私有方法。 同一个代理子类内部的方法相互调用不会再次执行切面。 这里以Cglib为例对第二点进行说明，cglib的相关核心组件可以参考前面CallbackFilter &amp; Callback部分。对于配置了一个切面的典型场景，Spring内部的执行流程可总结如下图: 核心便是对目标方法的调用上，这里由CglibMethodInvocation的invokeJoinpoint实现: 12345678@Overrideprotected Object invokeJoinpoint() throws Throwable &#123; if (this.publicMethod) &#123; return this.methodProxy.invoke(this.target, this.arguments); &#125; else &#123; return super.invokeJoinpoint(); &#125;&#125; 如果是非public方法，那么Spring将使用反射的方法对其进行调用，因为反射将其可访问性设为true。MethodProxy是Cglib对方法代理的抽象，这里的关键是方法调用的对象(目标)是我们的原生类对象，而不是Cglib代理子类的对象，这就从根本上决定了对同类方法的调用不会再次经过切面。 总结前面aop:aspectj-autoproxy-属性-expose-proxy一节提到了，Spring允许我们将代理子类暴露出来，可以进行如下配置: 123&lt;aop:config expose-proxy=\"true\"&gt; &lt;aop:advisor advice-ref=\"simpleMethodInterceptor\" pointcut=\"execution(* aop.SimpleAopBean.*(..))\" /&gt;&lt;/aop:config&gt; 当我们需要在一个被代理方法中调用同类的方法时(此方法也需要经过切面)，可以这样调用: 1234public void testB() &#123; System.out.println(\"testB执行\"); ((SimpleAopBean) AopContext.currentProxy()).testC();&#125; 这里其实是一个ThreadLocal，当Cglib代理子类创建调用链之间便会将代理类设置到其中，DynamicAdvisedInterceptor.intercept相关源码: 12345if (this.advised.exposeProxy) &#123; // Make invocation available if necessary. oldProxy = AopContext.setCurrentProxy(proxy); setProxyContext = true;&#125; 申明本文转载自seaswalker的github，转载授权，由我在万达摆地摊整理发布。","categories":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/tags/spring/"}]},{"title":"spring core源码分析","slug":"spring-core源码分析","date":"2018-06-06T03:50:05.000Z","updated":"2018-10-05T09:23:53.613Z","comments":true,"path":"posts/60270/","link":"","permalink":"https://satra.tk/posts/60270/","excerpt":"基本本部分从最基本的Spring开始。配置文件: 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans&gt; &lt;bean class=\"base.SimpleBean\"&gt;&lt;/bean&gt;&lt;/beans&gt;","text":"基本本部分从最基本的Spring开始。配置文件: 1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans&gt; &lt;bean class=\"base.SimpleBean\"&gt;&lt;/bean&gt;&lt;/beans&gt; 启动代码: 123456public static void main(String[] args) &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"config.xml\"); SimpleBean bean = context.getBean(SimpleBean.class); bean.send(); context.close();&#125; SimpleBean: 12345public class SimpleBean &#123; public void send() &#123; System.out.println(\"I am send method from SimpleBean!\"); &#125;&#125; ClassPathXmlApplicationContext整个继承体系如下: ResourceLoader代表了加载资源的一种方式，正是策略模式的实现。 构造器源码: 123456789public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) &#123; //null super(parent); setConfigLocations(configLocations); //默认true if (refresh) &#123; refresh(); &#125;&#125; 构造器首先看父类构造器，沿着继承体系一直向上调用，直到AbstractApplicationContext: 1234567public AbstractApplicationContext(ApplicationContext parent) &#123; this(); setParent(parent);&#125;public AbstractApplicationContext() &#123; this.resourcePatternResolver = getResourcePatternResolver();&#125; getResourcePatternResolver: 123protected ResourcePatternResolver getResourcePatternResolver() &#123; return new PathMatchingResourcePatternResolver(this);&#125; PathMatchingResourcePatternResolver支持Ant风格的路径解析。 设置配置文件路径即AbstractRefreshableConfigApplicationContext.setConfigLocations: 1234567891011public void setConfigLocations(String... locations) &#123; if (locations != null) &#123; Assert.noNullElements(locations, \"Config locations must not be null\"); this.configLocations = new String[locations.length]; for (int i = 0; i &lt; locations.length; i++) &#123; this.configLocations[i] = resolvePath(locations[i]).trim(); &#125; &#125; else &#123; this.configLocations = null; &#125;&#125; resolvePath: 123protected String resolvePath(String path) &#123; return getEnvironment().resolveRequiredPlaceholders(path);&#125; 此方法的目的在于将占位符(placeholder)解析成实际的地址。比如可以这么写: new ClassPathXmlApplicationContext(&quot;classpath:config.xml&quot;);那么classpath:就是需要被解析的。 getEnvironment方法来自于ConfigurableApplicationContext接口，源码很简单，如果为空就调用createEnvironment创建一个。AbstractApplicationContext.createEnvironment: 123protected ConfigurableEnvironment createEnvironment() &#123; return new StandardEnvironment();&#125; Environment接口继承体系: Environmen接口代表了当前应用所处的环境。从此接口的方法可以看出，其主要和profile、Property相关。 ProfileSpring Profile特性是从3.1开始的，其主要是为了解决这样一种问题: 线上环境和测试环境使用不同的配置或是数据库或是其它。有了Profile便可以在 不同环境之间无缝切换。Spring容器管理的所有bean都是和一个profile绑定在一起的。使用了Profile的配置文件示例: 123456789&lt;beans profile=\"develop\"&gt; &lt;context:property-placeholder location=\"classpath*:jdbc-develop.properties\"/&gt; &lt;/beans&gt; &lt;beans profile=\"production\"&gt; &lt;context:property-placeholder location=\"classpath*:jdbc-production.properties\"/&gt; &lt;/beans&gt; &lt;beans profile=\"test\"&gt; &lt;context:property-placeholder location=\"classpath*:jdbc-test.properties\"/&gt; &lt;/beans&gt; 在启动代码中可以用如下代码设置活跃(当前使用的)Profile: 1context.getEnvironment().setActiveProfiles(\"dev\"); 当然使用的方式还有很多(比如注解)，参考: spring3.1 profile 配置不同的环境 Spring Profiles example Property这里的Property指的是程序运行时的一些参数，引用注释: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects,Maps, and so on. Environment构造器1234private final MutablePropertySources propertySources = new MutablePropertySources(this.logger);public AbstractEnvironment() &#123; customizePropertySources(this.propertySources);&#125; PropertySources接口继承体系: 此接口实际上是PropertySource的容器，默认的MutablePropertySources实现内部含有一个CopyOnWriteArrayList作为存储载体。 StandardEnvironment.customizePropertySources: 1234567891011/** System environment property source name: &#123;@value&#125; */public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = \"systemEnvironment\";/** JVM system properties property source name: &#123;@value&#125; */public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = \"systemProperties\";@Overrideprotected void customizePropertySources(MutablePropertySources propertySources) &#123; propertySources.addLast(new MapPropertySource (SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME, getSystemProperties())); propertySources.addLast(new SystemEnvironmentPropertySource (SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, getSystemEnvironment()));&#125; PropertySource接口PropertySource接口代表了键值对的Property来源。继承体系： AbstractEnvironment.getSystemProperties: 123456789101112131415161718192021222324@Overridepublic Map&lt;String, Object&gt; getSystemProperties() &#123; try &#123; return (Map) System.getProperties(); &#125; catch (AccessControlException ex) &#123; return (Map) new ReadOnlySystemAttributesMap() &#123; @Override protected String getSystemAttribute(String attributeName) &#123; try &#123; return System.getProperty(attributeName); &#125; catch (AccessControlException ex) &#123; if (logger.isInfoEnabled()) &#123; logger.info(format(\"Caught AccessControlException when accessing system \" + \"property [%s]; its value will be returned [null]. Reason: %s\", attributeName, ex.getMessage())); &#125; return null; &#125; &#125; &#125;; &#125;&#125; 这里的实现很有意思，如果安全管理器阻止获取全部的系统属性，那么会尝试获取单个属性的可能性，如果还不行就抛异常了。 getSystemEnvironment方法也是一个套路，不过最终调用的是System.getenv，可以获取jvm和OS的一些版本信息。 路径Placeholder处理AbstractEnvironment.resolveRequiredPlaceholders: 12345@Overridepublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException &#123; //text即配置文件路径，比如classpath:config.xml return this.propertyResolver.resolveRequiredPlaceholders(text);&#125; propertyResolver是一个PropertySourcesPropertyResolver对象: 12private final ConfigurablePropertyResolver propertyResolver = new PropertySourcesPropertyResolver(this.propertySources); PropertyResolver接口PropertyResolver继承体系(排除Environment分支): 此接口正是用来解析PropertyResource。 解析AbstractPropertyResolver.resolveRequiredPlaceholders: 1234567@Overridepublic String resolveRequiredPlaceholders(String text) throws IllegalArgumentException &#123; if (this.strictHelper == null) &#123; this.strictHelper = createPlaceholderHelper(false); &#125; return doResolvePlaceholders(text, this.strictHelper);&#125; 12345private PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) &#123; //三个参数分别是$&#123;, &#125;, : return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix, this.valueSeparator, ignoreUnresolvablePlaceholders);&#125; doResolvePlaceholders： 123456789private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) &#123; //PlaceholderResolver接口依然是策略模式的体现 return helper.replacePlaceholders(text, new PropertyPlaceholderHelper.PlaceholderResolver() &#123; @Override public String resolvePlaceholder(String placeholderName) &#123; return getPropertyAsRawString(placeholderName); &#125; &#125;);&#125; 其实代码执行到这里的时候还没有进行xml配置文件的解析，那么这里的解析placeHolder是什么意思呢，原因在于可以这么写: 123System.setProperty(\"spring\", \"classpath\");ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"$&#123;spring&#125;:config.xml\");SimpleBean bean = context.getBean(SimpleBean.class); 这样就可以正确解析。placeholder的替换其实就是字符串操作，这里只说一下正确的属性是怎么来的。实现的关键在于PropertySourcesPropertyResolver.getProperty: 12345678910111213@Overrideprotected String getPropertyAsRawString(String key) &#123; return getProperty(key, String.class, false);&#125;protected &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetValueType, boolean resolveNestedPlaceholders) &#123; if (this.propertySources != null) &#123; for (PropertySource&lt;?&gt; propertySource : this.propertySources) &#123; Object value = propertySource.getProperty(key); return value; &#125; &#125; return null;&#125; 很明显了，就是从System.getProperty和System.getenv获取，但是由于环境变量是无法自定义的，所以其实此处只能通过System.setProperty指定。 注意，classpath:XXX这种写法的classpath前缀到目前为止还没有被处理。 refreshSpring bean解析就在此方法，所以单独提出来。 AbstractApplicationContext.refresh: 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; prepareRefresh1234567891011121314protected void prepareRefresh() &#123; this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); // Initialize any placeholder property sources in the context environment //空实现 initPropertySources(); // Validate that all properties marked as required are resolvable // see ConfigurablePropertyResolver#setRequiredProperties getEnvironment().validateRequiredProperties(); // Allow for the collection of early ApplicationEvents, // to be published once the multicaster is available... this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();&#125; 属性校验AbstractEnvironment.validateRequiredProperties: 1234@Overridepublic void validateRequiredProperties() throws MissingRequiredPropertiesException &#123; this.propertyResolver.validateRequiredProperties();&#125; AbstractPropertyResolver.validateRequiredProperties: 123456789101112@Overridepublic void validateRequiredProperties() &#123; MissingRequiredPropertiesException ex = new MissingRequiredPropertiesException(); for (String key : this.requiredProperties) &#123; if (this.getProperty(key) == null) &#123; ex.addMissingRequiredProperty(key); &#125; &#125; if (!ex.getMissingRequiredProperties().isEmpty()) &#123; throw ex; &#125;&#125; requiredProperties是通过setRequiredProperties方法设置的，保存在一个list里面，默认是空的，也就是不需要校验任何属性。 BeanFactory创建由obtainFreshBeanFactory调用AbstractRefreshableApplicationContext.refreshBeanFactory: 12345678910111213141516@Overrideprotected final void refreshBeanFactory() throws BeansException &#123; //如果已经存在，那么销毁之前的 if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; //创建了一个DefaultListableBeanFactory对象 DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125;&#125; BeanFactory接口此接口实际上就是Bean容器，其继承体系: BeanFactory定制AbstractRefreshableApplicationContext.customizeBeanFactory方法用于给子类提供一个自由配置的机会，默认实现: 12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; if (this.allowBeanDefinitionOverriding != null) &#123; //默认false，不允许覆盖 beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.allowCircularReferences != null) &#123; //默认false，不允许循环引用 beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125;&#125; Bean加载AbstractXmlApplicationContext.loadBeanDefinitions，这个便是核心的bean加载了: 123456789101112131415@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) &#123; // Create a new XmlBeanDefinitionReader for the given BeanFactory. XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // Allow a subclass to provide custom initialization of the reader, // then proceed with actually loading the bean definitions. //默认空实现 initBeanDefinitionReader(beanDefinitionReader); loadBeanDefinitions(beanDefinitionReader);&#125; EntityResolver此处只说明用到的部分继承体系: EntityResolver接口在org.xml.sax中定义。DelegatingEntityResolver用于schema和dtd的解析。 BeanDefinitionReader继承体系: 路径解析(Ant)1234567891011protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; reader.loadBeanDefinitions(configResources); &#125; String[] configLocations = getConfigLocations(); //here if (configLocations != null) &#123; reader.loadBeanDefinitions(configLocations); &#125;&#125; AbstractBeanDefinitionReader.loadBeanDefinitions: 123456789@Overridepublic int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException &#123; Assert.notNull(locations, \"Location array must not be null\"); int counter = 0; for (String location : locations) &#123; counter += loadBeanDefinitions(location); &#125; return counter;&#125; 之后调用: 12345678910111213141516171819202122232425262728293031//第二个参数为空public int loadBeanDefinitions(String location, Set&lt;Resource&gt; actualResources) &#123; ResourceLoader resourceLoader = getResourceLoader(); //参见ResourceLoader类图，ClassPathXmlApplicationContext实现了此接口 if (resourceLoader instanceof ResourcePatternResolver) &#123; // Resource pattern matching available. try &#123; Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location); int loadCount = loadBeanDefinitions(resources); if (actualResources != null) &#123; for (Resource resource : resources) &#123; actualResources.add(resource); &#125; &#125; return loadCount; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( \"Could not resolve bean definition resource pattern [\" + location + \"]\", ex); &#125; &#125; else &#123; // Can only load single resources by absolute URL. Resource resource = resourceLoader.getResource(location); int loadCount = loadBeanDefinitions(resource); if (actualResources != null) &#123; actualResources.add(resource); &#125; return loadCount; &#125;&#125; getResource的实现在AbstractApplicationContext： 12345@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; //构造器中初始化，PathMatchingResourcePatternResolver对象 return this.resourcePatternResolver.getResources(locationPattern);&#125; PathMatchingResourcePatternResolver是ResourceLoader继承体系的一部分。 123456789101112131415161718192021222324252627282930@Overridepublic Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, \"Location pattern must not be null\"); //classpath: if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // a class path resource (multiple resources for same name possible) //matcher是一个AntPathMatcher对象 if (getPathMatcher().isPattern(locationPattern .substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern .substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; else &#123; // Only look for a pattern after a prefix here // (to not get fooled by a pattern symbol in a strange prefix). int prefixEnd = locationPattern.indexOf(\":\") + 1; if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125;&#125; isPattern: 1234@Overridepublic boolean isPattern(String path) &#123; return (path.indexOf('*') != -1 || path.indexOf('?') != -1);&#125; 可以看出配置文件路径是支持ant风格的，也就是可以这么写: 1new ClassPathXmlApplicationContext(\"con*.xml\"); 具体怎么解析ant风格的就不写了。 配置文件加载入口方法在AbstractBeanDefinitionReader的217行: 1234//加载Resource[] resources = ((ResourcePatternResolver) resourceLoader).getResources(location);//解析int loadCount = loadBeanDefinitions(resources); 最终逐个调用XmlBeanDefinitionReader的loadBeanDefinitions方法: 1234@Overridepublic int loadBeanDefinitions(Resource resource) &#123; return loadBeanDefinitions(new EncodedResource(resource));&#125; Resource是代表一种资源的接口，其类图: EncodedResource扮演的其实是一个装饰器的模式，为InputStreamSource添加了字符编码(虽然默认为null)。这样为我们自定义xml配置文件的编码方式提供了机会。 之后关键的源码只有两行: 12345public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); InputSource inputSource = new InputSource(inputStream); return doLoadBeanDefinitions(inputSource, encodedResource.getResource());&#125; InputSource是org.xml.sax的类。 doLoadBeanDefinitions： 1234protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) &#123; Document doc = doLoadDocument(inputSource, resource); return registerBeanDefinitions(doc, resource);&#125; doLoadDocument: 1234protected Document doLoadDocument(InputSource inputSource, Resource resource) &#123; return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware());&#125; documentLoader是一个DefaultDocumentLoader对象，此类是DocumentLoader接口的唯一实现。getEntityResolver方法返回ResourceEntityResolver，上面说过了。errorHandler是一个SimpleSaxErrorHandler对象。 校验模型其实就是确定xml文件使用xsd方式还是dtd方式来校验，忘了的话左转度娘。Spring会通过读取xml文件的方式判断应该采用哪种。 NamespaceAware默认false，因为默认配置了校验为true。 DefaultDocumentLoader.loadDocument: 12345678@Overridepublic Document loadDocument(InputSource inputSource, EntityResolver entityResolver, ErrorHandler errorHandler, int validationMode, boolean namespaceAware) &#123; //这里就是老套路了，可以看出，Spring还是使用了dom的方式解析，即一次全部load到内存 DocumentBuilderFactory factory = createDocumentBuilderFactory(validationMode, namespaceAware); DocumentBuilder builder = createDocumentBuilder(factory, entityResolver, errorHandler); return builder.parse(inputSource);&#125; createDocumentBuilderFactory比较有意思: 12345678910111213141516protected DocumentBuilderFactory createDocumentBuilderFactory(int validationMode, boolean namespaceAware&#123; DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); factory.setNamespaceAware(namespaceAware); if (validationMode != XmlValidationModeDetector.VALIDATION_NONE) &#123; //此方法设为true仅对dtd有效，xsd(schema)无效 factory.setValidating(true); if (validationMode == XmlValidationModeDetector.VALIDATION_XSD) &#123; // Enforce namespace aware for XSD... //开启xsd(schema)支持 factory.setNamespaceAware(true); //这个也是Java支持Schema的套路，可以问度娘 factory.setAttribute(SCHEMA_LANGUAGE_ATTRIBUTE, XSD_SCHEMA_LANGUAGE); &#125; &#125; return factory;&#125; Bean解析XmlBeanDefinitionReader.registerBeanDefinitions: 123456public int registerBeanDefinitions(Document doc, Resource resource) &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125; createBeanDefinitionDocumentReader: 12345protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123; return BeanDefinitionDocumentReader.class.cast //反射 (BeanUtils.instantiateClass(this.documentReaderClass));&#125; documentReaderClass默认是DefaultBeanDefinitionDocumentReader，这其实也是策略模式，通过setter方法可以更换其实现。 注意cast方法，代替了强转。 createReaderContext： 1234public XmlReaderContext createReaderContext(Resource resource) &#123; return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, getNamespaceHandlerResolver());&#125; problemReporter是一个FailFastProblemReporter对象。 eventListener是EmptyReaderEventListener对象，此类里的方法都是空实现。 sourceExtractor是NullSourceExtractor对象，直接返回空，也是空实现。 getNamespaceHandlerResolver默认返回DefaultNamespaceHandlerResolver对象，用来获取xsd对应的处理器。 XmlReaderContext的作用感觉就是这一堆参数的容器，糅合到一起传给DocumentReader，并美其名为Context。可以看出，Spring中到处都是策略模式，大量操作被抽象成接口。 DefaultBeanDefinitionDocumentReader.registerBeanDefinitions: 123456@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; Element root = doc.getDocumentElement(); doRegisterBeanDefinitions(root);&#125; doRegisterBeanDefinitions: 12345678910111213141516171819202122protected void doRegisterBeanDefinitions(Element root) &#123; BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); //默认的命名空间即 //http://www.springframework.org/schema/beans if (this.delegate.isDefaultNamespace(root)) &#123; //检查profile属性 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; //profile属性可以以,分割 String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; return; &#125; &#125; &#125; preProcessXml(root); parseBeanDefinitions(root, this.delegate); postProcessXml(root); this.delegate = parent;&#125; delegate的作用在于处理beans标签的嵌套，其实Spring配置文件是可以写成这样的: 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans&gt; &lt;bean class=\"base.SimpleBean\"&gt;&lt;/bean&gt; &lt;beans&gt; &lt;bean class=\"java.lang.Object\"&gt;&lt;/bean&gt; &lt;/beans&gt;&lt;/beans&gt; xml(schema)的命名空间其实类似于java的报名，命名空间采用URL，比如Spring的是这样: 12&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;beans xmlns=\"http://www.springframework.org/schema/beans\"&gt;&lt;/beans&gt; xmlns属性就是xml规范定义的用来设置命名空间的。这样设置了之后其实里面的bean元素全名就相当于http://www.springframework.org/schema/beans:bean，可以有效的防止命名冲突。命名空间可以通过规范定义的org.w3c.dom.Node.getNamespaceURI方法获得。 注意一下profile的检查, AbstractEnvironment.acceptsProfiles: 1234567891011121314@Overridepublic boolean acceptsProfiles(String... profiles) &#123; Assert.notEmpty(profiles, \"Must specify at least one profile\"); for (String profile : profiles) &#123; if (StringUtils.hasLength(profile) &amp;&amp; profile.charAt(0) == '!') &#123; if (!isProfileActive(profile.substring(1))) &#123; return true; &#125; &#125; else if (isProfileActive(profile)) &#123; return true; &#125; &#125; return false;&#125; 原理很简单，注意从源码可以看出，profile属性支持!取反。 preProcessXml方法是个空实现，供子类去覆盖，目的在于给子类一个把我们自定义的标签转为Spring标准标签的机会, 想的真周到。 DefaultBeanDefinitionDocumentReader.parseBeanDefinitions： 123456789101112131415161718protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; parseDefaultElement(ele, delegate); &#125; else &#123; delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 可见，对于非默认命名空间的元素交由delegate处理。 默认命名空间解析即import, alias, bean, 嵌套的beans四种元素。parseDefaultElement: 12345678910111213141516private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; //\"import\" if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; processBeanDefinition(ele, delegate); &#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // recurse doRegisterBeanDefinitions(ele); &#125;&#125; import写法示例: 12&lt;import resource=\"CTIContext.xml\" /&gt;&lt;import resource=\"customerContext.xml\" /&gt; importBeanDefinitionResource套路和之前的配置文件加载完全一样，不过注意被import进来的文件是先于当前文件 被解析的。 alias加入有一个bean名为componentA-dataSource，但是另一个组件想以componentB-dataSource的名字使用，就可以这样定义: 1&lt;alias name=\"componentA-dataSource\" alias=\"componentB-dataSource\"/&gt; processAliasRegistration核心源码: 123456protected void processAliasRegistration(Element ele) &#123; String name = ele.getAttribute(NAME_ATTRIBUTE); String alias = ele.getAttribute(ALIAS_ATTRIBUTE); getReaderContext().getRegistry().registerAlias(name, alias); getReaderContext().fireAliasRegistered(name, alias, extractSource(ele));&#125; 从前面的源码可以发现，registry其实就是DefaultListableBeanFactory，它实现了BeanDefinitionRegistry接口。registerAlias方法的实现在SimpleAliasRegistry: 12345678910111213141516171819202122232425@Overridepublic void registerAlias(String name, String alias) &#123; Assert.hasText(name, \"'name' must not be empty\"); Assert.hasText(alias, \"'alias' must not be empty\"); //名字和别名一样 if (alias.equals(name)) &#123; //ConcurrentHashMap this.aliasMap.remove(alias); &#125; else &#123; String registeredName = this.aliasMap.get(alias); if (registeredName != null) &#123; if (registeredName.equals(name)) &#123; // An existing alias - no need to re-register return; &#125; if (!allowAliasOverriding()) &#123; throw new IllegalStateException (\"Cannot register alias '\" + alias + \"' for name '\" + name + \"': It is already registered for name '\" + registeredName + \"'.\"); &#125; &#125; checkForAliasCircle(name, alias); this.aliasMap.put(alias, name); &#125;&#125; 所以别名关系的保存使用Map完成，key为别名，value为本来的名字。 beanbean节点是Spring最最常见的节点了。 DefaultBeanDefinitionDocumentReader.processBeanDefinition: 1234567891011121314151617protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition (bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; id &amp; name处理最终调用BeanDefinitionParserDelegate.parseBeanDefinitionElement(Element ele, BeanDefinition containingBean)，源码较长，分部分说明。 首先获取到id和name属性，name属性支持配置多个，以逗号分隔，如果没有指定id，那么将以第一个name属性值代替。id必须是唯一的，name属性其实是alias的角色，可以和其它的bean重复，如果name也没有配置，那么其实什么也没做。 1234567891011121314151617181920String id = ele.getAttribute(ID_ATTRIBUTE);String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);List&lt;String&gt; aliases = new ArrayList&lt;String&gt;();if (StringUtils.hasLength(nameAttr)) &#123; //按,分隔 String[] nameArr = StringUtils.tokenizeToStringArray (nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr));&#125;String beanName = id;if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; //name的第一个值作为id beanName = aliases.remove(0);&#125;//默认nullif (containingBean == null) &#123; //校验id是否已重复，如果重复直接抛异常 //校验是通过内部一个HashSet完成的，出现过的id都会保存进此Set checkNameUniqueness(beanName, aliases, ele);&#125; beanName生成如果name和id属性都没有指定，那么Spring会自己生成一个, BeanDefinitionParserDelegate.parseBeanDefinitionElement: 123beanName = this.readerContext.generateBeanName(beanDefinition);String beanClassName = beanDefinition.getBeanClassName();aliases.add(beanClassName); 可见，Spring同时会把类名作为其别名。 最终调用的是BeanDefinitionReaderUtils.generateBeanName: 12345678910111213141516171819202122232425262728public static String generateBeanName( BeanDefinition definition, BeanDefinitionRegistry registry, boolean isInnerBean) &#123; String generatedBeanName = definition.getBeanClassName(); if (generatedBeanName == null) &#123; if (definition.getParentName() != null) &#123; generatedBeanName = definition.getParentName() + \"$child\"; //工厂方法产生的bean &#125; else if (definition.getFactoryBeanName() != null) &#123; generatedBeanName = definition.getFactoryBeanName() + \"$created\"; &#125; &#125; String id = generatedBeanName; if (isInnerBean) &#123; // Inner bean: generate identity hashcode suffix. id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + ObjectUtils.getIdentityHexString(definition); &#125; else &#123; // Top-level bean: use plain class name. // Increase counter until the id is unique. int counter = -1; //用类名#自增的数字命名 while (counter == -1 || registry.containsBeanDefinition(id)) &#123; counter++; id = generatedBeanName + GENERATED_BEAN_NAME_SEPARATOR + counter; &#125; &#125; return id;&#125; bean解析还是分部分说明(parseBeanDefinitionElement)。 首先获取到bean的class属性和parent属性，配置了parent之后，当前bean会继承父bean的属性。之后根据class和parent创建BeanDefinition对象。 123456789String className = null;if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim();&#125;String parent = null;if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE);&#125;AbstractBeanDefinition bd = createBeanDefinition(className, parent); BeanDefinition的创建在BeanDefinitionReaderUtils.createBeanDefinition: 1234567891011121314public static AbstractBeanDefinition createBeanDefinition( String parentName, String className, ClassLoader classLoader) &#123; GenericBeanDefinition bd = new GenericBeanDefinition(); bd.setParentName(parentName); if (className != null) &#123; if (classLoader != null) &#123; bd.setBeanClass(ClassUtils.forName(className, classLoader)); &#125; else &#123; bd.setBeanClassName(className); &#125; &#125; return bd;&#125; 之后是解析bean的其它属性，其实就是读取其配置，调用相应的setter方法保存在BeanDefinition中: 1parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); 之后解析bean的decription子元素: 123&lt;bean id=\"b\" name=\"one, two\" class=\"base.SimpleBean\"&gt; &lt;description&gt;SimpleBean&lt;/description&gt;&lt;/bean&gt; 就仅仅是个描述。 然后是meta子元素的解析，meta元素在xml配置文件里是这样的: 123&lt;bean id=\"b\" name=\"one, two\" class=\"base.SimpleBean\"&gt; &lt;meta key=\"name\" value=\"skywalker\"/&gt;&lt;/bean&gt; 注释上说，这样可以将任意的元数据附到对应的bean definition上。解析过程源码: 12345678910111213141516public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) &#123; NodeList nl = ele.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (isCandidateElement(node) &amp;&amp; nodeNameEquals(node, META_ELEMENT)) &#123; Element metaElement = (Element) node; String key = metaElement.getAttribute(KEY_ATTRIBUTE); String value = metaElement.getAttribute(VALUE_ATTRIBUTE); //就是一个key, value的载体，无他 BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value); //sourceExtractor默认是NullSourceExtractor，返回的是空 attribute.setSource(extractSource(metaElement)); attributeAccessor.addMetadataAttribute(attribute); &#125; &#125;&#125; AbstractBeanDefinition继承自BeanMetadataAttributeAccessor类，底层使用了一个LinkedHashMap保存metadata。这个metadata具体是做什么暂时还不知道。 lookup-method解析： 此标签的作用在于当一个bean的某个方法被设置为lookup-method后，每次调用此方法时，都会返回一个新的指定bean的对象。用法示例: 12345&lt;bean id=\"apple\" class=\"cn.com.willchen.test.di.Apple\" scope=\"prototype\"/&gt;&lt;!--水果盘--&gt;&lt;bean id=\"fruitPlate\" class=\"cn.com.willchen.test.di.FruitPlate\"&gt; &lt;lookup-method name=\"getFruit\" bean=\"apple\"/&gt;&lt;/bean&gt; 数据保存在Set中，对应的类是MethodOverrides。可以参考: Spring - lookup-method方式实现依赖注入 replace-mothod解析: 此标签用于替换bean里面的特定的方法实现，替换者必须实现Spring的MethodReplacer接口，有点像aop的意思。 配置文件示例: 123456&lt;bean name=\"replacer\" class=\"springroad.deomo.chap4.MethodReplace\" /&gt; &lt;bean name=\"testBean\" class=\"springroad.deomo.chap4.LookupMethodBean\"&gt; &lt;replaced-method name=\"test\" replacer=\"replacer\"&gt; &lt;arg-type match=\"String\" /&gt; &lt;/replaced-method&gt; &lt;/bean&gt; arg-type的作用是指定替换方法的参数类型，因为接口的定义参数都是Object的。参考: SPRING.NET 1.3.2 学习20–方法注入之替换方法注入 解析之后将数据放在ReplaceOverride对象中，里面有一个LinkedList专门用于保存arg-type。 构造参数(constructor-arg)解析: 作用一目了然，使用示例: 12345&lt;bean class=\"base.SimpleBean\"&gt; &lt;constructor-arg&gt; &lt;value type=\"java.lang.String\"&gt;Cat&lt;/value&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; type一般不需要指定，除了泛型集合那种。除此之外，constructor-arg还支持name, index, ref等属性，可以具体的指定参数的位置等。构造参数解析后保存在BeanDefinition内部一个ConstructorArgumentValues对象中。如果设置了index属性，那么以Map的形式保存，反之，以List的形式保存。 property解析: 非常常用的标签，用以为bean的属性赋值，支持value和ref两种形式，示例: 123&lt;bean class=\"base.SimpleBean\"&gt; &lt;property name=\"name\" value=\"skywalker\" /&gt;&lt;/bean&gt; value和ref属性不能同时出现，如果是ref，那么将其值保存在不可变的RuntimeBeanReference对象中，其实现了BeanReference接口，此接口只有一个getBeanName方法。如果是value，那么将其值保存在TypedStringValue对象中。最终将对象保存在BeanDefinition内部一个MutablePropertyValues对象中(内部以ArrayList实现)。 qualifier解析: 配置示例: 1234567891011&lt;bean class=\"base.Student\"&gt; &lt;property name=\"name\" value=\"skywalker\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"12\"&gt;&lt;/property&gt; &lt;qualifier type=\"org.springframework.beans.factory.annotation.Qualifier\" value=\"student\" /&gt;&lt;/bean&gt; &lt;bean class=\"base.Student\"&gt; &lt;property name=\"name\" value=\"seaswalker\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"15\"&gt;&lt;/property&gt; &lt;qualifier value=\"student_2\"&gt;&lt;/qualifier&gt;&lt;/bean&gt;&lt;bean class=\"base.SimpleBean\" /&gt; SimpleBean部分源码: 123@Autowired@Qualifier(\"student\")private Student student; 此标签和@Qualifier, @Autowired两个注解一起使用才有作用。@Autowired注解采用按类型查找的方式进行注入，如果找到多个需要类型的bean便会报错，有了@Qualifier标签就可以再按照此注解指定的名称查找。两者结合相当于实现了按类型+名称注入。type属性可以不指定，因为默认就是那个。qualifier标签可以有attribute子元素，比如: 123&lt;qualifier type=\"org.springframework.beans.factory.annotation.Qualifier\" value=\"student\"&gt; &lt;attribute key=\"id\" value=\"1\"/&gt;&lt;/qualifier&gt; 貌似是用来在qualifier也区分不开的时候使用。attribute键值对保存在BeanMetadataAttribute对象中。整个qualifier保存在AutowireCandidateQualifier对象中。 Bean装饰这部分是针对其它schema的属性以及子节点，比如: 123&lt;bean class=\"base.Student\" primary=\"true\"&gt; &lt;context:property-override /&gt;&lt;/bean&gt; 没见过这种用法，留个坑。 Bean注册BeanDefinitionReaderUtils.registerBeanDefinition: 12345678910111213public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) &#123; // Register bean definition under primary name. String beanName = definitionHolder.getBeanName(); registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // Register aliases for bean name, if any. String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; registry.registerAlias(beanName, alias); &#125; &#125;&#125; registry其实就是DefaultListableBeanFactory对象，registerBeanDefinition方法主要就干了这么两件事: 12345@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); this.beanDefinitionNames.add(beanName);&#125; 一个是Map，另一个是List，一目了然。registerAlias方法的实现在其父类SimpleAliasRegistry，就是把键值对放在了一个ConcurrentHashMap里。 ComponentRegistered事件触发: 默认是个空实现，前面说过了。 BeanDefiniton数据结构BeanDefiniton数据结构如下图: beansbeans元素的嵌套直接递归调用DefaultBeanDefinitionDocumentReader.parseBeanDefinitions。 其它命名空间解析入口在DefaultBeanDefinitionDocumentReader.parseBeanDefinitions-&gt;BeanDefinitionParserDelegate.parseCustomElement(第二个参数为空): 12345public BeanDefinition parseCustomElement(Element ele, BeanDefinition containingBd) &#123; String namespaceUri = getNamespaceURI(ele); NamespaceHandler handler = this.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri); return handler.parse(ele, new ParserContext(this.readerContext, this, containingBd));&#125; NamespaceHandlerResolver由XmlBeanDefinitionReader初始化，是一个DefaultNamespaceHandlerResolver对象，也是NamespaceHandlerResolver接口的唯一实现。 其resolve方法: 1234567891011121314151617@Overridepublic NamespaceHandler resolve(String namespaceUri) &#123; Map&lt;String, Object&gt; handlerMappings = getHandlerMappings(); Object handlerOrClassName = handlerMappings.get(namespaceUri); if (handlerOrClassName == null) &#123; return null; &#125; else if (handlerOrClassName instanceof NamespaceHandler) &#123; return (NamespaceHandler) handlerOrClassName; &#125; else &#123; String className = (String) handlerOrClassName; Class&lt;?&gt; handlerClass = ClassUtils.forName(className, this.classLoader); NamespaceHandler namespaceHandler = (NamespaceHandler) BeanUtils.instantiateClass(handlerClass); namespaceHandler.init(); handlerMappings.put(namespaceUri, namespaceHandler); return namespaceHandler; &#125;&#125; 容易看出，Spring其实使用了一个Map了保存其映射关系，key就是命名空间的uri，value是NamespaceHandler对象或是Class完整名，如果发现是类名，那么用反射的方法进行初始化，如果是NamespaceHandler对象，那么直接返回。 NamespaceHandler映射关系来自于各个Spring jar包下的META-INF/spring.handlers文件，以spring-context包为例: 12345http\\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandlerhttp\\://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandlerhttp\\://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandlerhttp\\://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandlerhttp\\://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler NamespaceHandler继承体系 initresolve中调用了其init方法，此方法用以向NamespaceHandler对象注册BeanDefinitionParser对象。此接口用以解析顶层(beans下)的非默认命名空间元素，比如&lt;context:annotation-config /&gt;。 所以这样逻辑就很容易理解了: 每种子标签的解析仍是策略模式的体现，init负责向父类NamespaceHandlerSupport注册不同的策略，由父类的NamespaceHandlerSupport.parse方法根据具体的子标签调用相应的策略完成解析的过程。 此部分较为重要，所以重新开始大纲。 BeanFactory数据结构BeanDefinition在BeanFactory中的主要数据结构如下图: prepareBeanFactory此方法负责对BeanFactory进行一些特征的设置工作，”特征”包含这么几个方面: BeanExpressionResolver此接口只有一个实现: StandardBeanExpressionResolver。接口只含有一个方法: 1Object evaluate(String value, BeanExpressionContext evalContext) prepareBeanFactory将一个此对象放入BeanFactory: 1beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); StandardBeanExpressionResolver对象内部有一个关键的成员: SpelExpressionParser,其整个类图: 这便是Spring3.0开始出现的Spel表达式的解释器。 PropertyEditorRegistrar此接口用于向Spring注册java.beans.PropertyEditor，只有一个方法: 1registerCustomEditors(PropertyEditorRegistry registry) 实现也只有一个: ResourceEditorRegistrar。 在编写xml配置时，我们设置的值都是字符串形式，所以在使用时肯定需要转为我们需要的类型，PropertyEditor接口正是定义了这么个东西。 prepareBeanFactory: 1beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); BeanFactory也暴露了registerCustomEditors方法用以添加自定义的转换器，所以这个地方是组合模式的体现。 我们有两种方式可以添加自定义PropertyEditor: 通过context.getBeanFactory().registerCustomEditor 通过Spring配置文件: 1234567&lt;bean class=\"org.springframework.beans.factory.config.CustomEditorConfigurer\"&gt; &lt;property name=\"customEditors\"&gt; &lt;map&gt; &lt;entry key=\"base.Cat\" value=\"base.CatEditor\" /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 参考: 深入理解JavaBean(2)：属性编辑器PropertyEditor 环境注入在Spring中我们自己的bean可以通过实现EnvironmentAware等一系列Aware接口获取到Spring内部的一些对象。prepareBeanFactory: 1beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); ApplicationContextAwareProcessor核心的invokeAwareInterfaces方法: 1234567891011private void invokeAwareInterfaces(Object bean) &#123; if (bean instanceof Aware) &#123; if (bean instanceof EnvironmentAware) &#123; ((EnvironmentAware) bean).setEnvironment(this.applicationContext.getEnvironment()); &#125; if (bean instanceof EmbeddedValueResolverAware) &#123; ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(this.embeddedValueResolver); &#125; //.... &#125;&#125; 依赖解析忽略此部分设置哪些接口在进行依赖注入的时候应该被忽略: 12345beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);beanFactory.ignoreDependencyInterface(MessageSourceAware.class);beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);beanFactory.ignoreDependencyInterface(EnvironmentAware.class); bean伪装有些对象并不在BeanFactory中，但是我们依然想让它们可以被装配，这就需要伪装一下: 1234beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);beanFactory.registerResolvableDependency(ResourceLoader.class, this);beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);beanFactory.registerResolvableDependency(ApplicationContext.class, this); 伪装关系保存在一个Map","categories":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/tags/spring/"}]},{"title":"JDK动态代理的实现","slug":"JDK动态代理的实现","date":"2018-04-13T08:02:31.000Z","updated":"2018-04-19T08:00:28.331Z","comments":true,"path":"posts/6839/","link":"","permalink":"https://satra.tk/posts/6839/","excerpt":"什么是动态代理问题引入有这样一个类： 1234567public class Hello &#123; public void say() &#123; System.out.println(\"hello world\"); &#125;&#125; 现在有一个需求：需要在Hello类运行say()方法前后使用日志记录下运行的时间戳，该怎么做？","text":"什么是动态代理问题引入有这样一个类： 1234567public class Hello &#123; public void say() &#123; System.out.println(\"hello world\"); &#125;&#125; 现在有一个需求：需要在Hello类运行say()方法前后使用日志记录下运行的时间戳，该怎么做？ 最直观的方式就是在say()方法的前后加上日志记录当前的时间戳，像这样： 1234567public void say() &#123; System.out.println(System.currentTimeMillis());//用控制台输出代替日志记录 System.out.println(\"hello world\"); System.out.println(System.currentTimeMillis());//用控制台输出代替日志记录&#125; 但是这个时候，我们又有了一个新的类叫做GoodBye类，它也有个say()方法，我么也需要为它的say()方法添加日志记录，这时候怎么办？ 又手动为其方法前后添加日志记录逻辑？要是有一千个say()方法需要添加日志记录呢？ 这个时候我们可以使用装饰者模式来给业务代码添加“修饰”。 首先，我们需要为say()方法抽象出一个接口，我们暂时把这个接口叫做Hello吧： 123public interface Hello &#123; void say();&#125; 然后创建我们的装饰器，为HelloImpl的say方法添加“修饰”代码： 1234567891011121314public class HelloDecorator implements Hello &#123; private Hello hello; public HelloDecorator(Hello hello) &#123; this.hello = hello; &#125; public void say() &#123; System.out.println(System.currentTimeMillis()); this.hello.say(); System.out.println(System.currentTimeMillis()); &#125;&#125; 这样，我们在创建HelloDecorator装饰器的时候，只需将实现了Hello接口的实例对象作为参数传给装饰器，调用装饰器的say()方法就可以实现为say()方法添加日志记录的逻辑了。 这个时候我们虽然是实现了对于所有实现了Hello接口的类的say()方法的日志记录，但是我们如果还需要为goodBye()方法记录日志呢？若是有一千个方法需要记录日志呢？ 这个时候就需要动态代理了，其实动态代理的本质就是：动态的生成一个类实现某个接口，为接口的每一个方法添加一个固定的逻辑。 JDK的动态代理在分析JDK动态代理之前，我们先来看下JDK的动态代理是怎么使用的。 还是以上面的例子为例：我们需要在一个say()方法运行前后为其添加日志记录。 首先，我们需要一个实现了InvocationHandler接口的handler，并实现了接口的invoke方法： 123456789101112131415public class HelloInvocationHandler implements InvocationHandler &#123; private Hello hello; public HelloInvocationHandler(Hello hello) &#123; this.hello = hello; &#125; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(System.currentTimeMillis()); Object o = method.invoke(hello, args); System.out.println(System.currentTimeMillis()); return o; &#125;&#125; 然后写我们的main方法： 123456public static void main(String[] args) &#123; Hello hello = new HelloImpl(); HelloInvocationHandler h = new HelloInvocationHandler(hello); Hello proxyHello = (Hello) Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), h); proxyHello.say();&#125; 这样我们就实现了为say()方法添加日志记录的逻辑，但不仅限于say()方法哦，hello类中的所有方法都已经添加了日志记录的逻辑，只需要你通过proxyHello去调用其方法就行了。 JDK动态代理的实现其实JDK的动态代理的实现是很简单的，就是动态的为我们的类去生成一个装饰器类，我们可以来看看JDK为我们生成的这个装饰器类是什么样的。 我们只需要在newProxyInstance之前设置一下系统参数System.getProperties().put(“sun.misc.ProxyGenerator.saveGeneratedFiles”, “true”)，运行后就会在我们的工程目录下有一个JDK为我们生成的一个装饰器类。 在这个例子中，反编译下JDK为我们生成的装饰器类的源码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071package com.sun.proxy;import com.dj.proxy.Hello;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;import java.lang.reflect.UndeclaredThrowableException;public final class $Proxy0 extends Proxy implements Hello &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return ((Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;)).booleanValue(); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void say() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return ((Integer)super.h.invoke(this, m0, (Object[])null)).intValue(); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); m3 = Class.forName(\"com.dj.proxy.Hello\").getMethod(\"say\"); m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125; 可以看到，这个类的类名叫“$Proxy0”，在com.sun.proxy这个包下面，并且这个也实现了Hello接口，而其say()方法里面的代码是调用了其父类的h属性的invoke方法。而这个类的构造方法也是通过父类的构造方法实现的，接着，我们来看下它的父类的h属性和构造方法。 $Proxy0父类构造方法及属性： 123456protected InvocationHandler h;protected Proxy(InvocationHandler h) &#123; Objects.requireNonNull(h); this.h = h;&#125; 属性h就是一个InvocationHandler，而在JDK为我们生成的装饰器的方法中就是调用InvocationHandler的invoke方法为我们的类“装饰的”。 而这个InvocationHandler类是怎么来的呢？还记得我们在调用Proxy的newProxyInstance方法的时候传的一个我们自己实现了InvocationHandler接口的类吗？这里的InvocationHandler类就是我们自己实现了InvocationHandler接口的那个类，而JDK为我们生成的的装饰器类的装饰代码就是我们自己在invoke方法中写的，所以绕来绕去又绕回来了。 JDK动态代理源码分析注：本节中所有的JDK源代码都是去掉安全检测异常精简过后的，这样看上去结构更加清晰 最后我们来看下JDK动态代理的源码，看看它到底是怎么实现的。 回到我们使用JDK动态代理的main函数中，在main函数中，我们通过Proxy.newProxyInstance()为HelloImpl创建了一个代理类，这里就是JDK代理的入口，我们跟进去看看： 1234567891011121314151617181920212223242526public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException&#123; //首先检查InvocationHandler，不能为空 Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); //生成装饰器类的字节码，JDK动态代理核心方法 Class&lt;?&gt; cl = getProxyClass0(loader, intfs); //获取到装饰器类的有InvocationHandler参数的构造方法 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; //返回构造器实例对象 return cons.newInstance(new Object[]&#123;h&#125;); getProxyClass0方法源码： 12345678910private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; //接口个数不能超过65535个...... if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; //从缓存中取 return proxyClassCache.get(loader, interfaces);&#125; 可以看到，JDK在获取装饰器类的时候还做了一层缓存，只有在缓存中没找到的时候才会去生成装饰器类，生成装饰器类如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123; //所有装饰器类的名字都是以这个作为前缀的 private static final String proxyClassNamePrefix = \"$Proxy\"; //所有装饰器类名的后缀 private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; //这里的代码是把所有的接口都load进内存，防止有些接口在内存中还没有 for (Class&lt;?&gt; intf : interfaces) &#123; Class&lt;?&gt; interfaceClass = null; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; String proxyPkg = null; int accessFlags = Modifier.PUBLIC | Modifier.FINAL; //下面都是生成包名的逻辑 for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; &#125; &#125; //当通过上面的逻辑生成的包名为空的时候采用默认的包名，即：com.sun.proxy if (proxyPkg == null) &#123; proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; //生成完整的类名 long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; //通过sun的非公开方法生成类的字节码 byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); //通过本地方法生成类的实例对象并返回 return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125;&#125; 总结通过剖析JDK动态代理的实现，最后我们可以这么说：JDK的动态代理其实就是JDK为我们动态的生成了一个装饰器类。 最后为读者留一个问题，也是面试中经常会被问到的问题：为什么JDK的动态代理只支持接口的代理而不支持类继承的代理？","categories":[{"name":"Java","slug":"Java","permalink":"https://satra.tk/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://satra.tk/tags/Java/"}]},{"title":"Java容器源码分析之HashMap与HashSet","slug":"Java容器源码分析之HashMap与HashSet","date":"2018-04-07T05:00:57.000Z","updated":"2018-04-19T06:47:33.122Z","comments":true,"path":"posts/53527/","link":"","permalink":"https://satra.tk/posts/53527/","excerpt":"HashMap与HashSet介绍HashMap是Java为我们提供的一个存放键值对的容器，通过键的hash值定位存储位置，具有很快的访问速度。但是其遍历顺序是不确定的，这里所说的不确定是指其遍历的顺序与放入顺序不一致、多次遍历输出顺序不一致(可能会放进数据导致reHash，改变原有顺序)。HashMap允许有一个null的键，对于值没做要求。HashMap也是个非线程安全的容器，在并发环境下可以使用ynchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 HashSet是Java为我们提供的一个集合类容器，他不允许容器内元素重复，底层采用HashMap实现(适配器模式)。","text":"HashMap与HashSet介绍HashMap是Java为我们提供的一个存放键值对的容器，通过键的hash值定位存储位置，具有很快的访问速度。但是其遍历顺序是不确定的，这里所说的不确定是指其遍历的顺序与放入顺序不一致、多次遍历输出顺序不一致(可能会放进数据导致reHash，改变原有顺序)。HashMap允许有一个null的键，对于值没做要求。HashMap也是个非线程安全的容器，在并发环境下可以使用ynchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。 HashSet是Java为我们提供的一个集合类容器，他不允许容器内元素重复，底层采用HashMap实现(适配器模式)。 以下是HashMap的UML图与HashSet的Uml图： HashMap源码分析HashMap数据结构HashMap采用了一种数组+链表+红黑树(JDK1.8新增)的数据结构； HashMap实际存放数据的是一个叫Entry的Node节点，它的定义如下： 123456789101112131415161718192021222324252627282930313233343536373839static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; 存入HashMap里的数据均用Entry封装起来，通过键值定位到数组的位置，当该位置为空时，放入Entry元素，当该位置不为空时通过equals比较该位置与放入元素的键值，当键值相等时直接替换，当键值不相等时，采用拉链法解决hash冲突。 拉链法解决hash冲突：当hash冲突发生时，通过在该位置建立链表，将所有hash值相同但是equals不相等的元素通过链表链起来解决hash冲突； 当HashMap中拉链的长度超过8时，HashMap将链表数据结构转换为红黑树，此时的查找时间复杂度降低为O(log n)。 HashMap方法解析get方法HashMap get方法源码如下： 1234public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 首先先拿到key的hash值，然后通过hash值定位到数组中该hash位置的node，然后返回node的value； 计算key的hash值方法hash(): 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 计算一个key的hash值得具体算法是：当key为null时，hash值为0，不为null时，首先得到该key的hashCode，然后异或上key的hashCode值无符号右移16位。 通过hash值得到数组指定位置node元素方法getNode()： 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 首先，通过(n - 1) &amp; hash得到元素在数组中的位置然后取出元素，其中n是数组的总长度；当这个元素与要取的key相等(==与equals)时，该元素就是要取得元素；当不相等时，即判断为hash冲突了；当hash冲突时，HashMap通过查找链表(红黑树)的方式查找该位置的拉链(红黑树)，直到找到一个元素与key equals相等时返回或者没找到返回null，此时的查找就变为对链表或红黑树的遍历。 put方法HashMap put方法源码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断table数组是否已经初始化 if ((tab = table) == null || (n = tab.length) == 0) //没有初始化，开始初始化table数组 n = (tab = resize()).length; //通过(n - 1) &amp; hash获取该元素在table中该放入的位置 if ((p = tab[i = (n - 1) &amp; hash]) == null) //若该位置为空，则直接放入元素 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //该位置不为空时，开始判断是否是hash冲突 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //不是hash冲突，开始判断该位置的数据结构是否是红黑树 else if (p instanceof TreeNode) //当是红黑树时，使用红黑树插入方式插入元素 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123; //该位置是链表数据结构，遍历链表，找到一个为空位置，插入元素 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st //当链表长度超过临界值时，开始将链表转换为红黑树数据结构 treeifyBin(tab, hash); break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) //当遍历到链表的某一个位置时，该位置元素与要插入元素equals相等时即判断两个元素相等，不用插入，跳出循环 break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold) //当此时HashMap长度大于长度 * 扩容因子时扩容 resize(); afterNodeInsertion(evict); return null;&#125; HashMap在put一个元素的时候会去调用其putVal方法，在putVal方法中，首先会去检测用来存储元素的数组是否已经初始化了，因为HashMap与ArrayList一样采用了延迟为数组分配空间的策略，我们可以来看下它的构造方法： 123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125; 默认的构造方法中，就设置了一个扩容因子。 若数组已经初始化了，HashMap会通过(n - 1) &amp; hash计算出该元素在数组中的位置，当该位置没有元素时，直接放入，当该位置已经有元素了，HashMap开始判断是否与该位置的元素发生了Hash冲突。 当发生了Hash冲突时，HashMap会判断该位置是通过红黑树还是链表，然后通过红黑树或者链表添加数据的方式添加新元素。 最后HashMap会检查此时数组的长度，当长度超过数组容量*扩容因子时会开始扩容的过程。 HashMap扩容函数resize方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394//resize兼容了扩容和HashMap初始化的过程final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; //获取数组长度 int oldCap = (oldTab == null) ? 0 : oldTab.length; //获取临界长度 int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; //当现在数组长度大于0时即说明HashMap已经初始化了，开始扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; //当长度超过1&lt;&lt;30长度时，直接将新长度设置为Integer.MAX_VALUE，为1&lt;&lt;30的两倍 threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //当(oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY且oldCap大于默认长度时，直接扩容为原有长度的两倍 newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) //当数组没有初始化时，若oldThr&gt;0，则说明调用的是有参数的构造函数 //此时新长度就是带参数构造函数计算出来的临界长度 newCap = oldThr; else &#123; //数组未初始化，且调用的是没有参数构造函数 //数组长度为默认值1&lt;&lt;4 //计算临界长度 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //上面是计算新数组的长度，下面开始将旧数组中元素搬移到新数组中 threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; //遍历旧数组 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) //当该位置就一个元素时，重新计算该元素在新数组中的位置并放入该元素 newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) //若该位置还有其他元素，且是红黑树的数据结构，执行红黑树迁移元素方案 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //通过e.hash &amp; oldCap判断元素是否需要移动 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) //确定首元素 loHead = e; else //循环遍历将元素迁移至loHead为首的链表中 loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; //loTail != null不为空说明元素不用移动，直接放在数组原位置 loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; //hiTail != null说明元素需要移动，将链表放在j + oldCap新位置 hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; //完成扩容 return newTab;&#125; 这里需要讲一下的，扩容时通过e.hash &amp; oldCap判断元素是否需要移动，具体示例如下： 示例1： 通过e.hash &amp; oldCap判断元素是否需要移动： e.hash = 10 0000 1010 oldCap = 16 0001 0000 &amp; = 0 0000 0000 //不需要移动 通过(e.hash &amp; (oldCap-1))计算得到的下标位置： e.hash = 10 0000 1010 oldCap - 1 = 15 0000 1111 &amp; = 10 0000 1010 //位置没变 示例2： 通过e.hash &amp; oldCap判断元素是否需要移动： e.hash = 17 0001 0001 oldCap = 16 0001 0000 &amp; = 1 0001 0000 //元素需要移动，新的下标位置是原下标位置 + 原数组长度 通过(e.hash &amp; (oldCap-1))计算得到的下标位置： e.hash = 17 0001 0001 newCap - 1 = 31 0001 1111 &amp; = 17 0001 0001 //位置为17 HashSet源码分析HashSet是通过HashMap实现的，首先我们来看下Hashset的构造函数： 1234567891011121314151617181920public HashSet() &#123; map = new HashMap&lt;&gt;();&#125;public HashSet(Collection&lt;? extends E&gt; c) &#123; map = new HashMap&lt;&gt;(Math.max((int) (c.size()/.75f) + 1, 16)); addAll(c);&#125;public HashSet(int initialCapacity, float loadFactor) &#123; map = new HashMap&lt;&gt;(initialCapacity, loadFactor);&#125;public HashSet(int initialCapacity) &#123; map = new HashMap&lt;&gt;(initialCapacity);&#125;HashSet(int initialCapacity, float loadFactor, boolean dummy) &#123; map = new LinkedHashMap&lt;&gt;(initialCapacity, loadFactor);&#125; 通过HashSet的构造函数我们就能略知一二，HashSet有个map的成员变量保存了一个HashMap的实例。 HashSet的add方法： 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; HashSet的add方法很简单，就一行代码；成员变量PRESENT是new出来的一个static final的Object对象。 HashSet通过将值作为HashMap的key，一个static final的Object对象作为value用来实现了一个不可重复的set容器 思考 Q：为什么HashMap与HashSet容量总是2的n次方？A：HashMap通过h &amp; (table.length -1)来得到该对象的保存位，当长度总是2的n次方时，h &amp; (length-1)运算等价于对length取模，也就是h%length，但是&amp;比%具有更高的效率。 Q：为什么HashMap要对长度取模？A：把hash值对数组长度取模运算，可以使元素相对均匀分布在数组中。","categories":[{"name":"Java容器","slug":"Java容器","permalink":"https://satra.tk/categories/Java容器/"}],"tags":[{"name":"Java容器","slug":"Java容器","permalink":"https://satra.tk/tags/Java容器/"}]},{"title":"Java容器源码分析之LinkedList","slug":"Java容器源码分析之LinkedList","date":"2018-03-28T02:07:33.000Z","updated":"2018-04-19T06:47:33.115Z","comments":true,"path":"posts/32562/","link":"","permalink":"https://satra.tk/posts/32562/","excerpt":"LinkedList简介LinkedList是一个使用双向链表结构实现的容器，与ArrayList一样，它能动态扩充其长度，LinkedList相较于ArrayList，其任意位置插入速度比ArrayList要快，但是其查询速度要比ArrayList要慢；LinkedList继承自AbstractSequentialList，实现了List、Deque、Cloneable、Serializable接口。","text":"LinkedList简介LinkedList是一个使用双向链表结构实现的容器，与ArrayList一样，它能动态扩充其长度，LinkedList相较于ArrayList，其任意位置插入速度比ArrayList要快，但是其查询速度要比ArrayList要慢；LinkedList继承自AbstractSequentialList，实现了List、Deque、Cloneable、Serializable接口。 LinkedList UML图如下： 和ArrayList一样，LinkedList也不是一个线程安全的容器。 LinkedList源码分析构造方法LinkedList有两个构造方法： 12345678public LinkedList() &#123;&#125;//从已有的一个容器创建一个LinkedList对象public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; addAll()方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //检查index是否溢出 checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; //获取第index位置的node元素和node的前一个元素 //succ：第index位置的node元素 //pred：index位置前一个node元素 Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; //遍历，将元素插入链表中 for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125; add方法LinkedList也有两个add方法，如下： 1234567891011121314151617public boolean add(E e) &#123; //添加元素到队尾 linkLast(e); return true;&#125;public void add(int index, E element) &#123; //检查index是否溢出 checkPositionIndex(index); if (index == size) //index == size，直接添加到队尾 linkLast(element); else //index != size，添加元素到index位置 linkBefore(element, node(index));&#125; linkLast方法： 123456789101112131415void linkLast(E e) &#123; final Node&lt;E&gt; l = last; //新建一个node，将其前一个元素指针指向原链表的最后一个元素 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); //更新尾指针 last = newNode; if (l == null) //若原last==null说明此时链表就一个元素 first = newNode; else //更新原链表尾元素指针 l.next = newNode; size++; modCount++;&#125; linkBefore方法： 123456789101112131415void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; //获取指定位node元素的前一个元素pred final Node&lt;E&gt; pred = succ.prev; //新建一个node，将其前指针指向pred元素 final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); //将指定位置的node元素的前指针指向新元素，完成插入 succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 获取指定位置node指针方法node： 12345678910111213141516Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); //index &gt; size/2时，说明在链表前半段，从前往后搜索 if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; //index &lt; size/2时，从后往前搜索 &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; get方法1234public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; get方法也比较简单，首先检测index是否溢出，然后直接找到index位置的元素，并返回其item。","categories":[{"name":"Java容器","slug":"Java容器","permalink":"https://satra.tk/categories/Java容器/"}],"tags":[{"name":"Java容器","slug":"Java容器","permalink":"https://satra.tk/tags/Java容器/"}]},{"title":"Java容器源码分析之ArrayList","slug":"Java容器源码分析之ArrayList","date":"2018-03-27T08:28:47.000Z","updated":"2018-04-19T06:47:33.094Z","comments":true,"path":"posts/64920/","link":"","permalink":"https://satra.tk/posts/64920/","excerpt":"ArrayList简介ArrayList是一个使用数组实现的容器，与普通的数组相比，它能动态的扩容，ArrayList继承自AbstractList，实现了List、RandomAccess、Cloneable、Serializable接口。","text":"ArrayList简介ArrayList是一个使用数组实现的容器，与普通的数组相比，它能动态的扩容，ArrayList继承自AbstractList，实现了List、RandomAccess、Cloneable、Serializable接口。 ArrayList UML图如下： ArrayList不是一个线程安全的容器。 ArrayList源码分析我们主要分析ArrayList的构造方法、add方法、get方法以及扩容方法 构造方法ArrayList有三个构造方法，分别如下： 1234567891011121314151617181920212223242526272829//构造一个指定长度的ArrayList对象，initialCapacity：长度public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125;&#125;//构造一个默认长度为0的ArrayList对象，JDK6以前默认长度为10public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;//从已有的一个容器创建一个ArrayList对象public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 对于第三个构造方法，第22行注释，这是Java在jdk6时代的一个bug，官方文档在此；造成这个bug的原因是：当元素存在父类对象时，父类实例的具体类型，实际上是取决于在new时，我们所使用的子类类型。当不加以23行检测代码时，可能会造成将一个父类存进子类数组中，导致报错。 add方法ArrayList中有两个add方法，如下： 12345678910111213141516171819202122//在尾部添加一个元素public boolean add(E e) &#123; //确定容量是否能够添加一个元素 ensureCapacityInternal(size + 1); // Increments modCount!! //将元素放到size位置 elementData[size++] = e; return true;&#125;//在指定位置添加一个元素public void add(int index, E element) &#123; //检查index是否溢出 rangeCheckForAdd(index); //确定容量是否能够添加一个元素 ensureCapacityInternal(size + 1); // Increments modCount!! //通过System.arraycopy将index+1到size位置的元素向后移一位 System.arraycopy(elementData, index, elementData, index + 1, size - index); //设置index位置的元素 elementData[index] = element; size++;&#125; 在两个add方法中都有调用检查容器空间是否足够的方法，下面看看ensureCapacityInternal是如何实现的； ensureCapacityInternal： 1234567891011121314151617181920private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;//返回当前长度和ArrayList默认长度中大的一个private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureExplicitCapacity(int minCapacity) &#123; //计数检查次数 modCount++; //当需要长度已经大于此时ArrayList内部数组长度时，开始扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 具体的扩容代码，我们将在后面分析，我们先来看下get是怎么实现的 get方法12345678910public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125;private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; get方法比较简单，首先检测index是否溢出，然后返回数组中第index个元素。 扩容方法我们在分析add方法的时候，就已经知道ArrayList的扩容方法是grow()方法了，我们直接来看grow()方法源码 grow： 12345678910111213141516171819202122private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; //newCapacity = oldCapacity + 0.5 * oldCapacity int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) //如果新长度值还小于需要长度，那么新长度设置为需要长度 newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) //当新长度大于Integer.MAX_VALUE - 8时，做一次检测 newCapacity = hugeCapacity(minCapacity); //将旧数组中元素复制进新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 总结ArrayList在jdk6以前，默认初始大小为10，jdk6以后采取了延迟为数组分配空间的策略默认初始大小为0，在第一次add元素的时候，会检测数组大小并初始化为默认大小10。 ArrayList扩容触发条件是当数组长度不足以容纳添加一个元素时扩容；扩容大小为原大小的1.5倍，具体算法为int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)","categories":[{"name":"Java容器","slug":"Java容器","permalink":"https://satra.tk/categories/Java容器/"}],"tags":[{"name":"Java容器","slug":"Java容器","permalink":"https://satra.tk/tags/Java容器/"}]},{"title":"spring模块解读","slug":"spring模块解读","date":"2018-03-26T08:04:49.000Z","updated":"2018-04-19T06:47:33.303Z","comments":true,"path":"posts/57271/","link":"","permalink":"https://satra.tk/posts/57271/","excerpt":"spring模块Spring框架的功能被有组织的分散到约20个模块中。这些模块分布在核心容器，数据访问/集成，Web，AOP（面向切面​​的编程），植入(Instrumentation)，消息传输和测试，如下面的图所示。","text":"spring模块Spring框架的功能被有组织的分散到约20个模块中。这些模块分布在核心容器，数据访问/集成，Web，AOP（面向切面​​的编程），植入(Instrumentation)，消息传输和测试，如下面的图所示。 核心容器核心容器由以下模块组成，spring-core， spring-beans，spring-context，spring-context-support，和spring-expression （Spring表达式语言）。 spring-core和spring-beans模块提供了框架的基础功能，包括IOC和依赖注入功能。 BeanFactory是一个成熟的工厂模式的实现。你不再需要编程去实现单例模式，允许你把依赖关系的配置和描述从程序逻辑中解耦。 上下文（spring-context）模块建立在由Core和Beans模块提供的坚实的基础上：它提供一个框架式的对象访问方式，类似于一个JNDI注册表。上下文模块从Beans模块继承其功能，并添加支持国际化（使用，例如，资源集合），事件传播，资源负载，并且透明创建上下文，例如，Servlet容器。Context模块还支持Java EE的功能，如EJB，JMX和基本的远程处理。ApplicationContext接口是Context模块的焦点。 spring-context-support支持整合普通第三方库到Spring应用程序上下文，特别是用于高速缓存（ehcache，JCache）和调度（CommonJ，Quartz）的支持。 spring-expression模块提供了强大的表达式语言去支持查询和操作运行时对象图。这是对JSP 2.1规范中规定的统一表达式语言（unified EL）的扩展。该语言支持设置和获取属性值，属性分配，方法调用，访问数组，集合和索引器的内容，逻辑和算术运算，变量命名以及从Spring的IoC容器中以名称检索对象。 它还支持列表投影和选择以及常见的列表聚合。 AOP和Instrumentationspring-aop模块提供了一个符合AOP联盟（要求）的面向方面的编程实现，例如，允许您定义方法拦截器和切入点（pointcuts），以便干净地解耦应该被分离的功能实现。 使用源级元数据(source-level metadata)功能，您还可以以类似于.NET属性的方式将行为信息合并到代码中。 单独的spring-aspects模块，提供了与AspectJ的集成。 spring-instrument模块提供了类植入(instrumentation)支持和类加载器的实现,可以应用在特定的应用服务器中。该spring-instrument-tomcat 模块包含了支持Tomcat的植入代理。 消息Spring框架4包括spring-messaging(消息传递模块)，其中包含来自Spring Integration的项目，例如，Message，MessageChannel，MessageHandler，和其他用来传输消息的基础应用。该模块还包括一组用于将消息映射到方法的注释(annotations)，类似于基于Spring MVC注释的编程模型。 数据访问/集成数据访问/集成层由JDBC，ORM，OXM，JMS和事务模块组成。 spring-jdbc模块提供了一个JDBC –抽象层，消除了需要的繁琐的JDBC编码和数据库厂商特有的错误代码解析。 spring-tx模块支持用于实现特殊接口和所有POJO（普通Java对象）的类的编程和声明式事务 管理。 spring-orm模块为流行的对象关系映射(object-relational mapping )API提供集成层，包括JPA和Hibernate。使用spring-orm模块，您可以将这些O / R映射框架与Spring提供的所有其他功能结合使用，例如前面提到的简单声明性事务管理功能。 spring-oxm模块提供了一个支持对象/ XML映射实现的抽象层，如JAXB，Castor，JiBX和XStream。 spring-jms模块(Java Messaging Service) 包含用于生产和消费消息的功能。自Spring Framework 4.1以来，它提供了与 spring-messaging模块的集成。 WebWeb层由spring-web，spring-webmvc和spring-websocket 模块组成。 spring-web模块提供基本的面向Web的集成功能，例如多部分文件上传功能，以及初始化一个使用了Servlet侦听器和面向Web的应用程序上下文的IoC容器。它还包含一个HTTP客户端和Spring的远程支持的Web相关部分。 spring-webmvc模块（也称为Web-Servlet模块）包含用于Web应用程序的Spring的模型-视图-控制器(MVC)和REST Web Services实现。 Spring的MVC框架提供了领域模型代码和Web表单之间的清晰分离，并与Spring Framework的所有其他功能集成。 测试spring-test模块支持使用JUnit或TestNG对Spring组件进行单元测试和 集成测试。它提供了Spring ApplicationContexts的一致加载和这些上下文的缓存。它还提供可用于独立测试代码的模仿(mock)对象。 本文节选自spring官方文档，由并发编程网翻译","categories":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/categories/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://satra.tk/tags/spring/"}]},{"title":"BST树与AVL树","slug":"BST树与AVL树","date":"2018-03-09T08:43:35.000Z","updated":"2018-04-19T06:47:33.086Z","comments":true,"path":"posts/61974/","link":"","permalink":"https://satra.tk/posts/61974/","excerpt":"抽象树结构定义本文将介绍BST树与AVL树，树的数据结构是类似于链表，首先我们需要一个抽象类AbstractTree，该类里面定义了树节点的数据结构，以及完成树的先序、中序、后续遍历的代码模板，后面的BST与AVL树将继承这个抽象类； 首先我们定义树节点的数据结构，通过内部类定义：","text":"抽象树结构定义本文将介绍BST树与AVL树，树的数据结构是类似于链表，首先我们需要一个抽象类AbstractTree，该类里面定义了树节点的数据结构，以及完成树的先序、中序、后续遍历的代码模板，后面的BST与AVL树将继承这个抽象类； 首先我们定义树节点的数据结构，通过内部类定义： 1234567891011121314151617181920212223242526/*** 树节点** @param &lt;k&gt; key* @param &lt;v&gt; value*/static class Node&lt;k extends Comparable&lt;k&gt;, v&gt; &#123; private k key; private v value; private Node left; private Node right; private int height; public Node(k key, v value) &#123; this.key = key; this.value = value; &#125; //省略了get、set方法 @Override public String toString() &#123; return \"key:\" + key + \",\" + \"value:\" + value; &#125;&#125; 然后完成树的先序、中序、后续遍历的模板代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344/*** 先序遍历*/public void preOrder() &#123; preOrder(root);&#125;private void preOrder(Node node) &#123; if (node == null) return; System.out.println(node); preOrder(node.getLeft()); preOrder(node.getRight());&#125;/*** 中序遍历*/public void middleOrder() &#123; middleOrder(root);&#125;private void middleOrder(Node node) &#123; if (node == null) return; middleOrder(node.getLeft()); System.out.println(node); middleOrder(node.getRight());&#125;/*** 后序遍历*/public void postOrder() &#123; postOrder(root);&#125;private void postOrder(Node node) &#123; if (node == null) return; postOrder(node.getLeft()); postOrder(node.getRight()); System.out.println(node);&#125; 对于树，我们需要写出它的添加节点、查找节点、删除节点方法，所以，我们在这个抽象类中添加添加节点、查找节点、删除节点的抽象方法交给子类具体的“树”去实现； 12345678910111213141516171819202122/*** 添加元素** @param key* @param value*/public abstract void add(k key, v value);/*** 查找元素** @param key* @return*/public abstract v get(k key);/*** 删除元素** @param key*/public abstract void del(k key); BST树BST树介绍BST全称为Binary Search Tree，即二叉搜索树； 一颗二叉树具有如下性质被称之为BST树： 若任意节点的左子树不空，则左子树上所有节点的值均小于它的根节点的值； 若任意节点的右子树不空，则右子树上所有节点的值均大于它的根节点的值； 任意节点的左、右子树也分别为二叉查找树； 没有键值相等的节点。 下图就是一颗典型的BST树： BST树实现首先需要继承之前的树的抽象类AbstractTree； 接下来实现BST树的添加节点、查找节点、删除节点方法； 添加节点首先需要判断root节点是否已经初始化了，若没有初始化需要先初始化root节点； 当一个key-value需要被插入BST树时，首先判断key与节点的大小，若key大于节点的key值继续搜寻节点的右子树，若key小于节点的key值则继续搜寻节点的左子节点，直到找到某个节点的左子节点或者右子节点为空时，将需要插入的key-value插入； 非递归实现： 12345678910111213141516171819202122232425262728293031323334353637public void add(k key, v value) &#123; Node root = getRoot(); if (root == null) &#123; //root还未初始化 setRoot(new Node(key, value)); &#125; else &#123; //root已经初始化 Node tmp = root; while (tmp != null) &#123; //BST树插入节点都是叶子节点 int com = tmp.getKey().compareTo(key); if (com == 0) &#123; //相等，替换value值并退出函数 tmp.setValue(value); return; &#125; else if (com &gt; 0) &#123; //比tmp小，找左节点 if (tmp.getLeft() == null) &#123; //如果左节点为空，即为要插入位置 tmp.setLeft(new Node(key, value)); &#125; else &#123; //如果不为空继续找左节点 tmp = tmp.getLeft(); &#125; &#125; else if (com &lt; 0) &#123; //比tmp大，找右节点 if (tmp.getRight() == null) tmp.setRight(new Node(key, value)); else tmp = tmp.getRight(); &#125; &#125; &#125;&#125; 递归实现： 123456789101112131415public Node add(Node node, k key, v value) &#123; if (node == null) &#123; return new Node(key, value); &#125; int com = node.getKey().compareTo(key); if (com == 0) &#123; node.setValue(value); return node; &#125; else if (com &gt; 0) &#123; node.setLeft(add(node.getLeft(), key, value)); &#125; else if (com &lt; 0) &#123; node.setRight(add(node.getRight(), key, value)); &#125; return node;&#125; 查找节点查找结点比较容易，首先判断根节点是否为空，若为空则返回空，不为空比较key与节点的key大小，若key大于节点的key则继续查找节点的右节点，若key小于节点的key则继续查找节点的左节点，当key等于节点的key值时代表找到了，返回value即可； 非递归实现： 12345678910111213141516171819202122232425public v get(k key) &#123; Node root = getRoot(); Node tmp = root; if (root == null) &#123; return null; &#125; else &#123; while (tmp != null) &#123; int com = tmp.getKey().compareTo(key); if (com == 0) &#123; //相等，找到并返回 return (v) tmp.getValue(); &#125; else if (com &gt; 0) &#123; //比tmp小，找左节点 tmp = tmp.getLeft(); &#125; else if (com &lt; 0) &#123; //比tmp大，找右节点 tmp = tmp.getRight(); &#125; &#125; //未找到 return null; &#125;&#125; 递归实现： 12345678910111213public Node get(Node node, k key) &#123; if (node == null) &#123; return null; &#125; int com = node.getKey().compareTo(key); if (com == 0) &#123; return node; &#125; else if (com &gt; 0) &#123; return get(node.getLeft(), key); &#125; else &#123; return get(node.getRight(), key); &#125;&#125; 删除节点删除节点相对较复杂，可分为如下几步： 首先找打需要删除节点和其父节点； 如果该节点为叶子节点，直接删除； 如果该节点只有左节点或者右节点，用该节点左节点或者右节点替代该节点； 如果该节点既有左节点又有右节点，用该节点右节点最小节点替代该节点并删除该节点右节点最小节点； 非递归实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public void del(k key) &#123; //1. 首先找打需要删除节点和其父节点 Node parent = getRoot(); Node delNode = parent; //记录删除节点是父节点的左子节点还是右子节点 boolean left = false; while (delNode != null) &#123; int com = delNode.getKey().compareTo(key); if (com == 0) &#123; //找到要删除节点，跳出循环 break; &#125; else if (com &gt; 0) &#123; //比tmp小，找左节点 parent = delNode; delNode = delNode.getLeft(); left = true; &#125; else if (com &lt; 0) &#123; //比tmp大找右节点 parent = delNode; delNode = delNode.getRight(); left = false; &#125; &#125; //跳出循环：1）找到要删除节点；2）没有找到，需要抛出异常 if (delNode == null || delNode.getKey().compareTo(key) != 0) throw new RuntimeException(\"要删除节点不存在！\"); //2. 如果该节点为叶子节点，直接删除 //3. 如果该节点只有左节点或者右节点，用该节点左节点或者右节点替代该节点 if (delNode.getRight() == null) &#123; if (left) parent.setLeft(delNode.getLeft()); else parent.setRight(delNode.getLeft()); &#125; else if (delNode.getLeft() == null) &#123; if (left) parent.setLeft(delNode.getRight()); else parent.setRight(delNode.getRight()); &#125; else &#123; //4. 如果该节点既有左节点又有右节点，用该节点右节点最小节点替代该节点并删除该节点右节点最小节点 Node min = getMin(delNode.getRight()); delNode.setKey(min.getKey()); delNode.setValue(min.getValue()); delNode.setRight(del(delNode.getRight(), (k) min.getKey())); &#125;&#125; 这里把查找某个节点的最小子节点封装起来了： 123456789101112/*** 查找某个节点下的最小子节点** @param node* @return*/private Node getMin(Node node) &#123; if (node.getLeft() == null) &#123; return node; &#125; return getMin(node.getLeft());&#125; 递归实现： 123456789101112131415161718192021222324252627public Node del(Node node, k key) &#123; if (node == null) &#123; return null; &#125; int com = node.getKey().compareTo(key); if (com == 0) &#123; //找到要删除的节点 //如果该节点为叶子节点，直接删除 //如果该节点只有左节点或者右节点，用该节点左节点或者右节点替代该节点 if (node.getLeft() == null) return node.getRight(); if (node.getRight() == null) return node.getLeft(); Node min = getMin(node.getRight()); node.setKey(min.getKey()); node.setValue(min.getValue()); node.setRight(del(node.getRight(), (k) min.getKey())); return node; &#125; else if (com &gt; 0) &#123; //找左节点 node.setLeft(del(node.getLeft(), key)); &#125; else &#123; //找右节点 node.setRight(del(node.getRight(), key)); &#125; return node;&#125; AVL树AVL树介绍AVL树是一种自平衡二叉查找树，在AVL树中任何节点的两个子树的高度最大差别为1，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下的时间复杂度都是O(log n)。 AVL树的平衡性与旋转如下图所示的一棵树任何节点的两个子树的高度最大差别不超过1，是一颗AVL树： 而对于这颗树而言，它的跟节点的左右子节点的高度差超过了1，所以不是一颗AVL树： 对于一个节点，当其为叶子节点时，其高度为0，当且为null时，高度为-1，所以我们可以封装一个获取节点高度的函数： 123456789/*** 获取节点高度** @param node* @return*/private int height(Node node) &#123; return node == null ? -1 : node.getHeight();&#125; 对于一个节点，其父节点的高度总是等于其左子节点与其右子节点最高高度加1； 而我们在插入和删除元素的时候总是会破坏一颗AVL树的平衡性的，对于被破坏了平衡性的AVL树需要通过旋转来维持它的平衡； 对于一个被破坏了平衡性的节点α而言，有四种旋转的方式： 符号描述 描述 旋转方式 LL 对α的左儿子的左子树进行一次插入 右旋 LR 对α的左儿子的右子树进行一次插入 先左旋再右旋 RL 对α的右儿子的左子树进行一次插入 先右旋再左旋 RR 对α的右儿子的右子树进行一次插入 左旋 LL右旋： 代码实现： 1234567891011121314/*** 右旋** @param node*/private Node rightRotate(Node node) &#123; Node left = node.getLeft(); node.setLeft(left.getRight()); left.setRight(node); //旋转完需要重新计算node的高度 node.setHeight(Math.max(height(node.getLeft()), height(node.getRight())) + 1); left.setHeight(Math.max(height(left.getLeft()), height(left.getRight())) + 1); return left;&#125; RR左旋： 代码实现： 1234567891011121314/*** 左旋** @param node*/private Node leftRotate(Node node) &#123; Node right = node.getRight(); node.setRight(right.getLeft()); right.setLeft(node); //旋转完需要重新计算node的高度 node.setHeight(Math.max(height(node.getLeft()), height(node.getRight())) + 1); right.setHeight(Math.max(height(right.getLeft()), height(right.getLeft())) + 1); return right;&#125; LR先左旋再右旋： 代码实现： 123456789/*** 先左旋再右旋** @param node*/private Node leftAndRightRotate(Node node) &#123; node.setLeft(leftRotate(node.getLeft())); return rightRotate(node);&#125; RL先右旋再左旋： 代码实现： 123456789/*** 先右旋再左旋** @param node*/private Node rightAndLeftRotate(Node node) &#123; node.setRight(rightRotate(node.getRight())); return leftRotate(node);&#125; 所以对于这四种情况，我们可以通过一个函数来解决： 12345678910111213141516171819202122232425/*** 调整节点** @param node* @param key* @return*/private Node adjust(Node node, k key) &#123; int balance = height(node.getLeft()) - height(node.getRight()); //LL if (balance &gt; 1 &amp;&amp; node.getKey().compareTo(key) &gt; 0) &#123; return rightRotate(node); //LR &#125; else if (balance &gt; 1 &amp;&amp; node.getLeft().getKey().compareTo(key) &lt; 0) &#123; return leftAndRightRotate(node); //RR &#125; else if (balance &lt; -1 &amp;&amp; node.getKey().compareTo(key) &lt; 0) &#123; return leftRotate(node); //RL &#125; else if (balance &lt; -1 &amp;&amp; node.getLeft().getKey().compareTo(key) &gt; 0) &#123; return rightAndLeftRotate(node); &#125; return node;&#125; AVL树实现添加节点添加节点可以再BST树递归实现的添加节点的代码基础上增加上旋转调整的代码来实现： 1234567891011121314151617181920212223public void add(k key, v value) &#123; setRoot(add(getRoot(), key, value));&#125;private Node add(Node node, k key, v value) &#123; if (node == null) &#123; return new Node(key, value); &#125; int com = node.getKey().compareTo(key); if (com == 0) &#123; node.setValue(value); return node; &#125; else if (com &gt; 0) &#123; //左子树 node.setLeft(add(node.getLeft(), key, value)); &#125; else if (com &lt; 0) &#123; //右子树 node.setRight(add(node.getRight(), key, value)); &#125; //调整高度 node.setHeight(Math.max(height(node.getLeft()), height(node.getRight())) + 1); return adjust(node, key);&#125; 查找节点查找节点的实现方式与BST树的查找方式完全一致，这里就不放代码了； 删除节点删除节点的思路与BST树删除节点思路一致，不同的是，在删除一个节点后，需要重新计算其高度，并且判断其是否平衡，当其不平衡时，需要重新调整，使其平衡；值得注意的是，在删除完该节点右节点最小节点后，也需要重新计算这个最小节点的高度以及判断是否平衡，若不平衡也需要重新调整，使其平衡； 123456789101112131415161718192021222324252627282930public void del(k key) &#123; setRoot(del(getRoot(), key));&#125;private Node del(Node node, k key) &#123; if (node == null) &#123; return null; &#125; int com = node.getKey().compareTo(key); if (com == 0) &#123; //找到要删除节点，删除 if (node.getLeft() == null) return node.getRight(); if (node.getRight() == null) return node.getLeft(); Node min = getMin(node.getRight()); node.setKey(min.getKey()); node.setValue(min.getValue()); node.setRight(del(node.getRight(), (k) min.getKey())); &#125; else if (com &gt; 0) &#123; //在左子树上 node.setLeft(del(node.getLeft(), key)); &#125; else &#123; //在右子树上 node.setRight(del(node.getRight(), key)); &#125; //调整高度 node.setHeight(Math.max(height(node.getLeft()), height(node.getRight())) + 1); return adjust(node, key);&#125; 本文图片素材源自网络，如有侵权请告知，本人删除。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://satra.tk/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://satra.tk/tags/数据结构与算法/"}]},{"title":"Java并发之线程池源码分析","slug":"Java并发之线程池源码分析","date":"2018-03-06T03:30:29.000Z","updated":"2018-04-19T06:47:33.225Z","comments":true,"path":"posts/44048/","link":"","permalink":"https://satra.tk/posts/44048/","excerpt":"为什么需要线程池操作系统中线程的实现有三种，一种是用户级线程，一种是内核支持线程，还有一种是前两种的组合方式。用户级线程是在用户空间实现的，而内核级线程是在OS内核空间实现的。JVM对于线程并没有明确的定义是用户线程还是内核线程，但Java常用的JVM HotSpot，它都是使用1:1线程模型即内核线程，线程的调度完全交给了操作系统内核；所以在HotSpot上创建线程需要操作系统从用户态切换到内核态，这个开销是巨大的。而Java的线程在使用完后就会被回收，而需要时又会被创建，所以通过将空闲线程管理起来成为线程池，当需要线程运行任务的时候就从线程池中拿线程，避免了线程的创建过程，提升效率。","text":"为什么需要线程池操作系统中线程的实现有三种，一种是用户级线程，一种是内核支持线程，还有一种是前两种的组合方式。用户级线程是在用户空间实现的，而内核级线程是在OS内核空间实现的。JVM对于线程并没有明确的定义是用户线程还是内核线程，但Java常用的JVM HotSpot，它都是使用1:1线程模型即内核线程，线程的调度完全交给了操作系统内核；所以在HotSpot上创建线程需要操作系统从用户态切换到内核态，这个开销是巨大的。而Java的线程在使用完后就会被回收，而需要时又会被创建，所以通过将空闲线程管理起来成为线程池，当需要线程运行任务的时候就从线程池中拿线程，避免了线程的创建过程，提升效率。 ExecutorJava对于线程池的实现依赖于Executor框架，Executor框架UML图： Executor接口： 1234public interface Executor &#123; void execute(Runnable command);&#125; Executor接口只提供了一个提交任务的方法; ExecutorService接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface ExecutorService extends Executor &#123; //关闭方法，调用后执行之前提交的任务，不再接受新的任务 void shutdown(); //暂停所有等待处理的任务并返回这些任务的列表 List&lt;Runnable&gt; shutdownNow(); //是否已经关闭 boolean isShutdown(); //关闭后所有任务是否都已完成 boolean isTerminated(); //在有关闭请求或者当前线程被中断时阻塞住直到完成执行 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; //提交一个Callable任务 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); //提交一个Runable任务，result要返回的结果 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); //提交一个任务 Future&lt;?&gt; submit(Runnable task); //执行所有给定的任务列表，当所有任务完成，返回保持任务状态和结果的Future列表 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; //执行给定的任务列表，当所有任务完成或超时期满时，返回保持任务状态和结果的Future列表 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; //执行给定的任务列表，如果某个任务已成功完成，则返回其结果 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; //执行给定的任务列表，如果在给定的超时期满前某个任务已成功完成，则返回其结果。 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; ExecutorService接口扩展自Executor，相比Executor它提供了线程池生命周期管理的方法和各种形式任务的提交方法； AbstractExecutorService抽象类实现了ExecutorService接口，为线程池提供了submit、invokeAny、invokeAll模板代码。 线程池实现类源码分析继承自AbstractExecutorService的类都是Java提供的线程池的具体实现类； ThreadPoolExecutorThreadPoolExecutor有五个内部类：AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy、Worker，其中AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy四个内部类实现了RejectedExecutionHandler接口为线程池的拒绝策略，当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略； AbortPolicy:丢弃任务并抛出RejectedExecutionException异常； CallerRunsPolicy：由调用线程处理该任务； DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）； DiscardPolicy：也是丢弃任务，但是不抛出异常； Worker主要维护线程运行的中断状态，Worker也实现了AQS类。 ThreadPoolExecutor有四个构造方法 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 构造函数参数意义： corePoolSize：线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程； maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize； keepAliveTime：线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用； unit：keepAliveTime的单位； workQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口； threadFactory：创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名； handler：线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务； 其他构造函数都是调用这个构造函数实现的： 12345678910111213141516171819202122232425262728public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);&#125; 一个任务通过 execute(Runnable)方法被添加到线程池。 execute方法： 123456789101112131415161718192021222324252627282930313233public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); //活动线程小于corePoolSize if (workerCountOf(c) &lt; corePoolSize) &#123; //直接启动新任务 if (addWorker(command, true)) //添加成功返回 return; c = ctl.get(); &#125; //活动线程大于等于corePoolSize //线程池处于RUNNING状态，且往等待队列添加Runnable成功 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //线程池处于非RUNNING状态，并且从workQueue移除成功 if (! isRunning(recheck) &amp;&amp; remove(command)) //执行拒绝策略 reject(command); //线程池处于RUNNING状态或者线程池处于非RUNNING状态但是任务移除失败 //活动线程数量等于0 else if (workerCountOf(recheck) == 0) //添加一个null任务 addWorker(null, false); &#125; //活动线程大于等于corePoolSize //线程池处于非RUNNING状态或者线程池处于RUNNING状态但是往等待队列添加Runnable失败 //尝试启动新任务失败 else if (!addWorker(command, false)) //执行拒绝策略 reject(command);&#125; ThreadPoolExecutor使用了一个ctl变量来存储线程池有效线程数量和线程池的状态； ctl变量： 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 使用ctl变量判断线程池有效线程数量和线程池状态方法： 123456789101112private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; ctl用一个32位int类型来存储有效线程数量和线程池状态，其中低29位存线程数，高3位存线程运行状态，所以线程池状态有如下五种： RUNNING：-536870912 SHUTDOWN：0 STOP：536870912 TIDYING：1073741824 TERMINATED：1610612736 这几个状态的意义： RUNNING：线程池正常运行，可以接受新的任务并处理队列中的任务； SHUTDOWN：不再接受新的任务，但是会执行队列中的任务； STOP：不再接受新任务，不处理队列中的任务； TIDYING：所有任务已经终止，workerCount为0时，线程池转换成TIDYING状态，将会运行terminated()方法； TERMINATED：terminated()方法已经运行完成； 启动新任务addWorker方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//firstTask：Runnable任务//core：是否需要重新检查workerCount是否小于corePoolSizeprivate boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //线程池非RUNNING状态 //线程池处于非SHUTDOWN状态并且firstTask不为空并且workQueue不为空 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) //返回失败 return false; //此时，线程池处于RUNNING状态或者SHUTDOWN状态 for (;;) &#123; //获取线程池运行线程数量 int wc = workerCountOf(c); //线程池运行线程数量大于线程池最大允许容量或者大于corePoolSize(maximumPoolSize) if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) //返回失败 return false; //原子变化workerCount if (compareAndIncrementWorkerCount(c)) //成功，跳出自旋 break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) //失败，重试 continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); //线程池处于运行状态或者处于SHUTDOWN状态且firstTask为空 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //将新的线程添加到线程池中 workers.add(w); int s = workers.size(); //更新largestPoolSize if (s &gt; largestPoolSize) largestPoolSize = s; //标记添加任务成功 workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; //任务添加成功时 if (workerAdded) &#123; //运行任务 t.start(); //标记任务在运行 workerStarted = true; &#125; &#125; &#125; finally &#123; //线程启动失败 if (! workerStarted) //从wokers中移除w并递减wokerCount addWorkerFailed(w); &#125; return workerStarted;&#125; 当new一个Worker实例的时候，Worker的构造函数通过调用ThreadFactory获得一个线程，并且保存在自己的成员变量thread中； 当添加任务成功后会调用Worker的thread的start()方法，通过另一个线程去执行Worker的run方法； Worker的run方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void run() &#123; runWorker(this);&#125;final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //Worker里的Runnable不为空或从workQueue队列获取Runnable不为空 while (task != null || (task = getTask()) != null) &#123; w.lock(); //线程池处于非RUNNING、SHUTDOWN状态且线程不是中断状态 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; //执行之前处理，由子类实现 beforeExecute(wt, task); Throwable thrown = null; try &#123; //执行 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; //执行之后处理，由子类实现 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; //线程结束后的一些清理工作 processWorkerExit(w, completedAbruptly); &#125;&#125; 从workQueue队列获取task方法getTask()： 123456789101112131415161718192021222324252627282930313233343536373839404142private Runnable getTask() &#123; boolean timedOut = false; //自旋 for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //线程池处于非RUNNING、SHUTDOWN状态并且线程池处于非STOP状态workQueue不为空 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; //递减workerCount值 decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); //标记从队列中取任务时是否允许超时 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //线程池线程总数量大于maximumPoolSize或者workQueue为空 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //workerCount递减，并返回空 if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; //当允许超时时从workQueue中超时获取task，当不允许超时时，直接从workQueue获取task Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 线程结束后清理方法processWorkerExit()： 12345678910111213141516171819202122232425262728293031323334353637private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; //runWorker正常允许完成后，已经完成了workerCount递减 if (completedAbruptly) decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; completedTaskCount += w.completedTasks; //从Worker集合中移除Worker workers.remove(w); &#125; finally &#123; mainLock.unlock(); &#125; //尝试停止线程池 tryTerminate(); int c = ctl.get(); //线程池状态为RUNNING或SHUTDOWN if (runStateLessThan(c, STOP)) &#123; //线程非异常退出 if (!completedAbruptly) &#123; //当允许coreThread超时时，线程池最小线程数量设置为0，当不允许时，线程池最小线程数量设置为corePoolSize int min = allowCoreThreadTimeOut ? 0 : corePoolSize; //最小线程数量为0且workQueue不为空 if (min == 0 &amp;&amp; ! workQueue.isEmpty()) //最小线程数置为1 min = 1; //线程池中线程数量大于min if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; //线程异常退出或者线程池为空，但是队列中还有任务没执行 addWorker(null, false); &#125;&#125; 尝试停止线程池方法tryTerminate()： 123456789101112131415161718192021222324252627282930313233343536373839404142final void tryTerminate() &#123; //自旋 for (;;) &#123; int c = ctl.get(); //线程池还在运行 //线程池处于RUNNING、SHUTDOWN、STOP状态 //线程池状态为SHUTDOWN但是workQueue不为空 //直接返回 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return; //当线程池状态为SHUTDOWN且workQueue为空时程序继续 //workerCount不为0则不能停止线程池，且此时线程都处于等待的状态 if (workerCountOf(c) != 0) &#123; //中断正在等待的线程 interruptIdleWorkers(ONLY_ONE); return; &#125; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //设置线程池状态为TIDYING状态 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; //执行terminated()方法，由子类实现 terminated(); &#125; finally &#123; //设置线程池状态为TERMINATED状态 ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125;&#125; 中断正在等待的线程方法interruptIdleWorkers()： 1234567891011121314151617181920212223//onlyOne：是否只中断一个线程private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //遍历workers集合中断 for (Worker w : workers) &#123; Thread t = w.thread; if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; w.unlock(); &#125; &#125; if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125;&#125; 线程池关闭shutdown()方法： 1234567891011121314151617public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //检查是否有权限关闭 checkShutdownAccess(); //设置线程池状态为SHUTDOWN advanceRunState(SHUTDOWN); //中断所有空闲线程 interruptIdleWorkers(); onShutdown(); &#125; finally &#123; mainLock.unlock(); &#125; //尝试停止线程池 tryTerminate();&#125; 线程池立即关闭方法shutdownNow()： 12345678910111213141516171819public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); //设置线程池状态为STOP advanceRunState(STOP); //与shutdown()不同，shutdownNow()执行interruptWorkers()方法，中断所有线程 interruptWorkers(); //返回队列中还没执行的任务 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; //尝试停止线程池 tryTerminate(); return tasks;&#125; 线程池工具类ExecutorsExecutors提供了一系列静态工厂方法用于创建各种线程池； 通过Executors Java提供四种线程池，分别为： newCachedThreadPool：创建一个可缓存线程池； newFixedThreadPool：创建一个定长线程池； newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行； newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行； newCachedThreadPool方法： 123456789101112public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory);&#125; newFixedThreadPool方法： 123456789101112public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125; newScheduledThreadPool方法： 12345678public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125; newSingleThreadExecutor方法： 1234567891011121314public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));&#125;","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之ThreadLocal源码分析","slug":"Java并发之ThreadLocal源码分析","date":"2018-02-20T08:21:13.000Z","updated":"2018-04-19T06:47:33.190Z","comments":true,"path":"posts/48867/","link":"","permalink":"https://satra.tk/posts/48867/","excerpt":"ThreadLocal介绍ThreadLocal是Java提供的一个线程局部变量的工具，虽说它是为线程服务，但是它并没有在Java的并发包里面，而是和Thread一样在java.lang包里，首先我们来看下ThreadLocal的基本用法。 一般情况下，我们需要一个成员变量，并且在线程里对成员变量修改，往往我们会这样写：","text":"ThreadLocal介绍ThreadLocal是Java提供的一个线程局部变量的工具，虽说它是为线程服务，但是它并没有在Java的并发包里面，而是和Thread一样在java.lang包里，首先我们来看下ThreadLocal的基本用法。 一般情况下，我们需要一个成员变量，并且在线程里对成员变量修改，往往我们会这样写： 123456789101112131415public class ThreadLocalDemo &#123; static String name = null; public static void main(String[] args) &#123; Runnable runnable = () -&gt; &#123; name = Thread.currentThread().getName(); System.out.println(name); &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); &#125;&#125; 然而，这样写会造成线程安全问题，我们运行的结果： 解决这种对于共享资源访问造成的线程安全问题，我们可以通过对共享资源访问的线程加锁很容易解决这里的线程安全问题。可是我们想追求性能上的“极致”，不想去用“重量级”的锁，有没有一种轻量级的实现方式呢？有，我们可以通过ThreadLocal很容易的实现： 1234567891011121314151617public class ThreadLocalDemo &#123; static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; Runnable runnable = () -&gt; &#123; String name = threadLocal.get(); if (null == name) &#123; threadLocal.set(Thread.currentThread().getName()); name = threadLocal.get(); &#125; System.out.println(name); &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); &#125;&#125; 结果： ThreadLocal源码分析ThreadLocal方法源码分析ThreadLocal只有一个空的构造函数，两个内部类：SuppliedThreadLocal、ThreadLocalMap。 首先来看下get()方法： 1234567891011121314151617public T get() &#123; Thread t = Thread.currentThread(); //获取当前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) &#123; //获取线程的ThreadLocalMap.Entry对象，key为当前ThreadLocal对象 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") //ThreadLocalMap.Entry不为空，取值 T result = (T)e.value; return result; &#125; &#125; //ThreadLocalMap.Entry为空或获取ThreadLocalMap为空，返回一个默认值 return setInitialValue();&#125; getMap()方法源码： 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; getMap()方法直接返回线程的threadLocals变量的值，而Thread对象里threadLocals变量是一个对ThreadLocal.ThreadLocalMap对象的引用，实质上每个线程的局部变量是存放在自己的ThreadLocalMap对象当中的，而ThreadLocalMap类是一个简化版的HashMap，稍后我们将介绍这个类。 Thread类中threadLocals变量声明： 1ThreadLocal.ThreadLocalMap threadLocals = null; setInitialValue()方法源码： 1234567891011121314private T setInitialValue() &#123; //获取默认值 T value = initialValue(); Thread t = Thread.currentThread(); //获取当前线程ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) //map不为空设置值 map.set(this, value); else //map为空，创建一个并设置值 createMap(t, value); return value;&#125; initialValue()方法可以自定义重写实现，默认initialValue()方法返回值为空。 为线程创建ThreadLocalMap方法createMap()源码： 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 接着看下set()方法的源码： 12345678910public void set(T value) &#123; Thread t = Thread.currentThread(); //获取线程的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) //以当前ThreadLocal对象做为key，存入ThreadLocalMap map.set(this, value); else createMap(t, value);&#125; ThreadLocal的get和set方法主要是获取线程的threadLocals(ThreadLocalMap)变量，然后对threadLocals(ThreadLocalMap)容器进行get和set操作。 ThreadLocalMap内部类ThreadLocalMap是一个简化版的HashMap，是ThreadLocal的内部类，ThreadLocalMap通过Entry数组存储数据： 1private Entry[] table; ThreadLocalMap构造函数： 123456789101112ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //创建一个Entry数组，INITIAL_CAPACITY为16，默认大小 table = new Entry[INITIAL_CAPACITY]; //key的hash值，计算方法：ThreadLocal对象的threadLocalHashCode与上数组长度减一 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); //在hash位置设置元素 table[i] = new Entry(firstKey, firstValue); //数组长度 size = 1; //设置扩容阈值，为数组长度的2/3 setThreshold(INITIAL_CAPACITY);&#125; ThreadLocal对象的threadLocalHashCode计算方法： 123456789private final int threadLocalHashCode = nextHashCode();private static final int HASH_INCREMENT = 0x61c88647;private static AtomicInteger nextHashCode = new AtomicInteger();private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; set方法Entry是ThreadLocalMap的一个内部类，ThreadLocalMap通过set设置数据。 set方法源码： 12345678910111213141516171819202122232425262728293031323334353637private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; //获取Entry数组 Entry[] tab = table; //Entry数组长度 int len = tab.length; //计算Hash值，计算方法为ThreadLocal的threadLocalHashCode与Entry长度做与运算 int i = key.threadLocalHashCode &amp; (len-1); //在i位置尝试设置值，当失败时会尝试调用nextIndex()方法计算下一个位置并再次尝试设置新值 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; //循环，获取Entry数组i位置元素的key ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; //如果当前线程的key已经存在在Entry数组中，直接为这个key设置值 e.value = value; return; &#125; //ThreadLocalMap引用使用的是弱引用，会带来一个问题是被GC回收了导致e.get()的key为空 if (k == null) &#123; //当出现e.get()为空时，找到一个key与传入相同的key设置新值或在指定位置设置新值 replaceStaleEntry(key, value, i); return; &#125; &#125; //i位置为null，在i位置创建新Entry tab[i] = new Entry(key, value); //新大小 int sz = ++size; //首先先清除无用数据，再判断容器大小是否超出阈值 if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) //超出阈值rehash rehash();&#125; set的逻辑是：首先计算需要存储新数据的位置i，当i位置为空时，直接在i位置new一个Entry放入数据；当i位置不为空时，取得i位置Entry元素，当Entry元素的key与需要存储元素key相等时直接设置此key位置的value为新值，当Entry元素的key为null时，需要清除key为null的Entry元素，当i位置key既不等于新元素key且i位置key不为空此时出现hash冲突，需要通过调用nextIndex()元素计算下一个位置并再次尝试。 replaceStaleEntry()源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; //往前找，找到table中第一个需要需要清理数据的下标 for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; //i位置出现key相等的，直接设置新值 e.value = value; //交换tab[i]位置元素与tab[staleSlot]元素 tab[i] = tab[staleSlot]; tab[staleSlot] = e; //table中第一个需要清理数据的下标等于需要插入数据位置下标 if (slotToExpunge == staleSlot) //由于交换了tab[i]位置元素与tab[staleSlot]元素，所以需要清理数据为i位置 slotToExpunge = i; //清理table cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; if (k == null &amp;&amp; slotToExpunge == staleSlot) //未出现key相等且table中第一个需要需要清理数据的下标等于插入新值位置下标 slotToExpunge = i; &#125; //将staleSlot位置entry元素value设置为null tab[staleSlot].value = null; //在staleSlot位置设置新值 tab[staleSlot] = new Entry(key, value); if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125; expungeStaleEntry()源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; //将staleSlot位置的value设置为null //table的staleSlot位置设置为null //大小减一 tab[staleSlot].value = null; tab[staleSlot] = null; size--; Entry e; int i; //循环遍历table数组 for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; //当出现key为空时 //将当前位置value设置为null //当前位置设置为null //数组大小减一 e.value = null; tab[i] = null; size--; &#125; else &#123; //当key不为null时，说明该元素有效 //由于数组大小可能发生改变，需要重新计算元素位置hash int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; //原位置置空 tab[i] = null; while (tab[h] != null) //当新位置不为空需要计算另一个位置 h = nextIndex(h, len); //设置元素 tab[h] = e; &#125; &#125; &#125; return i;&#125; cleanSomeSlots()方法源码： 123456789101112131415private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed;&#125; cleanSomeSlots()方法作用是遍历table数清理无用的元素。 get方法get方法再ThreadLocalMap里是getEntry，getEntry方法源码： 123456789101112private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; //获取到entry位置 int i = key.threadLocalHashCode &amp; (table.length - 1); //获取entry Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) //entry不为空并且entry的key为取值key，返回值 return e; else //entry为空或者entry的key不为取值key，返回null或value return getEntryAfterMiss(key, i, e);&#125; getEntryAfterMiss()方法： 123456789101112131415161718192021private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; //循环遍历entry数组 while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) //当key等于取值key时，返回value return e; if (k == null) //key为空，清除entry expungeStaleEntry(i); else //取下一个hash位置的entry i = nextIndex(i, len); e = tab[i]; &#125; //遍历完，未找到，返回null return null;&#125; 总结Thread中有一个引用指向其对象自己的ThreadLocalMap。ThreadLocal实现主要依赖其内部类ThreadLocalMap，ThreadLocalMap是一个简化版HashMap，其key为线程，value为需要存入的值。ThreadLocalMap的内部元素Entry继承自WeakReference，导致GC发生时，key会被垃圾收集器回收导致key为空，所以在每次set和get时会对table数组中key为null的元素进行清除以防止内存泄漏。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之Semaphore源码分析","slug":"Java并发之Semaphore源码分析","date":"2018-02-13T07:18:21.000Z","updated":"2018-04-19T06:47:33.183Z","comments":true,"path":"posts/34660/","link":"","permalink":"https://satra.tk/posts/34660/","excerpt":"Semaphore介绍Semaphore又叫做信号量，使用它可以限制同一时间访问同一资源的线程数量； 我们来看下Semaphore同步工具使用Demo：","text":"Semaphore介绍Semaphore又叫做信号量，使用它可以限制同一时间访问同一资源的线程数量； 我们来看下Semaphore同步工具使用Demo： 123456789101112131415161718192021public class SemaphoreDemo &#123; public static void main(String[] args) &#123; //只允许一个线程 Semaphore semaphore = new Semaphore(1); Runnable runnable = () -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(\"线程\" + Thread.currentThread().getName() + \"获得资源，运行中......\"); Thread.sleep(3000); System.out.println(\"线程\" + Thread.currentThread().getName() + \"释放资源，结束运行！\"); semaphore.release(); &#125; catch (InterruptedException e) &#123; return; &#125; &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); new Thread(runnable, \"T3\").start(); new Thread(runnable, \"T4\").start(); &#125;&#125; 在这个Demo中，实例化了一个参数为1的Semaphore对象，在Runnable里通过semaphore.acquire()方法尝试获取资源锁，由于在实例化Semaphore对象时，传入的参数为1，所以同一时刻只允许一个线程获得资源锁，在Runnable运行结束时，通过semaphore.release()方法释放资源锁。 程序运行结果： Semaphore源码分析Semaphore源码相较于CyclicBarrier复杂一点，与ReentrantLock的源码类似，有三个内部类，Sync、NonfairSync、FairSync，其中Sync类继承自AQS类，NonfairSync与FairSync类继承字Sync类。 与ReentrantLock一样，Semaphore也有两个构造函数： 123456789101112//permits：有效资源访问线程数public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;/* * permits：有效资源访问线程数 * fair：是否为公平锁*/public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; Semaphore构造函数中传入的有效资源访问线程数有趣的是它可以是正数和负数，当它为正数时，需要先获取锁(acquire)才能访问资源同一时间下仅能有正数个线程访问这一资源，而当其为负数时，需要先释放(release)锁才能访问资源。 首先来看下acquire()方法的源码： 12345678910111213141516171819//不带参数的acquire()方法public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;//带参数的重载acquire()方法public void acquire(int permits) throws InterruptedException &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.acquireSharedInterruptibly(permits);&#125;//AQS类acquireSharedInterruptibly()方法public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) //返回值小于0时 doAcquireSharedInterruptibly(arg);&#125; acquire()方法通过调用AQS类的acquireSharedInterruptibly()模板代码实现；在AQS类的分析中，我们已经分析过了acquireSharedInterruptibly()方法，acquireSharedInterruptibly()方法又会去调用子类的重写的tryAcquireShared()方法，在Semaphore类里面Sync类并没有重写tryAcquireShared()方法，而是交给了FairSync类和UnfairSync类去重写。 非公平锁中，tryAcquireShared()方法源码： 1234567891011121314151617protected int tryAcquireShared(int acquires) &#123; //调用父类的nonfairTryAcquireShared()方法 return nonfairTryAcquireShared(acquires);&#125;//Sync类的nonfairTryAcquireShared()方法final int nonfairTryAcquireShared(int acquires) &#123; //自旋 for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) //当新值小于0，或更新状态成功 return remaining; &#125;&#125; 在非公平锁中，tryAcquireShared通过父类nonfairTryAcquireShared方法实现，在nonfairTryAcquireShared方法中，获取AQS类的state变量值并计算新值，当新值大于等于0且更新新值成功则获取资源锁成功，否则会将该线程阻塞并放入等待队列中。 公平锁中，tryAcquireShared()方法源码： 1234567891011121314protected int tryAcquireShared(int acquires) &#123; //自旋 for (;;) &#123; //判断当前线程是否是阻塞队列队头线程 if (hasQueuedPredecessors()) //当前线程不是阻塞队列队头线程，返回-1 return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125; 在公平锁中tryAcquireShared方法与非公平锁的tryAcquireShared方法实现原理类似，不同的是，在非公平锁的tryAcquireShared方法中，首先会去判断当前线程是否是等待队列的队头线程，不是的话直接返回，将线程阻塞。 分析完加锁的源码，接着看下释放锁的源码： 12345678910111213141516171819public void release() &#123; //通过AQS类releaseShared方法实现 sync.releaseShared(1);&#125;//重载方法public void release(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.releaseShared(permits);&#125;//AQS类中releaseShared()方法：public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 在AQS类中releaseShared()方法通过子类重写的AQS类的tryReleaseShared()方法实现释放锁，tryReleaseShared()方法由Sync类实现，Sync重写tryReleaseShared()方法源码： 1234567891011121314protected final boolean tryReleaseShared(int releases) &#123; //自旋 for (;;) &#123; int current = getState(); int next = current + releases; //判断是否溢出 if (next &lt; current) // overflow throw new Error(\"Maximum permit count exceeded\"); //CAS刷新state值 if (compareAndSetState(current, next)) //返回释放成功 return true; &#125;&#125; 总结通过ReentrantLock源码与Semaphore源码的对比，发现二者的实现极为相似，ReentrantLock对象在构造时实际上同时构造出了一个state为0的AQS类(子类)，而Semaphore对象在构造时，同时构造出的AQS类(子类)的state值是由用户确定的；ReentrantLock在加锁时，当state从0变为1即加锁成功，其他线程再尝试加锁会阻塞，而Semaphore在尝试加锁时，会将state值减一(或指定值)，当state小于0或者更新state值失败时会加锁失败线程阻塞；ReentrantLock在释放锁时，会将state的值由1变成0，而Semaphore释放锁是简单的将state加一并刷新state值，成功则释放锁成功；二者均有公平锁和非公平锁之分。ReentrantLock在一定程度上可近似的认为是一个state值为1的Semaphore对象。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之CyclicBarrier源码分析","slug":"Java并发之CyclicBarrier","date":"2018-02-12T08:45:11.000Z","updated":"2018-04-19T06:47:33.153Z","comments":true,"path":"posts/31040/","link":"","permalink":"https://satra.tk/posts/31040/","excerpt":"CyclicBarrier介绍CyclicBarrier俗称屏障，使用它可以完成，让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。","text":"CyclicBarrier介绍CyclicBarrier俗称屏障，使用它可以完成，让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 我们来看下CyclicBarrier的具体使用： 123456789101112131415161718192021222324252627282930public class CyclicBarrierDemo &#123; private static int sleepTime = 0; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(4); Runnable runnable = () -&gt; &#123; try &#123; synchronized (CyclicBarrierDemo.class) &#123; sleepTime++; &#125; Thread.sleep(sleepTime * 1000); System.out.println(\"线程\" + Thread.currentThread().getName() + \"到达屏障点！\"); System.out.println(\"等待线程数：\" + cyclicBarrier.getNumberWaiting()); cyclicBarrier.await(); System.out.println(\"线程\" + Thread.currentThread().getName() + \"运行！\"); &#125; catch (InterruptedException e) &#123; return; &#125; catch (BrokenBarrierException e) &#123; return; &#125; &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); new Thread(runnable, \"T3\").start(); new Thread(runnable, \"T4\").start(); &#125;&#125; 上面这个示例程序只有在四个线程都运行了cyclicBarrier.await()后，每个线程才能继续往下执行。 运行结果： CyclicBarrier还有一个可传入一个Runnable的构造函数： 1public CyclicBarrier(int parties, Runnable barrierAction) 其作用是，当最后一个线程到达屏障时，由最后一个线程执行这个Runnable； Demo： 1234567891011121314151617181920212223242526272829303132public class CyclicBarrierDemo &#123; private static int sleepTime = 0; public static void main(String[] args) &#123; Runnable done = () -&gt; &#123; System.out.println(\"执行Runnable线程：\" + Thread.currentThread().getName()); &#125;; CyclicBarrier cyclicBarrier = new CyclicBarrier(4, done); Runnable runnable = () -&gt; &#123; try &#123; synchronized (CyclicBarrierDemo.class) &#123; sleepTime++; &#125; Thread.sleep(sleepTime * 1000); System.out.println(\"线程\" + Thread.currentThread().getName() + \"到达屏障点！\"); System.out.println(\"等待线程数：\" + cyclicBarrier.getNumberWaiting()); cyclicBarrier.await(); System.out.println(\"线程\" + Thread.currentThread().getName() + \"运行！\"); &#125; catch (InterruptedException e) &#123; return; &#125; catch (BrokenBarrierException e) &#123; return; &#125; &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); new Thread(runnable, \"T3\").start(); new Thread(runnable, \"T4\").start(); &#125;&#125; 结果： CyclicBarrier源码分析CyclicBarrier借助ReentrantLock实现，CyclicBarrier有两个构造函数，一个内部类Generation，Generation内部类中就一个成员变量broken，CyclicBarrier通过Generation标志线程是否被打断，同时一个线程组一个Generation对象。 Generation对象源码： 123private static class Generation &#123; boolean broken = false;&#125; await()源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125;//dowait()源码：//timed：是否有超时设置；//nanos：超时时长private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; //获取Generation对象 final Generation g = generation; if (g.broken) //如果线程已经被打断，抛出异常 throw new BrokenBarrierException(); if (Thread.interrupted()) &#123; //线程收到中断信号，设置中断标志为true，并唤醒所有线程 breakBarrier(); throw new InterruptedException(); &#125; int index = --count; //当count为0时 if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) //当存在Runnable任务时，使用这最后一个线程先行执行Runnable任务 command.run(); //标志Runnable执行完成 ranAction = true; //唤醒所有线程，重置count计数器和Generation对象 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) //若为执行完Runnable任务则设置中断标志为true，并唤醒所有线程 breakBarrier(); &#125; &#125; //自旋 for (;;) &#123; try &#123; if (!timed) //无超时设置，调用ReentrantLock的await()方法使线程处于等待状态 trip.await(); else if (nanos &gt; 0L) //存在超时设置，并超时时长大于0，调用ReentrantLock的awaitNanos()方法使线程处于超时等待状态 nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; Thread.currentThread().interrupt(); &#125; &#125; if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; await()重载方法源码： 1234567public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; //调用dowait方法传入超时参数实现 return dowait(true, unit.toNanos(timeout));&#125; 总结CyclicBarrier工具类的实现主要靠对ReentrantLock的封装实现，使用了一个内部类来标识线程是否被中断；其核心方法是在同步代码里使用ReentrantLock的await()方法和awaitNanos()方法实现。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之CountDownLatch源码分析","slug":"Java并发之CountDownLatch源码分析","date":"2018-02-10T06:12:16.000Z","updated":"2018-04-19T06:47:33.146Z","comments":true,"path":"posts/3981/","link":"","permalink":"https://satra.tk/posts/3981/","excerpt":"CountDownLatch介绍CountDownLatch俗称门闩，利用它可以实现类似计数器的功能。比如有一个任务，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。","text":"CountDownLatch介绍CountDownLatch俗称门闩，利用它可以实现类似计数器的功能。比如有一个任务，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。 我们使用CountDownLatch来实现这个功能： 123456789101112131415161718192021222324252627282930313233public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(4); Thread mainThread = Thread.currentThread(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep((long) (Math.random() * 1000)); System.out.println(Thread.currentThread().getName() + \", main thread status: \" + mainThread.getState()); countDownLatch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread t1 = new Thread(runnable, \"T1\"); Thread t2 = new Thread(runnable, \"T2\"); Thread t3 = new Thread(runnable, \"T3\"); Thread t4 = new Thread(runnable, \"T4\"); t1.start(); t2.start(); t3.start(); t4.start(); countDownLatch.await(); System.out.println(\"main end.\"); &#125;&#125; 运行结果： CountDownLatch源码分析首先看下CountDownLatch的构造方法： 12345public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); //Sync是CountDownLatch的一个内部类 this.sync = new Sync(count);&#125; CountDownLatch里有一个内部类，继承自AQS类； new CountDownLatch时传入一个int类型数值，构造函数执行时，将CountDownLatch类的内部类Sync实例化并且将传入的数值传给Sync类，Sync类构造方法： 123Sync(int count) &#123; setState(count);&#125; Sync调用其父类AQS的方法将Stats设置为传入值；CountDownLatch同步方法的实现依赖于Sync类，而Sync类通过继承AQS类； 我们来看下CountDownLatch的两个主要的方法await()和countDown()的源码，countDown()的源码: 123456789101112131415161718192021222324252627282930public void countDown() &#123; //调用AQS类的releaseShared()方法 sync.releaseShared(1);&#125;//AQS类releaseShared()方法,releaseShared方法调用子类实现的tryReleaseShared()方法public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;//Sync类实现的父类tryReleaseShared()方法protected boolean tryReleaseShared(int releases) &#123; //自旋，确保成功 for (;;) &#123; //获取state int c = getState(); if (c == 0) //为0，count down失败 return false; //减一得到新值 int nextc = c-1; //更新 if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; await()的源码： 1234public void await() throws InterruptedException &#123; //调用AQS类acquireSharedInterruptibly方法 sync.acquireSharedInterruptibly(1);&#125; 12345678910111213public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); //tryAcquireShared()方法由子类实现 if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125;//Sync类tryAcquireShared()方法protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; await()还有一个有参数的重载方法： 1234public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));&#125; 总结CountDownLatch方法的实现主要依赖于其内部类Sync，而Sync继承自AQS类，在AQS类的分析中，我们就已经介绍过了AQS类的模板代码；CountDownLatch的实现源自对AQS类的灵活运用。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之原子类源码分析(以AtomicInteger为例)","slug":"Java并发之原子类源码分析-以AtomicInteger为例","date":"2018-02-09T05:35:51.000Z","updated":"2018-04-19T06:47:33.199Z","comments":true,"path":"posts/15821/","link":"","permalink":"https://satra.tk/posts/15821/","excerpt":"什么是原子类在我之前的博客文章中介绍了JVM的内存模型，JVM内存模型规定了对一个变量的操作分为八步，这八步分别是：Lock（锁定）、unlock(解锁)、read（读取）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入）；也就是说，对于一个数的操作是分为八步完成的，即对一个数的操作不是一个原子操作，如：i++，在代码层面就一行代码，看似是原子操作，实际上在指令层面并不是一步完成的，而是多部完成的。这就造成了对于变量操作的线程安全问题。","text":"什么是原子类在我之前的博客文章中介绍了JVM的内存模型，JVM内存模型规定了对一个变量的操作分为八步，这八步分别是：Lock（锁定）、unlock(解锁)、read（读取）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入）；也就是说，对于一个数的操作是分为八步完成的，即对一个数的操作不是一个原子操作，如：i++，在代码层面就一行代码，看似是原子操作，实际上在指令层面并不是一步完成的，而是多部完成的。这就造成了对于变量操作的线程安全问题。 要解决这个问题很简单，我们可以使用我们之前学习的知识，利用锁来解决，但是一个简单的操作，配上锁，显得有点太过于“重量级”了；那么有没有一种不使用锁又可以实现变量操作的原子性呢？答案是有，这个方法就是我们今天说的原子类。原子类就是指通过这个类对一个变量的操作都是原子性的，操作不可分割，这样就保证了变量操作的线程安全性。 Java的原子类位于java.util.concurrent.atomic包下 AtomicInteger类源码解析使用原子类就可以很简单的实现对一个变量的原子操作，原子类的实现原理都差不多，通过调用Unsafe类的方法使用CAS算法得以实现原子类，以AtomicInteger为例，我们来看下AtomicInteger类提供给我们的几个主要方法的源码； AtomicInteger有三个成员变量： 1234private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;private volatile int value; 其中value是用来保存值的，由于AtomicInteger类的原子操作是依赖于Unsafe实现的，所以AtomicInteger类成员变量unsafe保存了Unsafe类的实例对象，valueOffset是value变量在内存里的偏移量。 构造方法： 12345public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; public AtomicInteger() &#123; &#125; 有参数构造方法传入一个int类型数据，在构造时就已经初始化了value变量。 获取value值： 12345678//获取value值public final int get() &#123; return value;&#125;//重新设置value值public final void set(int newValue) &#123; value = newValue;&#125; getAndSet方法： 123public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue);&#125; 调用Unsafe类本地方法实现，先返回当前值，然后设置为新值； compareAndSet方法： 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; compareAndSet方法给value使用CAS算法设置一个指定的值，需要传入预期值和设置的新值； 其他的一些主要方法： 1234567891011121314151617181920212223242526272829//获取值并加一public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;//获取值并减一public final int getAndDecrement() &#123; return unsafe.getAndAddInt(this, valueOffset, -1);&#125;//获取值并增加指定值public final int getAndAdd(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta);&#125;//加一再获取值public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;//减一再获取值public final int decrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, -1) - 1;&#125;//加指定值再获取值public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta;&#125; 总结原子类的实现基本都是通过调用Unsafe类的方法实现的，我们可以自己获取到Unsafe类的实例来实现一个我们自己的原子类。CAS算法是保证原子类操作原子性的重要依据。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之ReentrantReadWriteLock源码分析","slug":"Java并发之ReentrantReadWriteLock源码分析","date":"2018-02-08T02:55:42.000Z","updated":"2018-04-19T06:47:33.174Z","comments":true,"path":"posts/48223/","link":"","permalink":"https://satra.tk/posts/48223/","excerpt":"ReadWriteLockReadWriteLock是一个读写锁接口，所谓读写锁，是对访问资源共享锁和互斥锁，一般的重入性语义为如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。","text":"ReadWriteLockReadWriteLock是一个读写锁接口，所谓读写锁，是对访问资源共享锁和互斥锁，一般的重入性语义为如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。 ReadWriteLock接口中定义了两个方法： 123456public interface ReadWriteLock &#123; Lock readLock(); Lock writeLock();&#125; ReentrantReadWriteLock源码分析ReentrantReadWriteLock实现了ReadWriteLock接口和Serializable接口： 123public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable &#123; ......&#125; 构造方法： 12345678910111213public ReentrantReadWriteLock() &#123; //调用有参数构造方法实现 this(false);&#125;public ReentrantReadWriteLock(boolean fair) &#123; //是否是公平锁 sync = fair ? new FairSync() : new NonfairSync(); //读锁 readerLock = new ReadLock(this); //写锁 writerLock = new WriteLock(this);&#125; 默认情况下，ReentrantReadWriteLock为非公平锁。 ReentrantReadWriteLock中有五个内部类，分别是：ReadLock、WriteLock、FairSync、NonfairSync、Sync，其中Sync继承自AQS类，FairSync、NonfairSync继承自Sync类。 ReentrantReadWriteLock读写锁同步状态通过一个整型位来表示状态，高16位表是读状态，低16位表是写状态； 12345678static final int SHARED_SHIFT = 16;static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;//返回共享锁数量static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;//返回独占锁数static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; 读锁lock我们先看下读锁，读锁的lock方法源码： 1234public void lock() &#123; //调用AQS类acquireShared方法 sync.acquireShared(1);&#125; AQS类中acquireShared源码： 123456public final void acquireShared(int arg) &#123; //尝试加锁 if (tryAcquireShared(arg) &lt; 0) //加锁失败，阻塞住 doAcquireShared(arg);&#125; 在之前的文章中分析AQS类我们说过tryAcquireShared方法在AQS类中是无法直接调用的，Sync类中实现了tryAcquireShared方法，源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647protected final int tryAcquireShared(int unused) &#123; //获取当前线程 Thread current = Thread.currentThread(); //获取线程同步状态 int c = getState(); //计算写锁是否为0并且当不为0时判断持锁线程是否为当前线程 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) //存在写锁，并且写锁持有者不为当前线程，加锁失败 return -1; //没有线程持有写锁，获取持有读锁数 int r = sharedCount(c); //readerShouldBlock():读锁是否需要等待，r &lt; MAX_COUNT：持有线程小于最大数（65535），compareAndSetState(c, c + SHARED_UNIT)：设置读取锁状态 if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; //持有读锁数为0 if (r == 0) &#123; //获取读锁的第一个线程设置为当前线程 firstReader = current; //firstReader持有读锁数量为1 firstReaderHoldCount = 1; //持有读锁数不为0，且持有读锁线程为当前线程 &#125; else if (firstReader == current) &#123; //将firstReader持有读锁数量加1 firstReaderHoldCount++; //持有读锁数不为0，且持有线程不为当前线程 &#125; else &#123; //获取HoldCounter HoldCounter rh = cachedHoldCounter; //HoldCounter为空，或者获取的HoldCounter不是当前线程的HoldCounter if (rh == null || rh.tid != getThreadId(current)) //重新获取HoldCounter并设置rh和cachedHoldCounter cachedHoldCounter = rh = readHolds.get(); //rh不为空，且rh的值为0 else if (rh.count == 0) //设置线程自有的HoldCounter readHolds.set(rh); //持有读锁加1 rh.count++; &#125; //成功加锁 return 1; &#125; //自旋尝试加锁 return fullTryAcquireShared(current);&#125; readerShouldBlock()在Sync中定义为抽象类，由子类FairSync或NonfairSync实现； 对于FairSync中readerShouldBlock方法： 1234567891011121314final boolean readerShouldBlock() &#123; //调用AQS类hasQueuedPredecessors实现 return hasQueuedPredecessors();&#125;//AQS类hasQueuedPredecessors方法public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; //判断队头线程是否为当前线程，是的话返回false，否则返回true return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 对于NonfairSync中的readerShouldBlock方法： 1234567891011121314final boolean readerShouldBlock() &#123; //调用AQS类中apparentlyFirstQueuedIsExclusive实现 return apparentlyFirstQueuedIsExclusive();&#125;//AQS类apparentlyFirstQueuedIsExclusive方法final boolean apparentlyFirstQueuedIsExclusive() &#123; Node h, s; //链表头不为空，当前运行线程不为空，运行线程为独占模式返回true，否则返回false return (h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp; !s.isShared() &amp;&amp; s.thread != null;&#125; 在Sync类中，还有两个内部类，分别是：HoldCounter、ThreadLocalHoldCounter，HoldCounter类有两个成员变量：count和tid，其中count是用来计数线程持有锁的数量而tid是通过一个线程的id来标志是哪个线程的HoldCounter，HoldCounter保存在每个线程的ThreadLocal中；ThreadLocalHoldCounter是ThreadLocal的子类用于维护每个线程自己的HoldCounter。 unLock读锁中unLock源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void unlock() &#123; //调用AQS类实现 sync.releaseShared(1);&#125;//AQS类releaseShared方法public final boolean releaseShared(int arg) &#123; //尝试释放锁，交由子类实现 if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;//Sync类中tryReleaseShared方法protected final boolean tryReleaseShared(int unused) &#123; //获取当前线程 Thread current = Thread.currentThread(); //判断持有读锁线程是否为当前线程 if (firstReader == current) &#123; //判断持有读锁数量是否为1 if (firstReaderHoldCount == 1) //为1，置空firstReader firstReader = null; else //不为1，将该线程持有锁数量减1 firstReaderHoldCount--; //持有锁线程不为当前线程 &#125; else &#123; //获取到该线程的HoldCounter HoldCounter rh = cachedHoldCounter; //判断HoldCounter是否为空，且是否为该线程的HoldCounter if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); //获取该线程持有的锁数量 int count = rh.count; //判断是否小于1 if (count &lt;= 1) &#123; readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); &#125; //将持有锁数量减1 --rh.count; &#125; //自旋确保成功 for (;;) &#123; //获取状态 int c = getState(); //更新状态值 int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 当执行tryReleaseShared返回true后执行doReleaseShared方法，doReleaseShared方法的源码我们在AQS类分析的时候已经讲过了，故此不再赘述。 写锁lock写锁中的lock源码：123456789101112public void lock() &#123; //调用AQS类实现 sync.acquire(1);&#125;//AQS类中acquire方法public final void acquire(int arg) &#123; //tryAcquire由子类实现 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法在AQS类分析的时候已经分析过了。 我们来看下子类Sync中实现的tryAcquire方法： 123456789101112131415161718192021222324252627282930protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); //获取线程状态 int c = getState(); //获取写锁数量 int w = exclusiveCount(c); if (c != 0) &#123; //有线程持有写锁，且不是当前线程 if (w == 0 || current != getExclusiveOwnerThread()) //加锁失败 return false; //判断是否超过最大值 if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); // Reentrant acquire //CAS更新持锁线程数量 setState(c + acquires); //加锁成功 return true; &#125; //没有线程持有写锁，判断是否应该阻塞该线程并尝试更新持锁线程数量 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) //应该阻塞，或者更新持锁线程数量失败 return false; //成功，设置运行线程为当前线程 setExclusiveOwnerThread(current); //加锁成功 return true;&#125; writerShouldBlock方法分公平锁与非公平锁实现； 先来看下非公平锁实现： 123final boolean writerShouldBlock() &#123; return false; // writers can always barge&#125; 公平锁writerShouldBlock实现： 1234final boolean writerShouldBlock() &#123; //调用AQS实现，hasQueuedPredecessors方法在前面已经讲述 return hasQueuedPredecessors();&#125; unLock123456789101112131415161718public void unlock() &#123; //调用AQS的release方法实现 sync.release(1);&#125;//AQS中release实现public final boolean release(int arg) &#123; //调用子类tryRelease方法 if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) //将头节点解锁，并释放头节点 unparkSuccessor(h); //解锁成功 return true; &#125; return false;&#125; tryRelease在AQS子类Sync中实现： 1234567891011121314protected final boolean tryRelease(int releases) &#123; //判断是否是当前线程执行unLock if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int nextc = getState() - releases; //判断读锁数量是否应该为0 boolean free = exclusiveCount(nextc) == 0; if (free) //为0，置空当前执行线程 setExclusiveOwnerThread(null); //更新线程持有写锁数量 setState(nextc); return free;&#125; 锁降级锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这个过程是不能被称为锁降级的。锁降级是指把当前拥有的写锁，再获取到读锁，随后释放写锁的过程。 ReentrantReadWriteLock不支持锁升级（持有读锁，获取写锁，最后释放读锁的过程），目的也是为了数据可见性，如果读锁已经被多个线程获取，其中任意线程成功获取了写锁并且更新了数据，这个更新对其他已经获取到读锁的线程是不可见的。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"七种常用排序算法介绍","slug":"七种常用排序算法介绍","date":"2018-02-07T07:11:35.000Z","updated":"2018-04-19T06:47:33.309Z","comments":true,"path":"posts/9680/","link":"","permalink":"https://satra.tk/posts/9680/","excerpt":"介绍排序算法是指将一串乱序数据按照一定规则进行排列的算法；虽然排序是一个很简单的问题，但是对于排序算法的研究已经进行很多年；排序研究至今已经诞生了很多种排序算法了，而最常用常见的排序算法有七种，分别是：选择排序、插入排序、希尔排序、冒泡排序、归并排序、快速排序和堆排序。 很多其他的算法思想都源自基本排序算法，通过学习研究基本的排序算法，能有助于我们理解掌握基本排序算法衍生出来的其他算法。","text":"介绍排序算法是指将一串乱序数据按照一定规则进行排列的算法；虽然排序是一个很简单的问题，但是对于排序算法的研究已经进行很多年；排序研究至今已经诞生了很多种排序算法了，而最常用常见的排序算法有七种，分别是：选择排序、插入排序、希尔排序、冒泡排序、归并排序、快速排序和堆排序。 很多其他的算法思想都源自基本排序算法，通过学习研究基本的排序算法，能有助于我们理解掌握基本排序算法衍生出来的其他算法。 选择排序选择排序思想：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 图解(图片来自维基百科)： Java实现选择排序： 123456789101112131415161718public static void sort(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; for (int i = 0, l = array.length; i &lt; l; i++) &#123; int min = array[i]; int index = i; for (int j = i; j &lt; l; j++) &#123; if (min &gt; array[j]) &#123; min = array[j]; index = j; &#125; &#125; array[index] = array[i]; array[i] = min; &#125;&#125; 插入排序插入排序思想： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 图解(图片来自维基百科)： Java实现插入排序： 1234567891011121314public static void sort(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; for (int i = 1, l = array.length; i &lt; l; i++) &#123; int j = i; int insert = array[i]; while (j &gt; 0 &amp;&amp; insert &lt; array[j - 1]) &#123; array[j] = array[j - 1]; j--; &#125; array[j] = insert; &#125;&#125; 希尔排序希尔排序思想： 先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序； 然后取 d2(d2 &lt; d1)； 重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。 图解(图片来自维基百科)： Java实现希尔排序： 12345678910111213141516public static void sort(int[] array) &#123; int d = array.length; int length = array.length; while (d != 1) &#123; d = d / 2; for (int i = d; i &lt; length; i++) &#123; int tmp = array[i]; int j = i - d; while (j &gt;= 0 &amp;&amp; array[j] &lt; tmp) &#123; array[j + d] = array[j]; j = j - d; &#125; array[j + d] = tmp; &#125; &#125;&#125; 冒泡排序冒泡排序思想： 比较相邻的元素。 如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。 在这一点，最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 图解(图片来自维基百科)： Java实现冒泡排序： 123456789101112131415public static void sort(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; for (int i = 0, l = array.length; i &lt; l; i++) &#123; for (int j = 1; j &lt; l - i; j++) &#123; if (array[j] &lt; array[j - 1]) &#123; int tmp = array[j - 1]; array[j - 1] = array[j]; array[j] = tmp; &#125; &#125; &#125;&#125; 冒泡排序不管数列是否有序，它都要一直循环下去，我们可以给这个算法加一个标志位，标志是否交换过，当没有发生交换时，证明此时数列已经是有序的了，无需再循环； 改进版冒泡排序： 123456789101112131415161718public static void sort(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; boolean isSwap = true; // 交换标志，当没发生交换时说明数组已经有序，可以跳出循环 for (int i = 0, l = array.length; i &lt; l &amp;&amp; isSwap; i++) &#123; isSwap = false; for (int j = 1; j &lt; l - i; j++) &#123; if (array[j] &lt; array[j - 1]) &#123; int tmp = array[j - 1]; array[j - 1] = array[j]; array[j] = tmp; isSwap = true; &#125; &#125; &#125;&#125; 归并排序归并排序思想： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤3直到某一指针到达序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 图解(图片来自维基百科)： Java实现归并排序： 123456789101112131415161718192021222324252627282930313233public static void sort(int[] array, int l, int m, int r) &#123; if (l == r) &#123; return; &#125; sort(array, l, (m + l) / 2, m); sort(array, m + 1, (r + m + 1) / 2, r); int[] tmp = new int[r - l + 1]; int i = l; int j = m + 1; int k = 0; while (i &lt;= m &amp;&amp; j &lt;= r) &#123; if (array[i] &lt; array[j]) &#123; tmp[k++] = array[i++]; &#125; else &#123; tmp[k++] = array[j++]; &#125; &#125; while (i &lt;= m) &#123; tmp[k++] = array[i++]; &#125; while (j &lt;= r) &#123; tmp[k++] = array[j++]; &#125; for (int x = l, y = 0, len = tmp.length; y &lt; len; x++, y++) &#123; array[x] = tmp[y]; &#125;&#125; 快速排序快速排序思想： 从数列中挑出一个元素，称为”基准”； 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作； 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 图解(图片来自维基百科)： Java实现快速排序： 1234567891011121314151617181920212223public static void sort(int[] array, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int key = array[start]; int l = start; int h = end; while (l &lt; h) &#123; while (l &lt; h &amp;&amp; array[h] &gt;= key) &#123; h--; &#125; array[l] = array[h]; while (l &lt; h &amp;&amp; array[l] &lt;= key) &#123; l++; &#125; array[h] = array[l]; &#125; array[l] = key; sort(array, start, l - 1); sort(array, l + 1, end);&#125; 堆排序堆排序思想： 最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点； 创建最大堆：将堆所有数据重新排序； 堆排序：移除位在第一个数据的根节点，并做最大堆调整的递归运算。 堆节点关系：父节点i的左子节点在位置：(2i+1);父节点i的右子节点在位置：(2i+2); 图解(图片来自维基百科)： 12345678910111213141516171819202122232425262728293031323334353637383940public static void sort(int[] array) &#123; for (int i = 0, l = array.length; i &lt; l; i++) &#123; createHeap(array, l - i); int tmp = array[l - i - 1]; array[l - i - 1] = array[0]; array[0] = tmp; &#125;&#125;//创建大根堆private static void createHeap(int[] array, int size) &#123; for (int i = size / 2; i &gt;= 0; i--) &#123; adjust(array, i, size); print(array); &#125;&#125;//调整private static void adjust(int[] array, int position, int size) &#123; //左节点位置 int left = 2 * position + 1; //右节点位置 int right = 2 * position + 2; //左子节点大 if (left &lt; size &amp;&amp; array[position] &lt; array[left]) &#123; //交换 int tmp = array[left]; array[left] = array[position]; array[position] = tmp; adjust(array, left, size); &#125; //右子节点大 if (right &lt; size &amp;&amp; array[position] &lt; array[right]) &#123; int tmp = array[right]; array[right] = array[position]; array[position] = tmp; adjust(array, right, size); &#125;&#125; 总结最后总结下这七大排序算法的时间复杂度、空间复杂度和稳定性；以下是维基百科对时间复杂度、空间复杂度和稳定性的定义： 算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。空间复杂度是指计算机科学领域完成一个算法所需要占用的存储空间，一般是输入参数的函数。它是算法优劣的重要度量指标，一般来说，空间复杂度越小，算法越好。稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 排序方法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 选择排序 O(n^2) O(n^2) O(n^2) O(1) 稳定 插入排序 O(n^2) O(n) O(n^2) O(1) 稳定 希尔排序 O(nlogn)~O(n^2) O(n^1.3) O(n^2) O(1) 不稳定 冒泡排序 O(n^2) O(n) O(n^2) O(1) 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 快速排序 O(nlogn) O(nlogn) O(n^2) O(logn)~O(n) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://satra.tk/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://satra.tk/tags/数据结构与算法/"}]},{"title":"Java并发之ReentrantLock源码分析","slug":"Java并发之ReentrantLock源码分析","date":"2018-02-05T11:10:26.000Z","updated":"2018-04-19T06:47:33.161Z","comments":true,"path":"posts/14861/","link":"","permalink":"https://satra.tk/posts/14861/","excerpt":"Lock介绍Lock在Java中是一个接口，在这个接口中仅仅定义了6个方法： 1234567891011121314public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125;","text":"Lock介绍Lock在Java中是一个接口，在这个接口中仅仅定义了6个方法： 1234567891011121314public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; 实现了Lock接口的类有：ReentrantLock、ReentrantReadWriteLock(ReentrantReadWriteLock实际上是实现了ReadWriteLock，但是其内部类ReadLock和WriteLock实现了Lock接口) 我们这里讲的是ReentrantLock，ReentrantLock是一个实现了Lock接口的可重入锁，它具有与使用synchronized修饰的语句一样的功能，具有同步的作用；同时ReentrantLock具有可重入的特性。 ReentrantLock源码分析我们来看下ReentrantLock的源码，ReentrantLock实现了Lock接口和Serializable接口： 123public class ReentrantLock implements Lock, java.io.Serializable &#123; ......&#125; 构造方法，ReentrantLock有两个构造方法： 12345678public ReentrantLock() &#123; sync = new NonfairSync(); &#125;public ReentrantLock(boolean fair) &#123; //是否为公平锁 sync = fair ? new FairSync() : new NonfairSync();&#125; 有参数的构造方法参数是标志这个lock的所是否为公平锁，默认情况下ReentrantLock为非公平锁。 ReentrantLock中有三个内部类：Sync、NonfairSync、FairSync；NonfairSync和FairSync类是Sync的子类，而Sync继承自AbstractQueuedSynchronizer抽象类，Java中的两个lock和部分并发容器都是基于AQS实现的。 然后我们来看下ReentrantLock的lock()方法的源代码： 123public void lock() &#123; sync.lock();&#125; Sync中的lock方法是个抽象方法，并没有实现，具体的实现交由子类实现；Sync中的lock方法： 1abstract void lock(); 公平锁lock()方法直接调用sync.lock()实现的，而sync变量在实例化ReentrantLock时实例化了，对于公平锁的lock： 123final void lock() &#123; acquire(1);&#125; 直接调用AbstractQueuedSynchronizer的acquire()方法，AbstractQueuedSynchronizer的acquire()方法的实现如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 公平锁中重了写父类的tryAcquire()： 1234567891011121314151617181920212223242526272829protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); //获取线程状态 int c = getState(); //没有线程处于运行状态 if (c == 0) &#123; //判断是否处于等待队列最前面，并且尝试刷新加锁状态 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; //设置运行线程为当前线程 setExclusiveOwnerThread(current); //加锁成功 return true; &#125; &#125; //有线程在运行，判断运行线程是否为当前线程，为可重入锁准备 else if (current == getExclusiveOwnerThread()) &#123; //加了多少个锁 int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); //更新状态 setState(nextc); //加锁成功 return true; &#125; //加锁失败 return false; &#125; 首先判断当前线程是否在队列队头或者线程队列是否为空并且可以将线程状态设置为acquires的值，则将当前运行线程设置为当前线程并返回true，加锁成功，否则判断当前正在执行的线程是不是当前线程，是的话，将线程持有锁加一(锁的可重入)并返回true，加锁成功，以上情况都不满足，加锁失败。 当加锁失败时，执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，addWaiter方法将当前线程使用指定模式添加至等待节点，Node.EXCLUSIVE为独占模式，Node.SHARED为共享模式。 当加锁失败，并且将等待线程添加至等待链表后，执行acquireQueued()方法。 非公平锁对于非公平锁的lock: 123456789final void lock() &#123; //持有0个锁，直接尝试加锁 if (compareAndSetState(0, 1)) //成功设置运行线程为当前线程 setExclusiveOwnerThread(Thread.currentThread()); else //已经有线程持有锁了，加锁失败 acquire(1); &#125; 首先compareAndSetState(0, 1)直接尝试加锁，若加锁成功，设置当前运行线程为当前线程，如果失败的话，运行acquire(1); acquire()方法： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 非公平锁与公平锁一样实现了tryAcquire()方法： 1234protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; nonfairTryAcquire()方法的实现： 1234567891011121314151617181920212223242526final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //判断是否有线程持有锁 if (c == 0) &#123; //尝试加锁（比公平锁少了个判断是否处于等待队头） if (compareAndSetState(0, acquires)) &#123; //设置运行线程为当前线程 setExclusiveOwnerThread(current); //加锁成功 return true; &#125; &#125; //判断是否是当前线程持有锁，锁可重入 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); //设置持有锁数量 setState(nextc); //加锁成功 return true; &#125; //加锁失败 return false; &#125; nonfairTryAcquire()方法实现与公平锁的tryAcquire()类似，不同的是公平锁需要判断当前阻塞的线程队列中当前尝试加锁的线程是否是对头和队列是否为空，而非公平锁所有线程直接尝试加锁，谁能拿到谁就加锁成功。 释放锁unLock()方法源码： 123public void unlock() &#123; sync.release(1);&#125; 直接调用AQS的实现，release源码： 123456789101112131415public final boolean release(int arg) &#123; //尝试解锁，tryRelease交由子类实现 if (tryRelease(arg)) &#123; //获取头节点 Node h = head; //判断头节点是否为空，并且线程状态是否为初始值 if (h != null &amp;&amp; h.waitStatus != 0) //唤醒节点的后置节点 unparkSuccessor(h); //解锁成功 return true; &#125; //失败 return false;&#125; tryRelease方法在Sync子类中实现，源码： 12345678910111213141516protected final boolean tryRelease(int releases) &#123; //线程状态新值，锁可重入，新状态为老状态减releases int c = getState() - releases; //尝试解锁的线程是否为当前执行线程 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; //为0时，所有的锁都已经释放 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; //更新持有锁数量 setState(c); return free;&#125; ConditionLock可以通过lock.newCondition()来获取一个Condition，Condition是一个接口,接口中定义了await()、awaitNanos()、awaitUninterruptibly()、awaitUntil()、signal()、signalAll()这几个方法，await方法相当于Object中的wait，而signal，signalAll方法相当于Object中的notify和notifyAll方法。Object中的线程同步方法常用于synchronized中；await()、awaitNanos()、awaitUninterruptibly()、awaitUntil()、signal()、signalAll()方法用于lock.lock()代码段中对Lock进行线程之间的同步。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之AQS类介绍","slug":"Java并发之AQS类介绍","date":"2018-02-04T04:23:28.000Z","updated":"2018-04-19T06:47:33.129Z","comments":true,"path":"posts/33933/","link":"","permalink":"https://satra.tk/posts/33933/","excerpt":"AQS类介绍AQS类全称AbstractQueuedSynchronizer，Java在AQS类中提供了一系列的模板代码，用来实现Java中一系列的同步工具，很多同步工具都是通过内部类继承自AQS类，通过重写AQS类的方法来实现的，如ReentrantLock类、ReentrantReadWriteLock等。 AQS中使用了一个volatile的int类型变量state来表示线程状态，使用Node实现FIFO队列来完成线程的排队执行。","text":"AQS类介绍AQS类全称AbstractQueuedSynchronizer，Java在AQS类中提供了一系列的模板代码，用来实现Java中一系列的同步工具，很多同步工具都是通过内部类继承自AQS类，通过重写AQS类的方法来实现的，如ReentrantLock类、ReentrantReadWriteLock等。 AQS中使用了一个volatile的int类型变量state来表示线程状态，使用Node实现FIFO队列来完成线程的排队执行。 AQS类主要方法介绍AQS中通过state来表示线程状态，自然有线程状态相关的方法： 1234567protected final int getState() &#123; return state;&#125;protected final void setState(int newState) &#123; state = newState;&#125; compareAndSetState方法，compareAndSetState通过调用Unsafe中的方法来确保变量原子性的改变 123protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 一般对于一个同步工具，继承AQS类后，只需调用acquire模板代码加独占锁，调用acquireShared模板代码加共享锁acquire源码： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquireShared源码： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; AQS中还提供了如下其他的模板代码： 1234567public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; acquireInterruptibly(int arg)：以独占模式获取对象，如果被中断则中止； 1234567public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; acquireSharedInterruptibly(int arg)：以共享模式获取对象，如果被中断则中止； 而AQS类里的tryAcquire方法和tryAcquireShared方法都是交给子类去实现，需要实现判断某线程是否能获得锁的逻辑。AQS类里调用这些个方法是直接抛出异常的，AQS类里需要子类实现的方法及作用有如下几个： tryAcquire(int arg)：尝试在独占模式下获取对象锁； tryAcquireShared(int arg)：尝试在共享模式下获取对象锁； tryRelease(int arg)：尝试释放独占锁； tryReleaseShared(int arg)：尝试释放共享锁； 独占锁acquire加锁与释放加锁acquire源码： 123456public final void acquire(int arg) &#123; //首先交由子类实现的tryAcquire方法去尝试加锁，当加锁失败后将线程放入FIFO等待队列，并再次尝试加锁 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; addWaiter接收一个节点模式的参数，这个参数在AQS内部类Node里面维护，关于Node的FIFO队列将在后面详细介绍。 addWaiter方法源码： 1234567891011121314151617181920private Node addWaiter(Node mode) &#123; //创建一个节点 Node node = new Node(Thread.currentThread(), mode); //获取尾节点 Node pred = tail; //判断是否有尾节点，即判断链表是否初始化了 if (pred != null) &#123; //将尾节点设置为新节点的前置节点 node.prev = pred; //设置尾节点 if (compareAndSetTail(pred, node)) &#123; //将老尾节点的后置节点设置为新节点 pred.next = node; return node; &#125; &#125; //链表未初始化或者设置尾节点失败 enq(node); return node;&#125; enq方法： 12345678910111213141516171819202122private Node enq(final Node node) &#123; //自旋，确保成功 for (;;) &#123; //尾节点 Node t = tail; //无尾节点，即链表未初始化 if (t == null) &#123; //创建链表 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //链表已经初始化，将node节点前置设置为尾节点 node.prev = t; //设置尾节点 if (compareAndSetTail(t, node)) &#123; //将老尾节点的后置节点设置为新节点 t.next = node; return t; &#125; &#125; &#125;&#125; 简而言之，addWaiter方法是将获取锁失败的线程添加至等待链表的尾节点； acquireQueued源码： 1234567891011121314151617181920212223242526272829final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取node前置节点 final Node p = node.predecessor(); //判断是否为头节点并且尝试加锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //获取锁成功设置头节点为当前节点 setHead(node); //释放头节点的下一个节点 p.next = null; // help GC //标志加锁成功 failed = false; return interrupted; &#125; //判断当前线程是否中断并且将线程阻塞放入等待队列 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; //加锁失败 if (failed) //取消竞争 cancelAcquire(node); &#125;&#125; 独占锁的获取流程如图所示： 释放AQS里独占锁释放的模板代码是由release()方法实现； release()方法源码： 123456789101112public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; //首先判断head节点不为空，且节点状态不为初始状态 if (h != null &amp;&amp; h.waitStatus != 0) //唤醒head节点的后继节点 unparkSuccessor(h); //返回成功 return true; &#125; return false;&#125; 共享锁acquireShared的加锁与释放加锁acquireShared源码： 12345public final void acquireShared(int arg) &#123; //交由子类tryAcquireShared方法尝试加锁 if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 子类实现的tryAcquireShared方法加锁失败后，运行AQS的doAcquireShared()方法，doAcquireShared()源码： 12345678910111213141516171819202122232425262728293031323334private void doAcquireShared(int arg) &#123; //首先将线程加入等待队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; //自旋 for (;;) &#123; //获取当前线程的上一个节点 final Node p = node.predecessor(); if (p == head) &#123; //当p是头节点时，再次尝试加锁 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; //加锁成功，设置头节点为当前线程 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; //当p不为头节点，或者加锁失败时 //判断是否应该需要阻塞当前线程，需要的话阻塞当前线程并设置阻塞标志位为true if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 释放释放时通过AQS类的releaseShared()方法实现的，源码： 12345678public final boolean releaseShared(int arg) &#123; //首先由子类的实现去释放锁 if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; doReleaseShared()方法源码： 12345678910111213141516171819202122private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; //判断是否处于等待状态 if (ws == Node.SIGNAL) &#123; //重置状态标志位 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; //唤醒下一个节点 // loop to recheck cases unparkSuccessor(h); &#125; //处于初始状态且是头节点，则需要将后面的节点设置为传播状态 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; acquireInterruptibly()acquireInterruptibly(int arg)：以独占模式获取对象，如果被中断则中止；从上面的源码我们可以看出：它首先交由子类尝试加锁，当加锁失败时，会调用AQS类的doAcquireInterruptibly()方法； 而doAcquireInterruptibly()方法与acquireQueued()方法唯一不同的是：acquireQueued()在判断当前线程应该被中断时，将中断标识设置成true并继续运行，而doAcquireInterruptibly()方法则是判断当前线程应该被中断时，抛出异常； 源码对比如下： 123456789//acquireQueued()方法中：if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true;//doAcquireInterruptibly()方法中：if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); acquireSharedInterruptibly()acquireSharedInterruptibly(int arg)：以共享模式获取对象，如果被中断则中止；与doAcquireInterruptibly()方法一样，它与doAcquireShared()方法唯一不同的也是：它调用的doAcquireSharedInterruptibly()方法会在判断当前线程处于中断状态时会抛出异常。 源码对比如下： 123456789//doAcquireShared()方法中：if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true;//doAcquireSharedInterruptibly()方法中：if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); AQS类FIFO队列介绍前面说到AQS类里面维护了一个FIFO队列，这个队列里的每个节点代表着一个需要获取锁的线程，这个队列是个双向链表实现的；节点是定义在AQS类里的一个内部类Node，Node里有两个标志线程模式状态的变量SHARED和EXCLUSIVE，SHARED代表共享模式，EXCLUSIVE代表独占模式； Node中还用了waitStatus变量来表示线程的状态，waitStatus可取值：SIGNAL、CANCELLED、CONDITION、PROPAGATE、0； 其中SIGNAL的值为-1，代表后继结点处于等待状态，如果当前线程释放的同步状态或者被中断，将会通知后继结点，使后继结点线程运行； CANCELLED的值为1，代表同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待； CONDITION的值为-2，代表结点在等待队列中，结点线程等待在这个Condition上，当其他线程对这个Condition对象调用signal()\\signalAll()，则这个结点将进入等待队列中移入同步队列中，准备重试获取同步状态; PROPAGATE的值为-3，代表读写锁中，当读锁最开始没有获取到操作权限，得到后会发起一个doReleaseShared()动作，内部也是一个循环，当判定后续的节点状态为0时，尝试通过CAS自旋方式将状态修改为这个状态，表示节点可以运行。 0代表初始化状态； 123456789101112131415static final class Node &#123; static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus;&#125; 队列如图所示： 添加等待线程： 在AQS类中通过hasQueuedPredecessors()方法返回当前线程是否是FIFO队列的队头元素，在公平锁中一个线程需要获取锁，首先需要判断其自身是否是阻塞队列的队头元素；hasQueuedPredecessors()方法源码： 1234567public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; LockSupport类当有一个线程持有独占锁时，另一个线程尝试加独占锁就会被阻塞，而LockSupport类就是用于实现阻塞线程和唤醒线程的作用的。unpark类中所有的方法属性都是静态的，LockSupport类的park()方法将一个线程阻塞住，unpark()方法将线程唤醒。 park()方法源码： 123456public static void park(Object blocker) &#123; Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null);&#125; unpark()方法源码： 1234public static void unpark(Thread thread) &#123; if (thread != null) UNSAFE.unpark(thread);&#125; park()方法与unpark()方法均是通过Unsafe类的本地方法实现的。LockSupport除了park()方法和unpark()方法外，还有parkUntil()方法用于超时阻塞。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之CAS算法介绍","slug":"Java并发之CAS算法介绍","date":"2018-02-02T01:47:39.000Z","updated":"2018-04-19T06:47:33.137Z","comments":true,"path":"posts/42273/","link":"","permalink":"https://satra.tk/posts/42273/","excerpt":"CAS算法介绍CAS算法全称为Compare and swap，翻译成中文就是“比较与交换”，是一种有名的无锁算法。无锁编程，就是指在不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步。 在CAS算法中需要理解3个操作数，内存值V，旧的预期值A，要修改的新值B。 当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做，这就是CAS算法。现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰。","text":"CAS算法介绍CAS算法全称为Compare and swap，翻译成中文就是“比较与交换”，是一种有名的无锁算法。无锁编程，就是指在不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步。 在CAS算法中需要理解3个操作数，内存值V，旧的预期值A，要修改的新值B。 当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做，这就是CAS算法。现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰。 Java中CAS算法的实现很多人认为Java没办法直接操作内存，其实不然，sun为Java添加了一个“后门”，可以允许Java简介的操作内存，而这个“后门”就是Unsafe类。 Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等。Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。 Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。Oracle正在计划从Java 9中去掉Unsafe类。 而我们的CAS算法也是在Unsafe类中实现的。 如： 1public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); Unsafe类中绝大部分的方法都是native方法，调用本地方法实现，CAS算法也是。 CAS算法的ABA问题CAS算法有一个经典的ABA问题； ABA问题是指，线程1从内存V中取出值为A，然后期望改成某一值，同一时刻一个线程2从内存V中取出值也为A，然后期望改为B，此时由于某些原因，线程1被阻塞，线程2继续执行，将内存V的值改为了B，然后又一线程将内存V的值改为了A，此时线程1被唤醒，由于内存V的值为A所以导致线程1修改成功。其实此时线程1对比的内存V的值A并不是开始的那个A了，应该要修改失败才对。 ABA问题在Java中的解决要解决ABA问题其实很简单，可以为内存V的值添加一个版本号或者修改次数，当预期值A与内存V值相等时而版本号或修改次数与V的版本号或修改次数不等，则拒绝修改。 Java中AtomicStampedReference类解决了ABA问题，我们来看下它是怎么实现的。 AtomicStampedReference类中有一个内部类Pair，Pair类里reference属性保存了旧的期望值，stamp属性保存了版本号或者是修改次数。 我们来看下AtomicStampedReference类的compareAndSet方法源码： 12345678910111213public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; //只有当版本号相同的情况下才有可能修改成功 return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));&#125; 利用CAS算法实现一个tryLock获取Unsafe类实例Unsafe类提供了一个静态方法来获取它： 12345678public static Unsafe getUnsafe() &#123; Class var0 = Reflection.getCallerClass(); if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; throw new SecurityException(\"Unsafe\"); &#125; else &#123; return theUnsafe; &#125;&#125; 虽然Unsafe类提供了静态方法去获取它，但是我们还是拿不到，我们从源码可以看到，在调用getUnsafe方法时，对该方法做了安全限制，会抛出异常； 尽管如此，我们还是可以通过Java万能的反射来获取这个类的实例的，在Unsafe类中，Unsafe使用了theUnsafe属性来存储了自身的实例对象，我们可以通过反射，来获取Unsafe的theUnsafe属性的值，从而获取Unsafe实例。 1234Class&lt;?&gt; clazz = Unsafe.class;Field f = clazz.getDeclaredField(\"theUnsafe\");f.setAccessible(true);UNSAFE = (Unsafe) f.get(null); 构造Unsafe实现的tryLock首先我们创建一个UnsafeLock的类，来完成使用Unsafe完成锁的功能； 这个类里面我们需要一个status属性表示加锁状态，一个unsafe属性来存储Unsafe实例； Unsafe在修改一个内存值时需要传入这个内存值的偏移量，所以我们还需要一个属性来存储status的偏移量； 然后再实现我们的lock方法和unLock方法。 我们自己实现的锁源码如下： 123456789101112131415161718192021222324252627282930313233public class UnsafeLock &#123; private Unsafe unsafe; private int status = 0; private long statusOffset; private Thread localThread; public UnsafeLock() throws NoSuchFieldException, IllegalAccessException &#123; Class&lt;?&gt; clazz = Unsafe.class; Field f = clazz.getDeclaredField(\"theUnsafe\"); f.setAccessible(true); unsafe = (Unsafe) f.get(null); statusOffset = unsafe.objectFieldOffset(UnsafeLock.class.getDeclaredField(\"status\")); &#125; public void tryLock() throws Exception &#123; if (unsafe.compareAndSwapInt(this, statusOffset, 0, 1)) &#123; localThread = Thread.currentThread(); return; &#125; else &#123; throw new Exception(\"获取锁失败\"); &#125; &#125; public void unlock() &#123; if (Thread.currentThread() != localThread) return; if (unsafe.compareAndSwapInt(this, statusOffset, 1, 0)) &#123; localThread = null; &#125; &#125;&#125; 最后我们来写一个测试类来测试下这个tryLock： 12345678910111213141516171819202122public class MyLockTest &#123; private static int code = 0; public static void main(String[] args) throws Exception &#123; UnsafeLock lock = new UnsafeLock(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; try &#123; lock.tryLock(); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;线程\"+Thread.currentThread().getName()+\"获取锁成功&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); for (int j = 0; j &lt; 10; j++) System.out.println(Thread.currentThread().getName() + \":\" + code++); &#125; catch (Exception e) &#123; System.out.println(\"--------线程\"+Thread.currentThread().getName()+\"获取锁失败--------\"); &#125; finally &#123; lock.unlock(); &#125; &#125;, \"t\" + i).start(); &#125; &#125;&#125; 运行的结果如下图：","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之线程安全","slug":"Java并发之线程安全","date":"2018-02-01T05:14:53.000Z","updated":"2018-04-19T06:47:33.218Z","comments":true,"path":"posts/30524/","link":"","permalink":"https://satra.tk/posts/30524/","excerpt":"线程不安全首先我们来看一段代码：","text":"线程不安全首先我们来看一段代码： 123456789101112131415161718192021public class SynchronizedDemo implements Runnable &#123; private static int data = 0; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; data++; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; SynchronizedDemo demo = new SynchronizedDemo(); for (int i = 0; i &lt; 1000; i++) &#123; new Thread(demo).start(); &#125; Thread.sleep(5000); System.out.println(data); &#125;&#125; 我们想程序输出10000，但是很遗憾实际运行时很多情况下都不是10000而是小于10000，原因是data++并不是原子操作，而是线程从内存中读取data值，完成自增，然后刷新内存值，在单线程的情况下，这并没有什么问题，然而在多线程的情况下，当data值完成自增后还没来得及刷新内存，这个时候另外一个线程将内存中的data完成了读取自增刷新的操作，这个时候前一个线程才将内存的数据刷新，这两个线程的两次自增只自增了一次。这就造成了线程的安全问题，线程安全问题的本质是共享资源被多个线程访问，造成了数据不一致的情况。 实现线程安全的方法要使上面的demo变成线程安全的程序很简单，这里介绍两种方法。 synchronized通过对run方法添加synchronized关键字即可实现线程安全： 123456@Override public synchronized void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; data++; &#125; &#125; synchronized可以修饰方法和代码块，被synchronized修饰的方法和代码块同一时间下只允许一个线程访问相当于给这部分添加了一个锁，任何线程在没拿到这个锁的情况下是不能访问这部分的。 lock我们还可以通过显式lock的方式为代码加锁。 通过lock的方式加锁，上面的代码可改为： 12345678910111213private final Lock lock = new ReentrantLock(true); @Override public void run() &#123; try &#123; lock.lock(); for (int i = 0; i &lt; 10; i++) &#123; data++; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; 实例化一个lock，然后为有共享资源访问的代码显式的加锁。Java中的lock有ReentrantLock和ReentrantReadWriteLock两种。 区别： Lock使用起来比较灵活，但需要手动释放和开启；采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用； Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问； 在并发量比较小的情况下，使用synchronized是个不错的选择，但是在并发量比较高的情况下，其性能下降很严重，此时Lock是个不错的方案。 使用Lock的时候，等待/通知 是使用的Condition对象的await()/signal()/signalAll() ，而使用synchronized的时候，则是对象的wait()/notify()/notifyAll();由此可以看出，使用Lock的时候，粒度更细了，一个Lock可以对应多个Condition。 虽然Lock缺少了synchronized隐式获取释放锁的便捷性，但是却拥有了锁获取与是释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized所不具备的同步特性; Java提供的线程工具lock：ReentrantLock、ReentrantReadWriteLock、StampedLock(JDK8新增);原子类：AtomicXXXXXX；信号量：CountDownLatch、CyclicBarrier、Semaphore；其他的还有线程池工具，ForkJoin框架； 我们的多线程系列文章就是围绕这些个类和工具展开分析。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java并发之多线程","slug":"Java并发之多线程","date":"2018-02-01T02:31:49.000Z","updated":"2018-04-19T06:47:33.211Z","comments":true,"path":"posts/58803/","link":"","permalink":"https://satra.tk/posts/58803/","excerpt":"写在前面多线程，是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”。","text":"写在前面多线程，是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”。 现代编程语言都具有编写多线程程序的能力。就Java而言被大量应用于web后端处理，在处理大量并发访问网站时，多线程技术显得尤为重要。本系列文章将从Java代码及JDK源码介绍的方式全面讲述Java对多线程的支持。 Java如何创建一个线程Java对于线程的实现具有多种方法。 继承Thread类Thread类本质是一个实现了Runnable接口的类，通过继承Thread类，复写Thread类的run()方法，调用start()方法启动一个新的线程。Thread类的定义如下： 123public class Thread implements Runnable &#123; ......&#125; 继承Thread类实现一个新线程： 123456789101112131415public class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(\"Hello Thread.\"); System.out.println(\"This is new thread.\"); &#125; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); System.out.println(\"This is main thread.\"); &#125;&#125; 我们看下Thread的start()方法源码： 12345678910111213141516171819public synchronized void start() &#123; if (threadStatus != 0) //判断线程是否已经start() throw new IllegalThreadStateException(); group.add(this); //将这个线程添加至线程组 boolean started = false; try &#123; start0(); //start()方法核心逻辑，调用native本地方法来启动线程 started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125; 实现Runnable接口实现Runnable接口，新建一个线程： 12345678910111213141516public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"Hello Thread.\"); System.out.println(\"This is new thread.\"); &#125; public static void main(String[] args) &#123; MyRunnable myRunnable = new MyRunnable(); Thread t = new Thread(myRunnable); t.start(); System.out.println(\"This is main thread.\"); &#125;&#125; 实现Runnable接口后需要复写Runnable的run方法，然后将子类作为参数传入Thread的构造方法中，然后调用Thread的start()方法来启动这个线程。我们可以通过JDK8提供的lambda表达式来简化这个代码。lambda表达式实现： 1234567891011public class MyRunnable &#123; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; System.out.println(\"Hello Thread.\"); System.out.println(\"This is new thread.\"); &#125;).start(); System.out.println(\"This is main thread.\"); &#125;&#125; 实现Callable接口123456789101112131415161718public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println(\"Hello Thread.\"); System.out.println(\"This is new thread.\"); return null; &#125; public static void main(String[] args) &#123; MyCallable myCallable = new MyCallable(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(myCallable); Thread t = new Thread(futureTask); t.start(); System.out.println(\"This is main thread.\"); &#125;&#125; 实现Callable接口的方式来实现多线程，首先需要复写Callable的call()方法，然后将子类作为参数传入FutureTask的构造函数，再将FutureTask的实例作为参数传入Thread的构造函数，最后调用Thread方法的start()方法启动新的线程。 实现多线程方式对比细心的读者可能已经发现了，我们在通过实现Callable方法实现多线程的方式中，在复写call()方法时是可以抛出异常和有返回值的。 通过继承Thread类和实现Runnable接口实现的多线程方式是不能有返回值和抛出异常的，如果你需要在新的线程中抛出异常并且带有返回值的话，你需要通过实现Callable接口的方式来实现多线程。 线程生命周期在调用start()方法后，线程并不是立马在执行，而是处于可运行状态，等待cpu分配资源才会运行，当线程没有了cpu资源时线程又会处于可运行状态。当处于运行状态的线程被sleep、wait、join等，线程的状态会变为阻塞状态，当阻塞的线程被唤醒时，线程又处于可运行状态等待cup分配资源进而运行，当线程运行完或者因为异常退出时，此时线程处于死亡状态。线程的生命周期可用图表示： 守护线程什么是守护线程在线程启动前，调用Thread的setDaemon(true)方法可将线程设置为守护线程。 thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 在Daemon线程中产生的新线程也是Daemon的。 只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务。JVM在启动时，系统就自动生成了一些守护线程，如GC线程就是个守护线程。 守护线程的用途在现在分布式系统架构中，很多组件需要和server维持一个心跳连接发送心跳包，这个时候用守护线程来实现这个心跳包的发送最好不过了。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satra.tk/tags/Java并发/"}]},{"title":"Java虚拟机之JVM启动参数大全","slug":"Java虚拟机之JVM启动参数大全","date":"2018-01-31T02:47:12.000Z","updated":"2018-04-19T06:47:33.241Z","comments":true,"path":"posts/49189/","link":"","permalink":"https://satra.tk/posts/49189/","excerpt":"说明本文所有的参数是基于JDK7的HotSpot虚拟机，适用于JDK7及以前版本，JDK7后续版本参数是否有效请自测。 对于启用或关闭功能选项：-XX:+&lt;option&gt;打开某功能；-XX:-&lt;option&gt;关闭某功能； 对于数字型选项：-XX:&lt;option&gt;=&lt;number&gt;，若需要表示大小，可在数字后添加k、m、g； 对于字符串选项：-XX:&lt;option&gt;=&lt;string&gt;，用于指定文件，路径或命令列表；","text":"说明本文所有的参数是基于JDK7的HotSpot虚拟机，适用于JDK7及以前版本，JDK7后续版本参数是否有效请自测。 对于启用或关闭功能选项：-XX:+&lt;option&gt;打开某功能；-XX:-&lt;option&gt;关闭某功能； 对于数字型选项：-XX:&lt;option&gt;=&lt;number&gt;，若需要表示大小，可在数字后添加k、m、g； 对于字符串选项：-XX:&lt;option&gt;=&lt;string&gt;，用于指定文件，路径或命令列表； 参数列表功能选项 参数与默认值 描述 -XX:-AllowUserSignalHandlers 允许使用用户自定义的信号处理器 (只对应Solaris和Linux) -XX:AltStackSize=16384 修改栈容量 (单位 Kb) (对应Solaris, JDK 5.0以后弃用) -XX:-DisableExplicitGC 禁止手动调用System.gc() -XX:+FailOverToOldVerifier 如果新的类型校验器验证失败使用旧版本的类型校验器 (开始于JDK6.) -XX:+HandlePromotionFailure 关闭新生代收集担保(java5以前是默认不启用，java6默认启用) -XX:+MaxFDLimit 将文件描述符加到最大 (对应Solaris) -XX:PreBlockSpin=10 控制多线程自旋锁优化的自旋次数 -XX:-RelaxAccessControlCheck 放宽类型校验机的准入控制(JDK6) -XX:+ScavengeBeforeFullGC 在full GC之前先做年轻代GC (开始于JDK1.4.1.) -XX:+UseAltSigs 为了防止与其他发送信号的应用程序冲突，允许使用候补信号替代 SIGUSR1和SIGUSR2(限于Solaris) -XX:+UseBoundThreads 绑定所有的用户线程到内核线程, 减少线程进入饥饿状态（得不到任何cpu time）的次数(限于Solaris) -XX:-UseConcMarkSweepGC 使用并发的mark-sweep GC收集年老代 (始于JDK1.4.1) -XX:+UseGCOverheadLimit 使用一种限制VM做GC操作的时间所占比例过高的策略 (始于JDK6.) -XX:+UseLWPSynchronization 使用轻量级进程同步替代线程同步 (始于JDK1.4.0. Solaris相关) -XX:-UseParallelGC 使用并发平行GC(始于JDK1.4.1) -XX:-UseParallelOldGC 使用并发平行GC做 full GC. (始于JDK5.0 update 6.) -XX:-UseSerialGC 使用串行GC (始于JDK5.0.) -XX:-UseSpinning 启用多线程自旋锁优化(java1.4.2和1.5需要手动启用) -XX:+UseTLAB 启用线程本地缓存区(1.4.2以前和使用-client选项时，默认不启用，其余版本默认启用) -XX:+UseSplitVerifier 使用新的Class类型校验器(java5默认不启用, java6默认启用) -XX:+UseThreadPriorities 使用本地线程的优先级 -XX:+UseVMInterruptibleIO 在solaris中，允许运行时中断线程(限于solaris) G1垃圾收集器选项 参数与默认值 描述 -XX:+UseG1GC 使用G1垃圾处理器 -XX:MaxGCPauseMillis=n 设置并行收集最大暂停时间，这是一个理想目标，JVM将尽最大努力来实现它 -XX:InitiatingHeapOccupancyPercent=n 启动一个并发垃圾收集周期所需要达到的整堆占用比例。这个比例是指整个堆的占用比例而不是某一个代（例如G1）,如果这个值是0则代表‘持续做GC’。默认值是45 -XX:NewRatio=n 设置年轻代和年老代的比值。例如:值为3，则表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n 年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5 -XX:MaxTenuringThreshold=n 设置垃圾最大存活阀值。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论 -XX:ParallelGCThreads=n 配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等 -XX:ConcGCThreads=n 并发垃圾收集器线程数 -XX:G1ReservePercent=n 设置保留用来做假天花板以减少晋升（新生代对象晋升到老生代）失败可能性的堆数目 -XX:G1HeapRegionSize=n 使用G1垃圾回收器，java堆被划分成统一大小的区块。这个选项设置每个区块的大小。最小值是1Mb，最大值是32Mb 性能选项 参数与默认值 描述 -XX:+AggressiveOpts 启用JVM开发团队最新的调优成果。例如编译优化，偏向锁，并行年老代收集等(JDK 5 update 6后引入，但需要手动启用, JDK6默认启用) -XX:CompileThreshold=10000 通过JIT编译器，将方法编译成机器码的触发阀值，可以理解为调用方法的次数，例如调1000次，将方法编译为机器码 -XX:LargePageSizeInBytes=4m 设置堆内存的内存页大小 -XX:MaxHeapFreeRatio=70 GC后，如果发现空闲堆内存占到整个预估上限值的70%，则收缩预估上限值 -XX:MaxNewSize=size 新生代占整个堆内存的最大值 -XX:MaxPermSize=64m Perm（俗称方法区）占整个堆内存的最大值 -XX:MinHeapFreeRatio=40 GC后，如果发现空闲堆内存占到整个预估上限值的40%，则增大上限值 -XX:NewRatio=2 新生代和年老代的堆内存占用比例, 例如2表示新生代占年老代的1/2，占整个堆内存的1/3 -XX:NewSize=2m 新生代预估上限的默认值 -XX:ReservedCodeCacheSize=32m 设置代码缓存的最大值，编译时用 -XX:SurvivorRatio=8 Eden与Survivor的占用比例 -XX:TargetSurvivorRatio=50 实际使用的survivor空间大小占比。默认是50%，最高90% -XX:ThreadStackSize=512 线程堆栈大小 -XX:+UseBiasedLocking 启用偏向锁 -XX:+UseFastAccessorMethods 优化原始类型的getter方法性能(get/set:Primitive Type) -XX:-UseISM 启用solaris的ISM -XX:+UseLargePages 启用大内存分页 -XX:+UseMPSS 启用solaris的MPSS，不能与ISM同时使用 -XX:+UseStringCache 启用缓存常用的字符串 -XX:AllocatePrefetchLines=1 在使用JIT生成的预读取指令分配对象后读取的缓存行数。如果上次分配的对象是一个实例则默认值是1，如果是一个数组则是3 -XX:AllocatePrefetchStyle=1 预读取指令的生成代码风格0- 无预读取指令生成 1-在每次分配后执行预读取命令 2-当预读取指令执行后使用TLAB()分配水印指针来找回入口 -XX:+UseCompressedStrings 其中，对于不需要16位字符的字符串，可以使用byte[] 而非char[]。对于许多应用，这可以节省内存，但速度较慢（5％-10％） -XX:+OptimizeStringConcat 优化字符串连接操作在可能的情况下 调试选项 参数与默认值 描述 -XX:-CITime 打印发费在JIT编译上的时间 -XX:ErrorFile=./hs_err_pid&lt;pid&gt;.log 错误文件 -XX:-ExtendedDTraceProbes 启用性能的影响DTrace探测器 -XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof 指定HeapDump的文件路径或目录 -XX:-HeapDumpOnOutOfMemoryError 当抛出OOM时进行HeapDump -XX:OnError=”&lt;cmd args&gt;;&lt;cmd args&gt;” 当发生错误时执行用户指定的命令 -XX:OnOutOfMemoryError=”&lt;cmd args&gt;; &lt;cmd args&gt;” 当发生OOM时执行用户指定的命令 -XX:-PrintClassHistogram 当Ctrl+Break发生时打印Class实例信息,与jmap -histo相同 -XX:-PrintConcurrentLocks 当Ctrl+Break发生时打印java.util.concurrent的锁信息, 与jstack -l相同 -XX:-PrintCommandLineFlags 打印命令行上的标记 -XX:-PrintCompilation 当方法被编译时打印信息 -XX:-PrintGC 当GC发生时打印信息 -XX:-PrintGCDetails 打印GC详细信息 -XX:-PrintGCTimeStamps 打印GC用时 -XX:-PrintTenuringDistribution 打印Tenuring年龄信息 -XX:-PrintAdaptiveSizePolicy 打印自适应调整 -XX:-TraceClassLoading 跟踪类加载 -XX:-TraceClassLoadingPreorder 跟踪所有加载的引用类 -XX:-TraceClassResolution 跟踪常量池的变化 -XX:-TraceClassUnloading 跟踪类的卸载 -XX:-TraceLoaderConstraints 打印class的装载策略变化信息到stdout。 -XX:+PerfDataSaveToFile 退出时保存jvmstat二进制文件 -XX:ParallelGCThreads=n 设置新生代与老年代并行垃圾回收器的线程数 -XX:+UseCompressedOops 使用compressed pointers。这个参数默认在64bit的环境下默认启动，但是如果JVM的内存达到32G后，这个参数就会默认为不启动，因为32G内存后，压缩就没有多大必要了，要管理那么大的内存指针也需要很大的宽度了 -XX:+AlwaysPreTouch 在JVM 初始化时预先对Java堆进行摸底 -XX:AllocatePrefetchDistance=n 为对象分配设置预取距离 -XX:InlineSmallCode=n 当编译的代码小于指定的值时,内联编译的代码 -XX:MaxInlineSize=35 内联方法的最大字节数 -XX:FreqInlineSize=n 内联频繁执行的方法的最大字节码大小 -XX:LoopUnrollLimit=n 代表节点数目小于给定值时打开循环体 -XX:InitialTenuringThreshold=7 设置初始的对象在新生代中最大存活次数 -XX:MaxTenuringThreshold=n 设置对象在新生代中最大的存活次数,最大值15,并行回收机制默认为15,CMS默认为4 -Xloggc:&lt;filename&gt; 输出GC详细日志信息至指定文件 -XX:-UseGCLogFileRotation 开启GC日志文件切分功能，前置选项 -Xloggc -XX:NumberOfGClogFiles=1 设置切分GC日志文件数量，文件命名格式：.0, .1, …, .n-1 -XX:GCLogFileSize=8K GC日志文件切分大小 参考文献HotSpot官方文档","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/tags/Java虚拟机/"}]},{"title":"Java虚拟机之内存模型与volatile","slug":"Java虚拟机之内存模型与volatile","date":"2018-01-30T06:47:23.000Z","updated":"2018-04-19T06:47:33.267Z","comments":true,"path":"posts/14828/","link":"","permalink":"https://satra.tk/posts/14828/","excerpt":"硬件效率与一致性尽管现代内存的速度在不断提高，但是内存的速度与cpu比起来还不在一个量级，为了提升计算速度，在内存和处理器之间加上一个高速缓存来作为内存和处理器之间的缓冲。基于高速缓存的方法很好的解决了处理器与内存的矛盾，但是也引入了一个新的问题：缓存一致性。每个处理器都有自己的高速缓存，而他们又共享一个主内存。当处理多个处理器的运算任务都涉及同一个主内存区域时，将可能导致各自的缓存数据不一致，如果真发生这种情况，将同步到主内存的数据到底以谁的缓存数据为准。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。","text":"硬件效率与一致性尽管现代内存的速度在不断提高，但是内存的速度与cpu比起来还不在一个量级，为了提升计算速度，在内存和处理器之间加上一个高速缓存来作为内存和处理器之间的缓冲。基于高速缓存的方法很好的解决了处理器与内存的矛盾，但是也引入了一个新的问题：缓存一致性。每个处理器都有自己的高速缓存，而他们又共享一个主内存。当处理多个处理器的运算任务都涉及同一个主内存区域时，将可能导致各自的缓存数据不一致，如果真发生这种情况，将同步到主内存的数据到底以谁的缓存数据为准。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。 除了增加高速缓存之外，为了使得处理器内部的运算单元尽可能被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与代码中的顺序一致。因此，如果某个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。Java虚拟机的即时编译器中也有类似的指令重排序优化。 Java内存模型Jvava虚拟机规范中通过定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存差异，来实现Java程序在各种平台下都能达到一致的内存访问效果。 主内存与工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。 Java内存模型规定了所有的变量都存储在主内存中。每个线程还有自己的工作内存，线程的工作内存中保存了被该线程中使用到的变量的主内存拷贝副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之类的同步细节，Java内存模型中定义了8种操作来完成。 Lock（锁定）：作用于主内存的变量，他把变量标识为一个线程独占的状态。 unlock(解锁) ：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存中读取到线程工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把执行引擎接收到的值付给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传递到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，就要顺序地执行read和load操作，如果把变量从工作内存同步回主内存，就要顺序地执行store和write操作。Java内存模型还规定了在执行上述8种基本操作必须满足如下规则： 不允许read和load。store和write操作之一单独出现。 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因的把数据从线程的工作内存同步回主内存。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用了一个未被初始化的变量，换句话说，就是一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一个线程对其进行lock操作，但lock操作可以被同一条操作重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新load和assign操作初始化变量的值。 如果一个变量实现没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去lock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。 volatile首先介绍一下volatile所修饰的变量的特性： 第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得到的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。 volatile的第二个作用是禁止指令重排序优化，普通的变量仅能保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码执行的顺序一致。 long和double型变量的特殊规则Java内存中对于lock、unlock、read、load、use、assign、store、write八种操作都是具有原子性的，但是对于64位的数据类型，在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile关键字修饰的64位数据的读写操作划分为两次32位的操作来进行。即虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性。 如果多个线程共享一个并未被声明为volatile的long和double类型的变量，并且同时对它们进行了读取和修改操作，那么某些线程可能读取到一个并非原值，也不是被其他线程修改的代表了“半个变量的数值”。 为避免这种情况，现在的各种商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待。因此我们在编写代码时一般不需把long和double变量专门声明为volatile。 原子性、可见性和有序性原子性：由Java内存模型来直接保证的原子性操作包括read,load,assign.use,store,和write。应用到更大的场景中时，Java内存模型还提供了lock和unlock操作来满足这个需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式的使用这两个操作，这两个字节码反映到Java代码中就是同步块：synchronized关键字。因此在synchronized块之间的操作也具有原子性。 可见性：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取之前从主内存刷新左边两只这种依赖主内存作为传递媒介的方式来实现可见性，无论是普通变量还是volatile变量都是如此。普通变量和volatile变量的区别在于volatile变量的特殊规则保证了新值能够立即同步到主内存，以及每次使用前能够立即从主内存刷新。因此可以说volatile关键字保证了多线程操作时变量的可见性，而不同变量不能保证这一点。 Java还有两个关键字来保证可见性：即synchronized和final。synchronized的可见性是由“一个变量执行unlock操作之前，必须先把变量同步回主内存中”这条规则获得的。final关键字的可见性是指:被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”引用传递出去，那么其他线程就能看见final关键字的值。 有序性：如果在本线程中观察其他线程，所有操作都是无序的。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。而volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则来获得的。这个规则决定了拥有同一个锁的两个同步块只能串行的进入。 先行发生原则(happen-before原则)如果Java内存中所有的有序性都是依靠volatile和synchronized来完成，那么有一些操作将会变得很繁琐。但是Java语言中有一个“先行发生”的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的重要依据。 先行发生原则：在Java内存模型中定义了两项操作顺序之间的偏序关系，如果操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值，发送了消息，调用了方法等。 Java内存模型中包括下列一些天生发生的先行发生关系，如果两个操作之间不在此列，虚拟机可以对它们随意地进行重排序： 程序次序执行规则：在一个线程内，按照代码顺序执行，前面的操作先行发生于书写在后面的操作。 管程锁定规则：一个unlock操作先行发生于后面（时间上的先后）对同一个锁的lock操作。 volatile变量规则：对于一个volatile变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。 线程终止规则：线程的所有操作都先行发生于对此线程的终止操作 线程中断规则：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断时间的发生。 对象终结规则：一个对象的初始化完成先行发生于它的finalize（）方法的开始。 传递性：若A先行于B发生，B先行于C，那么得出A先行于C 我们衡量并发安全问题的时候不要受到时间顺序地干扰，必须以先行发生原则为准。 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/tags/Java虚拟机/"}]},{"title":"Java虚拟机之类加载器","slug":"Java虚拟机之类加载器","date":"2018-01-29T08:17:23.000Z","updated":"2018-04-19T06:47:33.284Z","comments":true,"path":"posts/51357/","link":"","permalink":"https://satra.tk/posts/51357/","excerpt":"类加载器介绍类加载器负责将class文件加载到内存中，并为之生成对应的java.lang.Class对象。对于任意一个类，都需要加载它的类加载器和这个类本身来确定该类在JVM中唯一性，也就是说，同一个class文件用两个不同的类加载器加载并创建两个java.lang.Class对象，即使两个对象来源自同一个class文件，它们也是不相等的，这里“相等”包括Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法，也包括使用instanceof关键字做对象所属关系判定情况。","text":"类加载器介绍类加载器负责将class文件加载到内存中，并为之生成对应的java.lang.Class对象。对于任意一个类，都需要加载它的类加载器和这个类本身来确定该类在JVM中唯一性，也就是说，同一个class文件用两个不同的类加载器加载并创建两个java.lang.Class对象，即使两个对象来源自同一个class文件，它们也是不相等的，这里“相等”包括Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法，也包括使用instanceof关键字做对象所属关系判定情况。 类加载器分类虚拟机提供了3种类加载器，启动（Bootstrap）类加载器、扩展（Extension）类加载器、应用程序（Application）类加载器（也称应用类加载器） Bootstrap ClassLoader该类加载器没有父类加载器，它负责加载虚拟机的核心类库。Bootstrap ClassLoader加载器用于在启动JVM时加载类，以使JVM能正常工作，因而它是用Native（c++）代码实现的，最早被创建出来，处于最底层。它并没有继承java.lang.ClassLoader类。 我们可以来看下Bootstrap ClassLoader加载了哪些类，查看Bootstrap ClassLoader加载的类可以通过System.getProperty(“sun.boot.class.path”)看到： 123456public class ClassLoaderTest &#123; public static void main(String[] args) &#123; String path = System.getProperty(\"sun.boot.class.path\"); Arrays.asList(path.split(\";\")).forEach(System.out::println); &#125;&#125; 结果： Extension ClassLoader该类加载器的父类加载器是根类加载器。它从java.ext.dirs系统属性所指定的目录获取加载类库或从JDK的安装目录的jre\\lib\\ext子目录下加载类库。如果把jar放到这个目录下，也会自动用扩展类加载器加载。扩展类加载器是java类，是java.lang.ClassLoader类的子类。 Application ClassLoader应用类加载器它的父类加载器是扩展类加载器，它将加载CLASSPATH中配置的目录和jar文件，它是用户自定义类加载器的默认父类加载器，系统类加载器是java类，是java.lang.ClassLoader类的子类。 类加载器之间的关系可用如图表示： 自定义类加载器用户可以自定义类加载器，自定义类加载器只需要继承java.lang.ClassLoader，重写父类的findClass方法即可完成自定义类加载器的编写。 我们自己动手写一个类加载器，加载位于D盘根目录下的类： 1234567891011121314151617181920212223242526272829303132333435363738public class MyClassLoader extends ClassLoader &#123; private final String dir = \"D:/\"; //重写父类findClass方法 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; //Java包是以目录形式存在在磁盘中，所以我们需要将.替换成/ String className = name.replace(\".\", \"/\"); File classFile = new File(dir, className + \".class\"); if (!classFile.exists()) &#123; throw new ClassNotFoundException(); &#125; //将类读成字节数组 byte[] classBytes = loadClassBytes(classFile); if (classBytes == null || classBytes.length == 0) &#123; throw new ClassNotFoundException(); &#125; return this.defineClass(name, classBytes, 0, classBytes.length); &#125; private byte[] loadClassBytes(File classFile) &#123; //JDK7语法糖，try with resource语法，可以不用手动的关闭资源 try (ByteArrayOutputStream bout = new ByteArrayOutputStream(); FileInputStream fin = new FileInputStream(classFile)) &#123; byte[] buffer = new byte[1024]; int len; while ((len = fin.read(buffer)) != -1) &#123; bout.write(buffer, 0, len); &#125; bout.flush(); return bout.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 新建一个HelloWorld类编译后放在D盘下： 12345public class HelloWorld &#123; public String hello() &#123; return \"Hello World!\"; &#125;&#125; 测试我们的类加载器： 12345678910111213public class ClassLoaderTest &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; MyClassLoader classLoader = new MyClassLoader(); Class&lt;?&gt; clazz = classLoader.loadClass(\"com.satra.classloader.HelloWorld\"); System.out.println(clazz); System.out.println(clazz.getClassLoader()); Object obj = clazz.newInstance(); Method method = clazz.getMethod(\"hello\", null); Object o = method.invoke(obj, null); System.out.println(o); &#125;&#125; 输出结果： 类加载器双亲委派模型前面我们说过，同一个class文件用两个不同的类加载器加载并创建两个java.lang.Class对象，即使两个对象来源自同一个class文件，它们也是不相等的。例如当我们自定义的类加载器加载了java.lang包中的String类，这样会造成内存中存在两个String的Class对象，而这两个Class对象的实例对象的eques会不相等，对虚拟机的稳定运行造成危害。所以虚拟机定义了双亲委派模型来解决这个问题。 双亲委派模型是指：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 我们可以看下JDK类加载器源码的实现： 123456789101112131415161718192021222324252627282930313233protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; //首先看这个类加载器是否有父类 if (parent != null) &#123; //有父类交由父类去加载 c = parent.loadClass(name, false); &#125; else &#123; //没有父类说明这个类加载器是Bootstrap类加载器调用本地方法去加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; &#125; //有父类且父类不能完成加载或者没有父类时，调用findClass完成加载 if (c == null) &#123; long t1 = System.nanoTime(); c = findClass(name); sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/tags/Java虚拟机/"}]},{"title":"Java虚拟机之类加载机制","slug":"Java虚拟机之类加载机制","date":"2018-01-28T05:39:09.000Z","updated":"2018-04-19T06:47:33.295Z","comments":true,"path":"posts/9465/","link":"","permalink":"https://satra.tk/posts/9465/","excerpt":"概述Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 与其他语言不同的是在Java语言里，类的加载、连接和初始化过程都是在程序运行期间完成的，Java里可动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。","text":"概述Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 与其他语言不同的是在Java语言里，类的加载、连接和初始化过程都是在程序运行期间完成的，Java里可动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 类加载的三个阶段Java类加载分为三个阶段，分别是：加载、连接、初始化；其中连接阶段又可以分为三个阶段，这三个阶段分别是：验证、准备、解析。类加载的三个阶段可如下图所示： Java虚拟机规范中并没有规定什么时候开始进行加载，这点交由虚拟机自己实现，但是对于初始化阶段，虚拟机规范则进行了严格的规定。 Java虚拟机规范中规定以下六种情况必须立即对类进行初始化： 遇到new、getstatic、putstatic、invokestatic这四条字节码时，如果类没有进行过初始化，则需先触发其初始化； 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类还没有进行初始化，则需要先触发其初始化； 当初始化一个类时，其父类还没有进行过初始化，则需要先触发其父类的初始化； 对一个类或接口的静态变量进行访问或者赋值操作时，这个类或者接口还没有进行过初始化，则需要先触发其初始化； 当虚拟机启动时，用户指定一个需要执行的主类，虚拟机会先初始化这个主类； 当调用一个类的静态方法时，这个类还没有进行过初始化，则需要先触发其初始化； Java虚拟机规范中规定的这六种情况触发的初始化情景称为对一个类的主动引用。除此之外，所有引用类的方式都不会触发初始化，称之为被动引用。 被动引用的几个个例子： 通过子类引用父类的静态字段，不会导致子类初始化 12345678910111213141516class Father&#123; static int count = 1; static&#123; System.out.println(\"Initialize class Dfather\"); &#125; &#125; class Son extends Father&#123; static&#123; System.out.println(\"Initialize class Dson\"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; int x = Son.count; &#125; &#125; 通过数组定义类引用类，不会触发此类的初始化 12345678910class A&#123; static&#123; System.out.println(\"Initialize class E\"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; A[] e = new A[10]; &#125; &#125; 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 1234567891011class A&#123; static final int count = 1; static&#123; System.out.println(\"Initialize class F\"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; int x = A.count; &#125; &#125; 类加载过程加载阶段加载是类加载过程的一个阶段，类加载阶段需要完成以下三件事情： 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 加载阶段生成的Class对象是一个Java对象，在Java虚拟机规范中并没有规定这个Class对象存放在哪个内存区域，对于HotSpot虚拟机而言，它将Class对象存放在了方法区中。 虚拟机规范中也没有规定被加载类的来源，类可以从本地磁盘中加载也可以从内存中加载还可以从网络中加载，总之规范中没有规定加载类的来源，只要被加载的类符合虚拟机规范的类文件结构，那么这个类就可以被加载。 连接阶段在加载阶段完成后，虚拟机外部的二进制数据就会按照虚拟机所需要的格式存储在虚拟机的方法区中，接着开始连接阶段，连接阶段分为验证、准备、解析三个阶段； 验证阶段验证阶段是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会对虚拟机自身安全造成危害。当验证不通过时，虚拟机应当抛出一个java.lang.VerifyError异常。 虚拟机首先会进行文件格式验证，文件格式验证会对以下几个方面进行验证： 是否以魔数0xCAFEBABE开头； 类的主次版本号是否在当前虚拟机处理范围之内； 常量池的常量是否含有不被支持的常量类型； 指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量； 其他二进制字节流的验证。 文件格式验证完后，然后开始元数据验证，元数据验证是对字节码描述的信息进行语义分析，保证不存在不符合Java语言规定的元数据信息，包括： 这个类是否有父类； 这个类的父类是否继承了不允许继承的类； 如果这个类不是抽象类，是否实现了父类或者接口之中要求实现的所有方法； 类中的字段、方法是否与父类产生矛盾； 其他语义验证。 元数据验证后，开始进行字节码验证，字节码验证主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这阶段会对类的方法进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 字节码验证后，进行验证阶段最后一个验证：符号引用验证，符号引用验证可以看作是对自身以外的信息（常量池中的各种符号引用）进行匹配性校验。符号引用验证的目的是确保解析动作能正常执行。 准备阶段准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所需要的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。这里说的初始值通常情况下是数据类型的零值，假设定义了一个变量： 1public static int value = 123； 变量value在准备阶段初始化值为0，而不是123，将变量赋值为123是在初始化阶段才会执行。 基本数据类型的零值： 数据类型 零值 int 0 long 0L short 0 char ‘\\u0000’ byte 0 boolean false float 0.0f double 0.0d reference null 如果这个变量是个常量，那么这个变量在准备阶段就会被赋值，如： 1public static final int value = 123； 变量value在准备阶段就会被赋值为123。 解析阶段解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用：符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用于虚拟机实现内存布局无关，引用的目标不一一定已经加载到内存中。 直接引用：直接引用可以使直接指向目标的指针、相对偏移量是一个能简介定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。 类或接口的解析判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 字段解析在对字段进行解析前，会先查看该字段所属的类或接口的符号引用是否已经解析过，没有就先对字段所属的接口或类进行解析。在对字段进行解析的时候，先查找本类或接口中是否有该字段，有就直接返回；否则，再对实现的接口进行遍历，会按照继承关系从下往上递归（也就是说，每个父接口都会走一遍）搜索各个接口和它的父接口，返回最近一个接口的直接引用；再对继承的父类进行遍历，会按照继承关系从下往上递归（也就是说，每个父类都会走一遍）搜索各个父类，返回最近一个父类的直接引用。 类方法解析和字段解析搜索步骤差不多，只不过是先搜索父类，再搜索接口。 接口方法解析和类方法解析差不多，只不过接口中不会有父类，因此只需要对父接口进行搜索即可。 初始化阶段类加载阶段的最后一个阶段就是初始化阶段，初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。 &lt;clinit&gt;()方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但是不能访问。 &lt;clinit&gt;()方法与类构造函数不一样，它不需要显示的调用父类的构造器，虚拟机会保证子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()已经执行完毕。 由于父类的&lt;clinit&gt;()方法先执行，所以父类的静态语句块优于子类的变量赋值操作。 &lt;clinit&gt;()对类或者接口来说并不是必须的，如果一个类没有静态语句块，也就没有对变量的赋值操作，那么编译器不会为这个类生成&lt;clinit&gt;()方法。 接口中无静态语句块但是有赋值操作，因此接口也会有&lt;clinit&gt;()方法，但是接口的&lt;clinit&gt;()方法只用当子类和实现类中定义的变量有使用时才会执行&lt;clinit&gt;()方法。 &lt;clinit&gt;()方法是线程安全的。 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/tags/Java虚拟机/"}]},{"title":"Java虚拟机之垃圾回收机制","slug":"Java虚拟机之垃圾回收机制","date":"2018-01-25T07:14:22.000Z","updated":"2018-04-19T06:47:33.274Z","comments":true,"path":"posts/54219/","link":"","permalink":"https://satra.tk/posts/54219/","excerpt":"概述在Java堆中，同一个接口中的多个实现类需要的内存是不一样的，一个方法中的多个分支需要的内存也不一样，Java程序只有在处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。本文将讲述Java自动内存管理中，Java虚拟机对内存的回收机制。","text":"概述在Java堆中，同一个接口中的多个实现类需要的内存是不一样的，一个方法中的多个分支需要的内存也不一样，Java程序只有在处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。本文将讲述Java自动内存管理中，Java虚拟机对内存的回收机制。 判断对象能否回收JVM虚拟机只有在对象已经“死亡”后，才会将这个对象所占用的内存回收释放，而判断对象是否“死亡”的算法有：引用计数算法和可达性分析算法。 引用计数算法引用计数算法很通俗易懂，给每个对象添加一个应用计数器，每当有一个地方引用它的时候，计数器加一；当引用失效时，计数器减一；当对象的引用计数器为零时，证明对象已经没有任何地方引用它了，此时可以判断对象所占用的内存可回收了。 引用计数算法不能解决对象之间相互循环引用的问题；例如，对象A中引用了对象B，对象B中引用了对象A，但是对象A和对象B都没有其他引用并且对象A和B都不可被访问到了，此时，由于对象A持有B的引用，所以对象B引用计数器不为0，对象B不会被回收，而对象B持有对象A的引用，对象A的引用计数器不为0；所以对象A同样不会被回收。 可达性分析算法在目前主流的虚拟机中，判断对象是否死亡的算法为可达性分析算法。这个算法的基本思路是通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到“GC Roots”没有任何引用链相连时，证明此对象是不可用的，如图所示：object5、object6、object7之间虽然互相关联，但是它们到“GC Roots”是不可达的，所以它们会被判为可回收的对象。在Java中“GC Roots”可以是： 虚拟机栈中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量池引用的对象； 本地方法栈中JNI引用的对象； Java引用类型强引用Object obj = new Object()这种对象的引用为强引用，只要引用还在对象就不会被回收。 软引用软引用对象创建：1SoftReference&lt;Object&gt; sobj = new SoftReference(new Object()) 对于软引用对象，在系统将要发生内存溢出时，会将这些对象回收，如果回收后内存还不够，才会抛出内存溢出异常。 弱引用弱引用对象创建：1WeakReference&lt;Object&gt; wobj = new WeakReference(new Object()) 对于弱引用，当垃圾收集器工作时，被弱引用引用的对象都会被回收。 虚引用虚引用对象创建：12ReferenceQueue queue = new ReferenceQueue();PhantomReference ref = new PhantomReference(new Object(), queue); 虚引用对象的创建需要配合队列使用； 被虚引用引用的对象无法通过该引用来获取一个实例，在下一次GC时，该对象也会被回收，虚引用唯一的目的是在GC时收到一个系统通知。 垃圾回收算法标记—清除算法标记—清除算法如同它的名字一样，需要经过两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。 标记清除算法有两个不足：一是效率不高，二是会产生大量空间碎片。 复制算法复制算法将可用内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将存活的对象复制到另一块上，然后再将已经使用过的内存一次清理掉。 这种算法有个缺点，内存缩小为了原来的一半，这样代价太高了。现在的商用虚拟机都采用这种算法来回收新生代，不过研究表明1:1的比例非常不科学，因此新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden区和两块Survivor区的比例为8:1:1。 标记—整理算法标记-整理算法过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。 分代收集算法现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。大批对象死去、少量对象存活的新生代，使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的老年代，采用标记-清理算法或者标记-整理算法。 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/tags/Java虚拟机/"}]},{"title":"Java虚拟机之JVM内存区域与Java对象","slug":"Java虚拟机之JVM内存区域与Java对象","date":"2018-01-10T10:33:18.000Z","updated":"2018-04-19T06:47:33.231Z","comments":true,"path":"posts/40993/","link":"","permalink":"https://satra.tk/posts/40993/","excerpt":"前言最近第七次拜读《深入理解Java虚拟机:JVM高级特性与最佳实践》，每次读都有不同的收获，为了以防自己读后忘记，同时为了加深理解，准备写一系列JVM相关文章。能力有限，文中大部分内容均由本人整理总结自《深入理解Java虚拟机:JVM高级特性与最佳实践》，文中出现错误的地方请见谅。","text":"前言最近第七次拜读《深入理解Java虚拟机:JVM高级特性与最佳实践》，每次读都有不同的收获，为了以防自己读后忘记，同时为了加深理解，准备写一系列JVM相关文章。能力有限，文中大部分内容均由本人整理总结自《深入理解Java虚拟机:JVM高级特性与最佳实践》，文中出现错误的地方请见谅。 JVM内存区域对于c、c++程序员而言，需要手动去管理自己创建对象所占用内存的销毁。而对于Java程序员而言，虚拟机帮你完成了这部分工作。Java虚拟机在运行时会将它所管理的内存划分为若干个不同的数据区域，我们一般把这叫做JVM的内存模型。 JVM运行时内存区域可分为：虚拟机栈、本地方法栈、程序计数器、方法区、堆；其中虚拟机栈、本地方法栈和程序计数器为线程安全区域，而方法区和堆为线程不安全区域；如下图所示： 虚拟机栈顾名思义，虚拟机栈是用于供程序使用的栈内存，它的生命周期与线程相同，虚拟机栈会在每个方法执行时创建一个栈帧，栈帧中存储着局部变量表、操作数栈、动态连接、方法出口等。当程序运行所需栈内存超过栈的大小虚拟机会抛出StackOverflowError异常，此时可通过JVM虚拟机参数—Xss调整栈大小；当机器可用物理内存小于JVM虚拟机栈所需内存时会抛出OutOfMemoryError异常。笔者在Linux上基于HotSpot虚拟机测得虚拟机栈默认大小为1024kb 其中局部变量表存放着编译期间可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象的引用、返回地址；局部变量表的大小在编译期间就已经知道了，除64位long和double占用两个局部变量空间（Slot）外，其余均只占用一个局部变量表。方法在运行期间不会改变局部变量表大小。 操作数栈：方法执行中进行算术运算或者是调用其他的方法进行参数传递的时候是通过操作数栈进行的。 动态连接：Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 返回地址中存放的是方法执行完之后返回地址。 本地方法栈本地方法栈与虚拟机栈的作用是类似的，不同的是：虚拟机栈是为执行Java方法服务而本地方法栈是为虚拟机使用到的Native方法服务。值得注意的是在sun公司的HotSpot虚拟机上，本地方法栈与虚拟机栈是合并在一起的。 程序计数器程序计数器可以看作是当前线程所执行的字节码的行号指示器，每个线程都有一个独立的程序计数器，各线程之间互不影响。若线程正在执行一个Native方法，则此时该线程的程序计数器为空。 方法区方法区用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也称之为“永久代”。 值得一说的是，在方法区中有一个运行时常量池（注意我说的是运行时的常量池），对于Java class文件也有一个常量池。运行时常量池是class文件常量池中编译期间生成的各种已知的字面量和符号引用，在class文件首次被虚拟机加载时载入方法区的运行时常量池。运行时常量池具备动态特性，不止只有class文件中常量池才能进入方法区运行时常量池，运行期间也可能将新的常量放入其中，例如String类的intern()方法。另外值得注意的是在JDK1.7之后的HotSpot虚拟机，字符串常量池已不在方法区，而在堆内存之中。 堆Java虚拟机规范中描述：所有的对象实例以及数组都要在堆上分配内存。也就是说堆主要是存放对象实例的。 堆内存大小可通过-Xms、-Xmx控制大小。JVM虚拟机的垃圾收集器主要活动的区域也是这块区域。对于堆内存还可分为新生代和老年代，其中默认情况下新生代占堆内存大小的三分之一，老年代占堆内存大小的三分之二，可通过参数-XX:NewRatio控制这个比例的大小。对于新生代还可分为Eden区和两个Survivor区其大小比为8：1：1。大内存对象直接分配在老年代，小内存对象分配在新生代Eden中GC一次后“搬移”到Survivor区，在Survivor区存活若干次GC后将会被“搬移”至老年代。关于GC相关的我会在后续文章中详细说明。 Java对象对象的创建在Java程序运行时，运行至对象创建指令（new、克隆、反序列化等）时，首先将检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，必须先执行相应的类加载过程。 类加载检查后虚拟机将为类分配内存，对象所需内存大小在类加载完后即可确定。为类分配内存有两种方式：一是若Java堆中内存是绝对规整的，所有使用中的内存放一边，空闲内存放另一边，中间放着一个指针作为分界点的指示器，分配内存时只需将指针向空闲空间那边移动一段与对象大小相等的距离，这种分配方式称之为“指针碰撞”。另一种是Java堆不是规整的，虚拟机维护了一个队列，队列记录了哪些内存块是可用的，在分配内存时从列表中找一块足够大的空间划分给对象实例，并更新记录，这种分配方式称之为“空闲列表”。 在并发情况下，对象创建的原子性是靠虚拟机通过CAS与失败重试保证的。另外可通过参数-XX:+/-UseTLAB来保证对象创建的原子性，TLAB是每个线程在Java堆中预先分配一块小的内存，称之为本地线程分配缓冲（TLAB）,对象首先在各自线程的TLAB中分配内存，只有当TLAB不够用需要重新分配TLAB时，才会同步锁定。 对象内存布局对象在内存中存储可分为三块区：对象头、实例数据、对齐填充。 对象头一部分存储对象自身运行时数据（HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等），另一部分是类型指针，即对象指向它的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 对象在堆内存的访问定位Java程序通过栈上reference数据来操作堆上对象实例，reference可能指向堆中的一个句柄池，句柄池中存放着堆中对象实例的地址和方法区中对象类型数据的地址； reference中也有可能直接存放着堆中实例对象地址，在对象头中存放着方法区对象类型数据地址。对象类型数据笔者认为是虚拟机从磁盘中class文件加载进方法区的对象类型数据。 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satra.tk/tags/Java虚拟机/"}]},{"title":"爬虫爬取了某大学阳光平台几千条信件后做了个有趣的分析","slug":"爬虫爬取了某大学阳光平台几千条信件后做了个有趣的分析","date":"2017-12-12T11:48:52.000Z","updated":"2018-04-19T06:47:33.319Z","comments":true,"path":"posts/22675/","link":"","permalink":"https://satra.tk/posts/22675/","excerpt":"最近在家准备写毕业论文，在家里查文献的时候特别不方便，知网的文献不能下载，只能看到摘要。但是我校购买了知网数据库，使用学校ip可以直接下载知网文献，遂上阳光服务平台准备咨询是否提供vpn连接到校内网供学生查询文献。然后突发奇想，使用python编写了个爬虫把阳光服务平台数据爬下来做数据分析。爬虫部分代码就不帖出来了，让我们一起来看下数据分析。","text":"最近在家准备写毕业论文，在家里查文献的时候特别不方便，知网的文献不能下载，只能看到摘要。但是我校购买了知网数据库，使用学校ip可以直接下载知网文献，遂上阳光服务平台准备咨询是否提供vpn连接到校内网供学生查询文献。然后突发奇想，使用python编写了个爬虫把阳光服务平台数据爬下来做数据分析。爬虫部分代码就不帖出来了，让我们一起来看下数据分析。 爬虫爬取的所有数据均保存在MySQL中，首先导入必要的包。 12345import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport pymysqlimport jieba 将数据从数据库导入进来。 12conn = pymysql.Connect(host='127.0.0.1', user='root', password='root', port=3306, db='ygfw', charset='utf8')df = pd.read_sql('select * from qa', conn) 让我们看下前面5条数据。 1df.head() 这里对字段说明下 字段 说明 title 标题 accept 受理单位 type 类型 submit_time 提交时间 finish_time 回复时间 click_num 点击次数 context 内容 status 状态 replay 回复 url 原链接地址 首先我们看下点击率。 12df.set_index('submit_time')['click_num'].plot()plt.show() 点击率最高数量的在2017年8月左右达到了6000多，让我们看下点击率第一的是哪条。 1(df.sort_values(by=['click_num'], ascending=False)).head() 可以看到点记录排第一的是来自城乡资源与规划学院的一封表扬唐老师的信件，点击有6500多次。 按照月份看下从14年到17年每个月提交信件的数量将submit_time提取出来作为一个Series的index，将Series的值设置为1作为统计计数，然后用lambda表达式按照月份统计信件和。 123s = pd.Series(1, index=df['submit_time'])s.groupby(lambda x: x.month).sum().plot()plt.show() 可以看到在十一月份左右信件数量最多，达到了450左右，而二月份和八月份可能是由于寒暑假的原因达到了年度最低量。 12s.groupby(lambda x: x.year).sum().plot(kind='bar')plt.show() 由于17年还没过完，所以17年比16年要少点。按照年份来看，阳光服务平台的信件数量呈现逐年上升趋势。 12345plt.rcParams['font.sans-serif'] = ['SimHei']plt.figure(figsize=(10, 6))s2 = pd.Series(1, index=df['accept'])s2.groupby('accept').sum().plot(kind='bar')plt.show() 其中各部门中管理处的信件是最多的，可能是大多数人不知道要发往那个部门，就往管理处投吧，233333~ 然后我们看下各部门对信件的处理速度吧。我们将信件处理完成的时间减去提交时间得到的时间差转换成秒数，然后对各部门的时间差求平均，得到各部门处理每封信件的速度。 12345678df['time'] = df['finish_time'] - df['submit_time']df['time'] = df['time'].apply(lambda x: x.total_seconds())df['num'] = 1df2 = df.set_index('accept').groupby('accept').sum()df2['mean'] = df2['time'] / df2['num']plt.figure(figsize=(10, 10))df2['mean'].plot(kind='barh')plt.show() 其中张家界校区财务办处理信件的速度最慢，历史与文化学院处理信件的速度最快，从上面各部门信件数量上来看历史与文化学院与张家界校区财务办信件数量上是差不多的，都比较少。 1234plt.figure(figsize=(11, 6))df3 = df.set_index('type').groupby('type').sum()df3['num'].plot(kind='barh')plt.show() 看下信件的类型，其中最多的是反映，第二是投诉，最少的是表扬，看样子学校做的不好的地方还是有点多啊。 好了，我们的数据分析先暂时到这。","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://satra.tk/categories/数据分析/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"https://satra.tk/tags/数据分析/"}]}]}