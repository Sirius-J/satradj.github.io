{"meta":{"title":"我在万达摆地摊's blog","subtitle":"欢迎来到'我在万达摆地摊'的博客","description":"一位在靠在万达摆地摊才能勉强存活的码农","author":"我在万达摆地摊","url":"https://satradj.github.io"},"pages":[{"title":"About","date":"2018-02-04T08:58:33.085Z","updated":"2018-02-04T08:58:33.085Z","comments":true,"path":"about/index.html","permalink":"https://satradj.github.io/about/index.html","excerpt":"","text":"网名来源：我在万达摆地摊，一位靠着在万达摆地摊才能勉强维持生计，生活在水生火热之中的码农。 我的技能IT技能：会一点Java和python，玩过几天大数据，了解一点点机器学习，会写一丢丢前端页面。 其他技能：会用PS，会一点点PR剪辑视频，懂得AE套模板。"},{"title":"我的书单","date":"2018-02-06T12:13:17.390Z","updated":"2018-02-06T12:13:17.390Z","comments":true,"path":"books/index.html","permalink":"https://satradj.github.io/books/index.html","excerpt":"","text":"对于我们程序员而言，最好的提升自己的方式就是看技术类书籍。毕竟看视频学习一个知识点与看书学习一个知识点相比太费时间；网上虽然有较多的博客文章类资源，但是相比书籍而言，缺乏系统性，而有些博客文章只是简单的复制粘贴，其内容正确与否完全不顾。所以，读一本好书，对于程序员的提升毋庸置疑的。 我在这里贴出我的个人书单供大家参考交流，书单不定期更新。 Java语言类Java基础 《Java编程思想（第4版）》 《Effective java 中文版（第2版）》 Java并发 《Java并发编程实战》 《Java并发编程的艺术》 Java虚拟机 《深入理解Java虚拟机:JVM高级特性与最佳实践(第2版)》 《Java性能优化权威指南》 软件工程设计模式 《Head First 设计模式（中文版）》 《重构》 算法 《算法（第4版）》 架构 《Netty实战》 《大型网站技术架构》 机器学习 《数学之美》 《机器学习实战》 数据库 《高性能MySQL》 《MySQL技术内幕-InnoDB存储引擎》"},{"title":"Categories","date":"2018-01-24T06:53:10.927Z","updated":"2018-01-24T06:53:10.927Z","comments":true,"path":"categories/index.html","permalink":"https://satradj.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java并发之线程池源码分析","slug":"Java并发之线程池源码分析","date":"2018-03-06T03:30:29.000Z","updated":"2018-03-06T05:35:42.945Z","comments":true,"path":"Java并发之线程池源码分析/","link":"","permalink":"https://satradj.github.io/Java并发之线程池源码分析/","excerpt":"为什么需要线程池操作系统中线程的实现有三种，一种是用户级线程，一种是内核支持线程，还有一种是前两种的组合方式。用户级线程是在用户空间实现的，而内核级线程是在OS内核空间实现的。JVM对于线程并没有明确的定义是用户线程还是内核线程，但Java常用的JVM HotSpot，它都是使用1:1线程模型即内核线程，线程的调度完全交给了操作系统内核；所以在HotSpot上创建线程需要操作系统从用户态切换到内核态，这个开销是巨大的。而Java的线程在使用完后就会被回收，而需要时又会被创建，所以通过将空闲线程管理起来成为线程池，当需要线程运行任务的时候就从线程池中拿线程，避免了线程的创建过程，提升效率。","text":"为什么需要线程池操作系统中线程的实现有三种，一种是用户级线程，一种是内核支持线程，还有一种是前两种的组合方式。用户级线程是在用户空间实现的，而内核级线程是在OS内核空间实现的。JVM对于线程并没有明确的定义是用户线程还是内核线程，但Java常用的JVM HotSpot，它都是使用1:1线程模型即内核线程，线程的调度完全交给了操作系统内核；所以在HotSpot上创建线程需要操作系统从用户态切换到内核态，这个开销是巨大的。而Java的线程在使用完后就会被回收，而需要时又会被创建，所以通过将空闲线程管理起来成为线程池，当需要线程运行任务的时候就从线程池中拿线程，避免了线程的创建过程，提升效率。 ExecutorJava对于线程池的实现依赖于Executor框架，Executor框架UML图： Executor接口： 1234public interface Executor &#123; void execute(Runnable command);&#125; Executor接口只提供了一个提交任务的方法; ExecutorService接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public interface ExecutorService extends Executor &#123; //关闭方法，调用后执行之前提交的任务，不再接受新的任务 void shutdown(); //暂停所有等待处理的任务并返回这些任务的列表 List&lt;Runnable&gt; shutdownNow(); //是否已经关闭 boolean isShutdown(); //关闭后所有任务是否都已完成 boolean isTerminated(); //在有关闭请求或者当前线程被中断时阻塞住直到完成执行 boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; //提交一个Callable任务 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); //提交一个Runable任务，result要返回的结果 &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); //提交一个任务 Future&lt;?&gt; submit(Runnable task); //执行所有给定的任务列表，当所有任务完成，返回保持任务状态和结果的Future列表 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; //执行给定的任务列表，当所有任务完成或超时期满时，返回保持任务状态和结果的Future列表 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; //执行给定的任务列表，如果某个任务已成功完成，则返回其结果 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; //执行给定的任务列表，如果在给定的超时期满前某个任务已成功完成，则返回其结果。 &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; ExecutorService接口扩展自Executor，相比Executor它提供了线程池生命周期管理的方法和各种形式任务的提交方法； AbstractExecutorService抽象类实现了ExecutorService接口，为线程池提供了submit、invokeAny、invokeAll模板代码。 线程池实现类源码分析继承自AbstractExecutorService的类都是Java提供的线程池的具体实现类； ThreadPoolExecutorThreadPoolExecutor有五个内部类：AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy、Worker，其中AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy四个内部类实现了RejectedExecutionHandler接口为线程池的拒绝策略，当线程池的任务缓存队列已满并且线程池中的线程数目达到maximumPoolSize，如果还有任务到来就会采取任务拒绝策略； AbortPolicy:丢弃任务并抛出RejectedExecutionException异常； CallerRunsPolicy：由调用线程处理该任务； DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）； DiscardPolicy：也是丢弃任务，但是不抛出异常； Worker主要维护线程运行的中断状态，Worker也实现了AQS类。 ThreadPoolExecutor有四个构造方法 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 构造函数参数意义： corePoolSize：线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有核心线程； maximumPoolSize：线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize； keepAliveTime：线程空闲时的存活时间，即当线程没有任务执行时，继续存活的时间；默认情况下，该参数只在线程数大于corePoolSize时才有用； unit：keepAliveTime的单位； workQueue：用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口； threadFactory：创建线程的工厂，通过自定义的线程工厂可以给每个新建的线程设置一个具有识别度的线程名； handler：线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务； 其他构造函数都是调用这个构造函数实现的： 12345678910111213141516171819202122232425262728public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);&#125;public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);&#125; 一个任务通过 execute(Runnable)方法被添加到线程池。 execute方法： 123456789101112131415161718192021222324252627282930313233public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); //活动线程小于corePoolSize if (workerCountOf(c) &lt; corePoolSize) &#123; //直接启动新任务 if (addWorker(command, true)) //添加成功返回 return; c = ctl.get(); &#125; //活动线程大于等于corePoolSize //线程池处于RUNNING状态，且往等待队列添加Runnable成功 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //线程池处于非RUNNING状态，并且从workQueue移除成功 if (! isRunning(recheck) &amp;&amp; remove(command)) //执行拒绝策略 reject(command); //线程池处于RUNNING状态或者线程池处于非RUNNING状态但是任务移除失败 //活动线程数量等于0 else if (workerCountOf(recheck) == 0) //添加一个null任务 addWorker(null, false); &#125; //活动线程大于等于corePoolSize //线程池处于非RUNNING状态或者线程池处于RUNNING状态但是往等待队列添加Runnable失败 //尝试启动新任务失败 else if (!addWorker(command, false)) //执行拒绝策略 reject(command);&#125; ThreadPoolExecutor使用了一个ctl变量来存储线程池有效线程数量和线程池的状态； ctl变量： 1private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 使用ctl变量判断线程池有效线程数量和线程池状态方法： 123456789101112private static final int COUNT_BITS = Integer.SIZE - 3;private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;private static final int STOP = 1 &lt;&lt; COUNT_BITS;private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; ctl用一个32位int类型来存储有效线程数量和线程池状态，其中低29位存线程数，高3位存线程运行状态，所以线程池状态有如下五种： RUNNING：-536870912 SHUTDOWN：0 STOP：536870912 TIDYING：1073741824 TERMINATED：1610612736 这几个状态的意义： RUNNING：线程池正常运行，可以接受新的任务并处理队列中的任务； SHUTDOWN：不再接受新的任务，但是会执行队列中的任务； STOP：不再接受新任务，不处理队列中的任务； TIDYING：所有任务已经终止，workerCount为0时，线程池转换成TIDYING状态，将会运行terminated()方法； TERMINATED：terminated()方法已经运行完成； 启动新任务addWorker方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980//firstTask：Runnable任务//core：是否需要重新检查workerCount是否小于corePoolSizeprivate boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //线程池非RUNNING状态 //线程池处于非SHUTDOWN状态并且firstTask不为空并且workQueue不为空 if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) //返回失败 return false; //此时，线程池处于RUNNING状态或者SHUTDOWN状态 for (;;) &#123; //获取线程池运行线程数量 int wc = workerCountOf(c); //线程池运行线程数量大于线程池最大允许容量或者大于corePoolSize(maximumPoolSize) if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) //返回失败 return false; //原子变化workerCount if (compareAndIncrementWorkerCount(c)) //成功，跳出自旋 break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) //失败，重试 continue retry; &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int rs = runStateOf(ctl.get()); //线程池处于运行状态或者处于SHUTDOWN状态且firstTask为空 if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); //将新的线程添加到线程池中 workers.add(w); int s = workers.size(); //更新largestPoolSize if (s &gt; largestPoolSize) largestPoolSize = s; //标记添加任务成功 workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; //任务添加成功时 if (workerAdded) &#123; //运行任务 t.start(); //标记任务在运行 workerStarted = true; &#125; &#125; &#125; finally &#123; //线程启动失败 if (! workerStarted) //从wokers中移除w并递减wokerCount addWorkerFailed(w); &#125; return workerStarted;&#125; 当new一个Worker实例的时候，Worker的构造函数通过调用ThreadFactory获得一个线程，并且保存在自己的成员变量thread中； 当添加任务成功后会调用Worker的thread的start()方法，通过另一个线程去执行Worker的run方法； Worker的run方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public void run() &#123; runWorker(this);&#125;final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //Worker里的Runnable不为空或从workQueue队列获取Runnable不为空 while (task != null || (task = getTask()) != null) &#123; w.lock(); //线程池处于非RUNNING、SHUTDOWN状态且线程不是中断状态 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; //执行之前处理，由子类实现 beforeExecute(wt, task); Throwable thrown = null; try &#123; //执行 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; //执行之后处理，由子类实现 afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; //线程结束后的一些清理工作 processWorkerExit(w, completedAbruptly); &#125;&#125; 从workQueue队列获取task方法getTask()： 123456789101112131415161718192021222324252627282930313233343536373839404142private Runnable getTask() &#123; boolean timedOut = false; //自旋 for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); //线程池处于非RUNNING、SHUTDOWN状态并且线程池处于非STOP状态workQueue不为空 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; //递减workerCount值 decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); //标记从队列中取任务时是否允许超时 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //线程池线程总数量大于maximumPoolSize或者workQueue为空 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //workerCount递减，并返回空 if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; //当允许超时时从workQueue中超时获取task，当不允许超时时，直接从workQueue获取task Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 线程结束后清理方法processWorkerExit()： 12345678910111213141516171819202122232425262728293031323334353637private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; //runWorker正常允许完成后，已经完成了workerCount递减 if (completedAbruptly) decrementWorkerCount(); final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; completedTaskCount += w.completedTasks; //从Worker集合中移除Worker workers.remove(w); &#125; finally &#123; mainLock.unlock(); &#125; //尝试停止线程池 tryTerminate(); int c = ctl.get(); //线程池状态为RUNNING或SHUTDOWN if (runStateLessThan(c, STOP)) &#123; //线程非异常退出 if (!completedAbruptly) &#123; //当允许coreThread超时时，线程池最小线程数量设置为0，当不允许时，线程池最小线程数量设置为corePoolSize int min = allowCoreThreadTimeOut ? 0 : corePoolSize; //最小线程数量为0且workQueue不为空 if (min == 0 &amp;&amp; ! workQueue.isEmpty()) //最小线程数置为1 min = 1; //线程池中线程数量大于min if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; //线程异常退出或者线程池为空，但是队列中还有任务没执行 addWorker(null, false); &#125;&#125; 尝试停止线程池方法tryTerminate()： 123456789101112131415161718192021222324252627282930313233343536373839404142final void tryTerminate() &#123; //自旋 for (;;) &#123; int c = ctl.get(); //线程池还在运行 //线程池处于RUNNING、SHUTDOWN、STOP状态 //线程池状态为SHUTDOWN但是workQueue不为空 //直接返回 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) return; //当线程池状态为SHUTDOWN且workQueue为空时程序继续 //workerCount不为0则不能停止线程池，且此时线程都处于等待的状态 if (workerCountOf(c) != 0) &#123; //中断正在等待的线程 interruptIdleWorkers(ONLY_ONE); return; &#125; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //设置线程池状态为TIDYING状态 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; //执行terminated()方法，由子类实现 terminated(); &#125; finally &#123; //设置线程池状态为TERMINATED状态 ctl.set(ctlOf(TERMINATED, 0)); termination.signalAll(); &#125; return; &#125; &#125; finally &#123; mainLock.unlock(); &#125; &#125;&#125; 中断正在等待的线程方法interruptIdleWorkers()： 1234567891011121314151617181920212223//onlyOne：是否只中断一个线程private void interruptIdleWorkers(boolean onlyOne) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //遍历workers集合中断 for (Worker w : workers) &#123; Thread t = w.thread; if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; w.unlock(); &#125; &#125; if (onlyOne) break; &#125; &#125; finally &#123; mainLock.unlock(); &#125;&#125; 线程池关闭shutdown()方法： 1234567891011121314151617public void shutdown() &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; //检查是否有权限关闭 checkShutdownAccess(); //设置线程池状态为SHUTDOWN advanceRunState(SHUTDOWN); //中断所有空闲线程 interruptIdleWorkers(); onShutdown(); &#125; finally &#123; mainLock.unlock(); &#125; //尝试停止线程池 tryTerminate();&#125; 线程池立即关闭方法shutdownNow()： 12345678910111213141516171819public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; checkShutdownAccess(); //设置线程池状态为STOP advanceRunState(STOP); //与shutdown()不同，shutdownNow()执行interruptWorkers()方法，中断所有线程 interruptWorkers(); //返回队列中还没执行的任务 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; //尝试停止线程池 tryTerminate(); return tasks;&#125; 线程池工具类ExecutorsExecutors提供了一系列静态工厂方法用于创建各种线程池； 通过Executors Java提供四种线程池，分别为： newCachedThreadPool：创建一个可缓存线程池； newFixedThreadPool：创建一个定长线程池； newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行； newSingleThreadExecutor：创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行； newCachedThreadPool方法： 123456789101112public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125;public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), threadFactory);&#125; newFixedThreadPool方法： 123456789101112public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());&#125;public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory);&#125; newScheduledThreadPool方法： 12345678public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize);&#125;public static ScheduledExecutorService newScheduledThreadPool( int corePoolSize, ThreadFactory threadFactory) &#123; return new ScheduledThreadPoolExecutor(corePoolSize, threadFactory);&#125; newSingleThreadExecutor方法： 1234567891011121314public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()));&#125;public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;(), threadFactory));&#125;","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之ThreadLocal源码分析","slug":"Java并发之ThreadLocal源码分析","date":"2018-02-20T08:21:13.000Z","updated":"2018-02-20T13:18:48.270Z","comments":true,"path":"Java并发之ThreadLocal源码分析/","link":"","permalink":"https://satradj.github.io/Java并发之ThreadLocal源码分析/","excerpt":"ThreadLocal介绍ThreadLocal是Java提供的一个线程局部变量的工具，虽说它是为线程服务，但是它并没有在Java的并发包里面，而是和Thread一样在java.lang包里，首先我们来看下ThreadLocal的基本用法。 一般情况下，我们需要一个成员变量，并且在线程里对成员变量修改，往往我们会这样写：","text":"ThreadLocal介绍ThreadLocal是Java提供的一个线程局部变量的工具，虽说它是为线程服务，但是它并没有在Java的并发包里面，而是和Thread一样在java.lang包里，首先我们来看下ThreadLocal的基本用法。 一般情况下，我们需要一个成员变量，并且在线程里对成员变量修改，往往我们会这样写： 123456789101112131415public class ThreadLocalDemo &#123; static String name = null; public static void main(String[] args) &#123; Runnable runnable = () -&gt; &#123; name = Thread.currentThread().getName(); System.out.println(name); &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); &#125;&#125; 然而，这样写会造成线程安全问题，我们运行的结果： 解决这种对于共享资源访问造成的线程安全问题，我们可以通过对共享资源访问的线程加锁很容易解决这里的线程安全问题。可是我们想追求性能上的“极致”，不想去用“重量级”的锁，有没有一种轻量级的实现方式呢？有，我们可以通过ThreadLocal很容易的实现： 1234567891011121314151617public class ThreadLocalDemo &#123; static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); public static void main(String[] args) &#123; Runnable runnable = () -&gt; &#123; String name = threadLocal.get(); if (null == name) &#123; threadLocal.set(Thread.currentThread().getName()); name = threadLocal.get(); &#125; System.out.println(name); &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); &#125;&#125; 结果： ThreadLocal源码分析ThreadLocal方法源码分析ThreadLocal只有一个空的构造函数，两个内部类：SuppliedThreadLocal、ThreadLocalMap。 首先来看下get()方法： 1234567891011121314151617public T get() &#123; Thread t = Thread.currentThread(); //获取当前线程的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) &#123; //获取线程的ThreadLocalMap.Entry对象，key为当前ThreadLocal对象 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") //ThreadLocalMap.Entry不为空，取值 T result = (T)e.value; return result; &#125; &#125; //ThreadLocalMap.Entry为空或获取ThreadLocalMap为空，返回一个默认值 return setInitialValue();&#125; getMap()方法源码： 123ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; getMap()方法直接返回线程的threadLocals变量的值，而Thread对象里threadLocals变量是一个对ThreadLocal.ThreadLocalMap对象的引用，实质上每个线程的局部变量是存放在自己的ThreadLocalMap对象当中的，而ThreadLocalMap类是一个简化版的HashMap，稍后我们将介绍这个类。 Thread类中threadLocals变量声明： 1ThreadLocal.ThreadLocalMap threadLocals = null; setInitialValue()方法源码： 1234567891011121314private T setInitialValue() &#123; //获取默认值 T value = initialValue(); Thread t = Thread.currentThread(); //获取当前线程ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) //map不为空设置值 map.set(this, value); else //map为空，创建一个并设置值 createMap(t, value); return value;&#125; initialValue()方法可以自定义重写实现，默认initialValue()方法返回值为空。 为线程创建ThreadLocalMap方法createMap()源码： 123void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 接着看下set()方法的源码： 12345678910public void set(T value) &#123; Thread t = Thread.currentThread(); //获取线程的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) //以当前ThreadLocal对象做为key，存入ThreadLocalMap map.set(this, value); else createMap(t, value);&#125; ThreadLocal的get和set方法主要是获取线程的threadLocals(ThreadLocalMap)变量，然后对threadLocals(ThreadLocalMap)容器进行get和set操作。 ThreadLocalMap内部类ThreadLocalMap是一个简化版的HashMap，是ThreadLocal的内部类，ThreadLocalMap通过Entry数组存储数据： 1private Entry[] table; ThreadLocalMap构造函数： 123456789101112ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //创建一个Entry数组，INITIAL_CAPACITY为16，默认大小 table = new Entry[INITIAL_CAPACITY]; //key的hash值，计算方法：ThreadLocal对象的threadLocalHashCode与上数组长度减一 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); //在hash位置设置元素 table[i] = new Entry(firstKey, firstValue); //数组长度 size = 1; //设置扩容阈值，为数组长度的2/3 setThreshold(INITIAL_CAPACITY);&#125; ThreadLocal对象的threadLocalHashCode计算方法： 123456789private final int threadLocalHashCode = nextHashCode();private static final int HASH_INCREMENT = 0x61c88647;private static AtomicInteger nextHashCode = new AtomicInteger();private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT);&#125; set方法Entry是ThreadLocalMap的一个内部类，ThreadLocalMap通过set设置数据。 set方法源码： 12345678910111213141516171819202122232425262728293031323334353637private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; //获取Entry数组 Entry[] tab = table; //Entry数组长度 int len = tab.length; //计算Hash值，计算方法为ThreadLocal的threadLocalHashCode与Entry长度做与运算 int i = key.threadLocalHashCode &amp; (len-1); //在i位置尝试设置值，当失败时会尝试调用nextIndex()方法计算下一个位置并再次尝试设置新值 for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; //循环，获取Entry数组i位置元素的key ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; //如果当前线程的key已经存在在Entry数组中，直接为这个key设置值 e.value = value; return; &#125; //ThreadLocalMap引用使用的是弱引用，会带来一个问题是被GC回收了导致e.get()的key为空 if (k == null) &#123; //当出现e.get()为空时，找到一个key与传入相同的key设置新值或在指定位置设置新值 replaceStaleEntry(key, value, i); return; &#125; &#125; //i位置为null，在i位置创建新Entry tab[i] = new Entry(key, value); //新大小 int sz = ++size; //首先先清除无用数据，再判断容器大小是否超出阈值 if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) //超出阈值rehash rehash();&#125; set的逻辑是：首先计算需要存储新数据的位置i，当i位置为空时，直接在i位置new一个Entry放入数据；当i位置不为空时，取得i位置Entry元素，当Entry元素的key与需要存储元素key相等时直接设置此key位置的value为新值，当Entry元素的key为null时，需要清除key为null的Entry元素，当i位置key既不等于新元素key且i位置key不为空此时出现hash冲突，需要通过调用nextIndex()元素计算下一个位置并再次尝试。 replaceStaleEntry()源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; //往前找，找到table中第一个需要需要清理数据的下标 for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; //i位置出现key相等的，直接设置新值 e.value = value; //交换tab[i]位置元素与tab[staleSlot]元素 tab[i] = tab[staleSlot]; tab[staleSlot] = e; //table中第一个需要清理数据的下标等于需要插入数据位置下标 if (slotToExpunge == staleSlot) //由于交换了tab[i]位置元素与tab[staleSlot]元素，所以需要清理数据为i位置 slotToExpunge = i; //清理table cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; if (k == null &amp;&amp; slotToExpunge == staleSlot) //未出现key相等且table中第一个需要需要清理数据的下标等于插入新值位置下标 slotToExpunge = i; &#125; //将staleSlot位置entry元素value设置为null tab[staleSlot].value = null; //在staleSlot位置设置新值 tab[staleSlot] = new Entry(key, value); if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125; expungeStaleEntry()源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; //将staleSlot位置的value设置为null //table的staleSlot位置设置为null //大小减一 tab[staleSlot].value = null; tab[staleSlot] = null; size--; Entry e; int i; //循环遍历table数组 for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; //当出现key为空时 //将当前位置value设置为null //当前位置设置为null //数组大小减一 e.value = null; tab[i] = null; size--; &#125; else &#123; //当key不为null时，说明该元素有效 //由于数组大小可能发生改变，需要重新计算元素位置hash int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; //原位置置空 tab[i] = null; while (tab[h] != null) //当新位置不为空需要计算另一个位置 h = nextIndex(h, len); //设置元素 tab[h] = e; &#125; &#125; &#125; return i;&#125; cleanSomeSlots()方法源码： 123456789101112131415private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed;&#125; cleanSomeSlots()方法作用是遍历table数清理无用的元素。 get方法get方法再ThreadLocalMap里是getEntry，getEntry方法源码： 123456789101112private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; //获取到entry位置 int i = key.threadLocalHashCode &amp; (table.length - 1); //获取entry Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) //entry不为空并且entry的key为取值key，返回值 return e; else //entry为空或者entry的key不为取值key，返回null或value return getEntryAfterMiss(key, i, e);&#125; getEntryAfterMiss()方法： 123456789101112131415161718192021private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; //循环遍历entry数组 while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) //当key等于取值key时，返回value return e; if (k == null) //key为空，清除entry expungeStaleEntry(i); else //取下一个hash位置的entry i = nextIndex(i, len); e = tab[i]; &#125; //遍历完，未找到，返回null return null;&#125; 总结Thread中有一个引用指向其对象自己的ThreadLocalMap。ThreadLocal实现主要依赖其内部类ThreadLocalMap，ThreadLocalMap是一个简化版HashMap，其key为线程，value为需要存入的值。ThreadLocalMap的内部元素Entry继承自WeakReference，导致GC发生时，key会被垃圾收集器回收导致key为空，所以在每次set和get时会对table数组中key为null的元素进行清除以防止内存泄漏。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之Semaphore源码分析","slug":"Java并发之Semaphore源码分析","date":"2018-02-13T07:18:21.000Z","updated":"2018-02-13T09:13:24.798Z","comments":true,"path":"Java并发之Semaphore源码分析/","link":"","permalink":"https://satradj.github.io/Java并发之Semaphore源码分析/","excerpt":"Semaphore介绍Semaphore又叫做信号量，使用它可以限制同一时间访问同一资源的线程数量； 我们来看下Semaphore同步工具使用Demo：","text":"Semaphore介绍Semaphore又叫做信号量，使用它可以限制同一时间访问同一资源的线程数量； 我们来看下Semaphore同步工具使用Demo： 123456789101112131415161718192021public class SemaphoreDemo &#123; public static void main(String[] args) &#123; //只允许一个线程 Semaphore semaphore = new Semaphore(1); Runnable runnable = () -&gt; &#123; try &#123; semaphore.acquire(); System.out.println(\"线程\" + Thread.currentThread().getName() + \"获得资源，运行中......\"); Thread.sleep(3000); System.out.println(\"线程\" + Thread.currentThread().getName() + \"释放资源，结束运行！\"); semaphore.release(); &#125; catch (InterruptedException e) &#123; return; &#125; &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); new Thread(runnable, \"T3\").start(); new Thread(runnable, \"T4\").start(); &#125;&#125; 在这个Demo中，实例化了一个参数为1的Semaphore对象，在Runnable里通过semaphore.acquire()方法尝试获取资源锁，由于在实例化Semaphore对象时，传入的参数为1，所以同一时刻只允许一个线程获得资源锁，在Runnable运行结束时，通过semaphore.release()方法释放资源锁。 程序运行结果： Semaphore源码分析Semaphore源码相较于CyclicBarrier复杂一点，与ReentrantLock的源码类似，有三个内部类，Sync、NonfairSync、FairSync，其中Sync类继承自AQS类，NonfairSync与FairSync类继承字Sync类。 与ReentrantLock一样，Semaphore也有两个构造函数： 123456789101112//permits：有效资源访问线程数public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;/* * permits：有效资源访问线程数 * fair：是否为公平锁*/public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125; Semaphore构造函数中传入的有效资源访问线程数有趣的是它可以是正数和负数，当它为正数时，需要先获取锁(acquire)才能访问资源同一时间下仅能有正数个线程访问这一资源，而当其为负数时，需要先释放(release)锁才能访问资源。 首先来看下acquire()方法的源码： 12345678910111213141516171819//不带参数的acquire()方法public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;//带参数的重载acquire()方法public void acquire(int permits) throws InterruptedException &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.acquireSharedInterruptibly(permits);&#125;//AQS类acquireSharedInterruptibly()方法public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) //返回值小于0时 doAcquireSharedInterruptibly(arg);&#125; acquire()方法通过调用AQS类的acquireSharedInterruptibly()模板代码实现；在AQS类的分析中，我们已经分析过了acquireSharedInterruptibly()方法，acquireSharedInterruptibly()方法又会去调用子类的重写的tryAcquireShared()方法，在Semaphore类里面Sync类并没有重写tryAcquireShared()方法，而是交给了FairSync类和UnfairSync类去重写。 非公平锁中，tryAcquireShared()方法源码： 1234567891011121314151617protected int tryAcquireShared(int acquires) &#123; //调用父类的nonfairTryAcquireShared()方法 return nonfairTryAcquireShared(acquires);&#125;//Sync类的nonfairTryAcquireShared()方法final int nonfairTryAcquireShared(int acquires) &#123; //自旋 for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) //当新值小于0，或更新状态成功 return remaining; &#125;&#125; 在非公平锁中，tryAcquireShared通过父类nonfairTryAcquireShared方法实现，在nonfairTryAcquireShared方法中，获取AQS类的state变量值并计算新值，当新值大于等于0且更新新值成功则获取资源锁成功，否则会将该线程阻塞并放入等待队列中。 公平锁中，tryAcquireShared()方法源码： 1234567891011121314protected int tryAcquireShared(int acquires) &#123; //自旋 for (;;) &#123; //判断当前线程是否是阻塞队列队头线程 if (hasQueuedPredecessors()) //当前线程不是阻塞队列队头线程，返回-1 return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125; 在公平锁中tryAcquireShared方法与非公平锁的tryAcquireShared方法实现原理类似，不同的是，在非公平锁的tryAcquireShared方法中，首先会去判断当前线程是否是等待队列的队头线程，不是的话直接返回，将线程阻塞。 分析完加锁的源码，接着看下释放锁的源码： 12345678910111213141516171819public void release() &#123; //通过AQS类releaseShared方法实现 sync.releaseShared(1);&#125;//重载方法public void release(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.releaseShared(permits);&#125;//AQS类中releaseShared()方法：public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 在AQS类中releaseShared()方法通过子类重写的AQS类的tryReleaseShared()方法实现释放锁，tryReleaseShared()方法由Sync类实现，Sync重写tryReleaseShared()方法源码： 1234567891011121314protected final boolean tryReleaseShared(int releases) &#123; //自旋 for (;;) &#123; int current = getState(); int next = current + releases; //判断是否溢出 if (next &lt; current) // overflow throw new Error(\"Maximum permit count exceeded\"); //CAS刷新state值 if (compareAndSetState(current, next)) //返回释放成功 return true; &#125;&#125; 总结通过ReentrantLock源码与Semaphore源码的对比，发现二者的实现极为相似，ReentrantLock对象在构造时实际上同时构造出了一个state为0的AQS类(子类)，而Semaphore对象在构造时，同时构造出的AQS类(子类)的state值是由用户确定的；ReentrantLock在加锁时，当state从0变为1即加锁成功，其他线程再尝试加锁会阻塞，而Semaphore在尝试加锁时，会将state值减一(或指定值)，当state小于0或者更新state值失败时会加锁失败线程阻塞；ReentrantLock在释放锁时，会将state的值由1变成0，而Semaphore释放锁是简单的将state加一并刷新state值，成功则释放锁成功；二者均有公平锁和非公平锁之分。ReentrantLock在一定程度上可近似的认为是一个state值为1的Semaphore对象。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之CyclicBarrier源码分析","slug":"Java并发之CyclicBarrier","date":"2018-02-12T08:45:11.000Z","updated":"2018-02-12T12:47:56.833Z","comments":true,"path":"Java并发之CyclicBarrier/","link":"","permalink":"https://satradj.github.io/Java并发之CyclicBarrier/","excerpt":"CyclicBarrier介绍CyclicBarrier俗称屏障，使用它可以完成，让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。","text":"CyclicBarrier介绍CyclicBarrier俗称屏障，使用它可以完成，让一组线程到达一个屏障（同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。 我们来看下CyclicBarrier的具体使用： 123456789101112131415161718192021222324252627282930public class CyclicBarrierDemo &#123; private static int sleepTime = 0; public static void main(String[] args) &#123; CyclicBarrier cyclicBarrier = new CyclicBarrier(4); Runnable runnable = () -&gt; &#123; try &#123; synchronized (CyclicBarrierDemo.class) &#123; sleepTime++; &#125; Thread.sleep(sleepTime * 1000); System.out.println(\"线程\" + Thread.currentThread().getName() + \"到达屏障点！\"); System.out.println(\"等待线程数：\" + cyclicBarrier.getNumberWaiting()); cyclicBarrier.await(); System.out.println(\"线程\" + Thread.currentThread().getName() + \"运行！\"); &#125; catch (InterruptedException e) &#123; return; &#125; catch (BrokenBarrierException e) &#123; return; &#125; &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); new Thread(runnable, \"T3\").start(); new Thread(runnable, \"T4\").start(); &#125;&#125; 上面这个示例程序只有在四个线程都运行了cyclicBarrier.await()后，每个线程才能继续往下执行。 运行结果： CyclicBarrier还有一个可传入一个Runnable的构造函数： 1public CyclicBarrier(int parties, Runnable barrierAction) 其作用是，当最后一个线程到达屏障时，由最后一个线程执行这个Runnable； Demo： 1234567891011121314151617181920212223242526272829303132public class CyclicBarrierDemo &#123; private static int sleepTime = 0; public static void main(String[] args) &#123; Runnable done = () -&gt; &#123; System.out.println(\"执行Runnable线程：\" + Thread.currentThread().getName()); &#125;; CyclicBarrier cyclicBarrier = new CyclicBarrier(4, done); Runnable runnable = () -&gt; &#123; try &#123; synchronized (CyclicBarrierDemo.class) &#123; sleepTime++; &#125; Thread.sleep(sleepTime * 1000); System.out.println(\"线程\" + Thread.currentThread().getName() + \"到达屏障点！\"); System.out.println(\"等待线程数：\" + cyclicBarrier.getNumberWaiting()); cyclicBarrier.await(); System.out.println(\"线程\" + Thread.currentThread().getName() + \"运行！\"); &#125; catch (InterruptedException e) &#123; return; &#125; catch (BrokenBarrierException e) &#123; return; &#125; &#125;; new Thread(runnable, \"T1\").start(); new Thread(runnable, \"T2\").start(); new Thread(runnable, \"T3\").start(); new Thread(runnable, \"T4\").start(); &#125;&#125; 结果： CyclicBarrier源码分析CyclicBarrier借助ReentrantLock实现，CyclicBarrier有两个构造函数，一个内部类Generation，Generation内部类中就一个成员变量broken，CyclicBarrier通过Generation标志线程是否被打断，同时一个线程组一个Generation对象。 Generation对象源码： 123private static class Generation &#123; boolean broken = false;&#125; await()源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125;//dowait()源码：//timed：是否有超时设置；//nanos：超时时长private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; //获取Generation对象 final Generation g = generation; if (g.broken) //如果线程已经被打断，抛出异常 throw new BrokenBarrierException(); if (Thread.interrupted()) &#123; //线程收到中断信号，设置中断标志为true，并唤醒所有线程 breakBarrier(); throw new InterruptedException(); &#125; int index = --count; //当count为0时 if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) //当存在Runnable任务时，使用这最后一个线程先行执行Runnable任务 command.run(); //标志Runnable执行完成 ranAction = true; //唤醒所有线程，重置count计数器和Generation对象 nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) //若为执行完Runnable任务则设置中断标志为true，并唤醒所有线程 breakBarrier(); &#125; &#125; //自旋 for (;;) &#123; try &#123; if (!timed) //无超时设置，调用ReentrantLock的await()方法使线程处于等待状态 trip.await(); else if (nanos &gt; 0L) //存在超时设置，并超时时长大于0，调用ReentrantLock的awaitNanos()方法使线程处于超时等待状态 nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; Thread.currentThread().interrupt(); &#125; &#125; if (g.broken) throw new BrokenBarrierException(); if (g != generation) return index; if (timed &amp;&amp; nanos &lt;= 0L) &#123; breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; await()重载方法源码： 1234567public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; //调用dowait方法传入超时参数实现 return dowait(true, unit.toNanos(timeout));&#125; 总结CyclicBarrier工具类的实现主要靠对ReentrantLock的封装实现，使用了一个内部类来标识线程是否被中断；其核心方法是在同步代码里使用ReentrantLock的await()方法和awaitNanos()方法实现。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之CountDownLatch源码分析","slug":"Java并发之CountDownLatch源码分析","date":"2018-02-10T06:12:16.000Z","updated":"2018-02-10T06:12:59.185Z","comments":true,"path":"Java并发之CountDownLatch源码分析/","link":"","permalink":"https://satradj.github.io/Java并发之CountDownLatch源码分析/","excerpt":"CountDownLatch介绍CountDownLatch俗称门闩，利用它可以实现类似计数器的功能。比如有一个任务，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。","text":"CountDownLatch介绍CountDownLatch俗称门闩，利用它可以实现类似计数器的功能。比如有一个任务，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。 我们使用CountDownLatch来实现这个功能： 123456789101112131415161718192021222324252627282930313233public class CountDownLatchDemo &#123; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(4); Thread mainThread = Thread.currentThread(); Runnable runnable = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep((long) (Math.random() * 1000)); System.out.println(Thread.currentThread().getName() + \", main thread status: \" + mainThread.getState()); countDownLatch.countDown(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread t1 = new Thread(runnable, \"T1\"); Thread t2 = new Thread(runnable, \"T2\"); Thread t3 = new Thread(runnable, \"T3\"); Thread t4 = new Thread(runnable, \"T4\"); t1.start(); t2.start(); t3.start(); t4.start(); countDownLatch.await(); System.out.println(\"main end.\"); &#125;&#125; 运行结果： CountDownLatch源码分析首先看下CountDownLatch的构造方法： 12345public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); //Sync是CountDownLatch的一个内部类 this.sync = new Sync(count);&#125; CountDownLatch里有一个内部类，继承自AQS类； new CountDownLatch时传入一个int类型数值，构造函数执行时，将CountDownLatch类的内部类Sync实例化并且将传入的数值传给Sync类，Sync类构造方法： 123Sync(int count) &#123; setState(count);&#125; Sync调用其父类AQS的方法将Stats设置为传入值；CountDownLatch同步方法的实现依赖于Sync类，而Sync类通过继承AQS类； 我们来看下CountDownLatch的两个主要的方法await()和countDown()的源码，countDown()的源码: 123456789101112131415161718192021222324252627282930public void countDown() &#123; //调用AQS类的releaseShared()方法 sync.releaseShared(1);&#125;//AQS类releaseShared()方法,releaseShared方法调用子类实现的tryReleaseShared()方法public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;//Sync类实现的父类tryReleaseShared()方法protected boolean tryReleaseShared(int releases) &#123; //自旋，确保成功 for (;;) &#123; //获取state int c = getState(); if (c == 0) //为0，count down失败 return false; //减一得到新值 int nextc = c-1; //更新 if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; await()的源码： 1234public void await() throws InterruptedException &#123; //调用AQS类acquireSharedInterruptibly方法 sync.acquireSharedInterruptibly(1);&#125; 12345678910111213public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); //tryAcquireShared()方法由子类实现 if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125;//Sync类tryAcquireShared()方法protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; await()还有一个有参数的重载方法： 1234public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));&#125; 总结CountDownLatch方法的实现主要依赖于其内部类Sync，而Sync继承自AQS类，在AQS类的分析中，我们就已经介绍过了AQS类的模板代码；CountDownLatch的实现源自对AQS类的灵活运用。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之原子类源码分析(以AtomicInteger为例)","slug":"Java并发之原子类源码分析-以AtomicInteger为例","date":"2018-02-09T05:35:51.000Z","updated":"2018-02-09T06:58:57.066Z","comments":true,"path":"Java并发之原子类源码分析-以AtomicInteger为例/","link":"","permalink":"https://satradj.github.io/Java并发之原子类源码分析-以AtomicInteger为例/","excerpt":"什么是原子类在我之前的博客文章中介绍了JVM的内存模型，JVM内存模型规定了对一个变量的操作分为八步，这八步分别是：Lock（锁定）、unlock(解锁)、read（读取）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入）；也就是说，对于一个数的操作是分为八步完成的，即对一个数的操作不是一个原子操作，如：i++，在代码层面就一行代码，看似是原子操作，实际上在指令层面并不是一步完成的，而是多部完成的。这就造成了对于变量操作的线程安全问题。","text":"什么是原子类在我之前的博客文章中介绍了JVM的内存模型，JVM内存模型规定了对一个变量的操作分为八步，这八步分别是：Lock（锁定）、unlock(解锁)、read（读取）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入）；也就是说，对于一个数的操作是分为八步完成的，即对一个数的操作不是一个原子操作，如：i++，在代码层面就一行代码，看似是原子操作，实际上在指令层面并不是一步完成的，而是多部完成的。这就造成了对于变量操作的线程安全问题。 要解决这个问题很简单，我们可以使用我们之前学习的知识，利用锁来解决，但是一个简单的操作，配上锁，显得有点太过于“重量级”了；那么有没有一种不使用锁又可以实现变量操作的原子性呢？答案是有，这个方法就是我们今天说的原子类。原子类就是指通过这个类对一个变量的操作都是原子性的，操作不可分割，这样就保证了变量操作的线程安全性。 Java的原子类位于java.util.concurrent.atomic包下 AtomicInteger类源码解析使用原子类就可以很简单的实现对一个变量的原子操作，原子类的实现原理都差不多，通过调用Unsafe类的方法使用CAS算法得以实现原子类，以AtomicInteger为例，我们来看下AtomicInteger类提供给我们的几个主要方法的源码； AtomicInteger有三个成员变量： 1234private static final Unsafe unsafe = Unsafe.getUnsafe();private static final long valueOffset;private volatile int value; 其中value是用来保存值的，由于AtomicInteger类的原子操作是依赖于Unsafe实现的，所以AtomicInteger类成员变量unsafe保存了Unsafe类的实例对象，valueOffset是value变量在内存里的偏移量。 构造方法： 12345public AtomicInteger(int initialValue) &#123; value = initialValue; &#125; public AtomicInteger() &#123; &#125; 有参数构造方法传入一个int类型数据，在构造时就已经初始化了value变量。 获取value值： 12345678//获取value值public final int get() &#123; return value;&#125;//重新设置value值public final void set(int newValue) &#123; value = newValue;&#125; getAndSet方法： 123public final int getAndSet(int newValue) &#123; return unsafe.getAndSetInt(this, valueOffset, newValue);&#125; 调用Unsafe类本地方法实现，先返回当前值，然后设置为新值； compareAndSet方法： 123public final boolean compareAndSet(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, valueOffset, expect, update);&#125; compareAndSet方法给value使用CAS算法设置一个指定的值，需要传入预期值和设置的新值； 其他的一些主要方法： 1234567891011121314151617181920212223242526272829//获取值并加一public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125;//获取值并减一public final int getAndDecrement() &#123; return unsafe.getAndAddInt(this, valueOffset, -1);&#125;//获取值并增加指定值public final int getAndAdd(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta);&#125;//加一再获取值public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;//减一再获取值public final int decrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, -1) - 1;&#125;//加指定值再获取值public final int addAndGet(int delta) &#123; return unsafe.getAndAddInt(this, valueOffset, delta) + delta;&#125; 总结原子类的实现基本都是通过调用Unsafe类的方法实现的，我们可以自己获取到Unsafe类的实例来实现一个我们自己的原子类。CAS算法是保证原子类操作原子性的重要依据。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之ReentrantReadWriteLock源码分析","slug":"Java并发之ReentrantReadWriteLock源码分析","date":"2018-02-08T02:55:42.000Z","updated":"2018-02-08T02:56:51.672Z","comments":true,"path":"Java并发之ReentrantReadWriteLock源码分析/","link":"","permalink":"https://satradj.github.io/Java并发之ReentrantReadWriteLock源码分析/","excerpt":"ReadWriteLockReadWriteLock是一个读写锁接口，所谓读写锁，是对访问资源共享锁和互斥锁，一般的重入性语义为如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。","text":"ReadWriteLockReadWriteLock是一个读写锁接口，所谓读写锁，是对访问资源共享锁和互斥锁，一般的重入性语义为如果对资源加了写锁，其他线程无法再获得写锁与读锁，但是持有写锁的线程，可以对资源加读锁（锁降级）；如果一个线程对资源加了读锁，其他线程可以继续加读锁。 ReadWriteLock接口中定义了两个方法： 123456public interface ReadWriteLock &#123; Lock readLock(); Lock writeLock();&#125; ReentrantReadWriteLock源码分析ReentrantReadWriteLock实现了ReadWriteLock接口和Serializable接口： 123public class ReentrantReadWriteLock implements ReadWriteLock, java.io.Serializable &#123; ......&#125; 构造方法： 12345678910111213public ReentrantReadWriteLock() &#123; //调用有参数构造方法实现 this(false);&#125;public ReentrantReadWriteLock(boolean fair) &#123; //是否是公平锁 sync = fair ? new FairSync() : new NonfairSync(); //读锁 readerLock = new ReadLock(this); //写锁 writerLock = new WriteLock(this);&#125; 默认情况下，ReentrantReadWriteLock为非公平锁。 ReentrantReadWriteLock中有五个内部类，分别是：ReadLock、WriteLock、FairSync、NonfairSync、Sync，其中Sync继承自AQS类，FairSync、NonfairSync继承自Sync类。 ReentrantReadWriteLock读写锁同步状态通过一个整型位来表示状态，高16位表是读状态，低16位表是写状态； 12345678static final int SHARED_SHIFT = 16;static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;//返回共享锁数量static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;//返回独占锁数static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; 读锁lock我们先看下读锁，读锁的lock方法源码： 1234public void lock() &#123; //调用AQS类acquireShared方法 sync.acquireShared(1);&#125; AQS类中acquireShared源码： 123456public final void acquireShared(int arg) &#123; //尝试加锁 if (tryAcquireShared(arg) &lt; 0) //加锁失败，阻塞住 doAcquireShared(arg);&#125; 在之前的文章中分析AQS类我们说过tryAcquireShared方法在AQS类中是无法直接调用的，Sync类中实现了tryAcquireShared方法，源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647protected final int tryAcquireShared(int unused) &#123; //获取当前线程 Thread current = Thread.currentThread(); //获取线程同步状态 int c = getState(); //计算写锁是否为0并且当不为0时判断持锁线程是否为当前线程 if (exclusiveCount(c) != 0 &amp;&amp; getExclusiveOwnerThread() != current) //存在写锁，并且写锁持有者不为当前线程，加锁失败 return -1; //没有线程持有写锁，获取持有读锁数 int r = sharedCount(c); //readerShouldBlock():读锁是否需要等待，r &lt; MAX_COUNT：持有线程小于最大数（65535），compareAndSetState(c, c + SHARED_UNIT)：设置读取锁状态 if (!readerShouldBlock() &amp;&amp; r &lt; MAX_COUNT &amp;&amp; compareAndSetState(c, c + SHARED_UNIT)) &#123; //持有读锁数为0 if (r == 0) &#123; //获取读锁的第一个线程设置为当前线程 firstReader = current; //firstReader持有读锁数量为1 firstReaderHoldCount = 1; //持有读锁数不为0，且持有读锁线程为当前线程 &#125; else if (firstReader == current) &#123; //将firstReader持有读锁数量加1 firstReaderHoldCount++; //持有读锁数不为0，且持有线程不为当前线程 &#125; else &#123; //获取HoldCounter HoldCounter rh = cachedHoldCounter; //HoldCounter为空，或者获取的HoldCounter不是当前线程的HoldCounter if (rh == null || rh.tid != getThreadId(current)) //重新获取HoldCounter并设置rh和cachedHoldCounter cachedHoldCounter = rh = readHolds.get(); //rh不为空，且rh的值为0 else if (rh.count == 0) //设置线程自有的HoldCounter readHolds.set(rh); //持有读锁加1 rh.count++; &#125; //成功加锁 return 1; &#125; //自旋尝试加锁 return fullTryAcquireShared(current);&#125; readerShouldBlock()在Sync中定义为抽象类，由子类FairSync或NonfairSync实现； 对于FairSync中readerShouldBlock方法： 1234567891011121314final boolean readerShouldBlock() &#123; //调用AQS类hasQueuedPredecessors实现 return hasQueuedPredecessors();&#125;//AQS类hasQueuedPredecessors方法public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; //判断队头线程是否为当前线程，是的话返回false，否则返回true return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 对于NonfairSync中的readerShouldBlock方法： 1234567891011121314final boolean readerShouldBlock() &#123; //调用AQS类中apparentlyFirstQueuedIsExclusive实现 return apparentlyFirstQueuedIsExclusive();&#125;//AQS类apparentlyFirstQueuedIsExclusive方法final boolean apparentlyFirstQueuedIsExclusive() &#123; Node h, s; //链表头不为空，当前运行线程不为空，运行线程为独占模式返回true，否则返回false return (h = head) != null &amp;&amp; (s = h.next) != null &amp;&amp; !s.isShared() &amp;&amp; s.thread != null;&#125; 在Sync类中，还有两个内部类，分别是：HoldCounter、ThreadLocalHoldCounter，HoldCounter类有两个成员变量：count和tid，其中count是用来计数线程持有锁的数量而tid是通过一个线程的id来标志是哪个线程的HoldCounter，HoldCounter保存在每个线程的ThreadLocal中；ThreadLocalHoldCounter是ThreadLocal的子类用于维护每个线程自己的HoldCounter。 unLock读锁中unLock源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public void unlock() &#123; //调用AQS类实现 sync.releaseShared(1);&#125;//AQS类releaseShared方法public final boolean releaseShared(int arg) &#123; //尝试释放锁，交由子类实现 if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;//Sync类中tryReleaseShared方法protected final boolean tryReleaseShared(int unused) &#123; //获取当前线程 Thread current = Thread.currentThread(); //判断持有读锁线程是否为当前线程 if (firstReader == current) &#123; //判断持有读锁数量是否为1 if (firstReaderHoldCount == 1) //为1，置空firstReader firstReader = null; else //不为1，将该线程持有锁数量减1 firstReaderHoldCount--; //持有锁线程不为当前线程 &#125; else &#123; //获取到该线程的HoldCounter HoldCounter rh = cachedHoldCounter; //判断HoldCounter是否为空，且是否为该线程的HoldCounter if (rh == null || rh.tid != getThreadId(current)) rh = readHolds.get(); //获取该线程持有的锁数量 int count = rh.count; //判断是否小于1 if (count &lt;= 1) &#123; readHolds.remove(); if (count &lt;= 0) throw unmatchedUnlockException(); &#125; //将持有锁数量减1 --rh.count; &#125; //自旋确保成功 for (;;) &#123; //获取状态 int c = getState(); //更新状态值 int nextc = c - SHARED_UNIT; if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 当执行tryReleaseShared返回true后执行doReleaseShared方法，doReleaseShared方法的源码我们在AQS类分析的时候已经讲过了，故此不再赘述。 写锁lock写锁中的lock源码：123456789101112public void lock() &#123; //调用AQS类实现 sync.acquire(1);&#125;//AQS类中acquire方法public final void acquire(int arg) &#123; //tryAcquire由子类实现 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)方法在AQS类分析的时候已经分析过了。 我们来看下子类Sync中实现的tryAcquire方法： 123456789101112131415161718192021222324252627282930protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); //获取线程状态 int c = getState(); //获取写锁数量 int w = exclusiveCount(c); if (c != 0) &#123; //有线程持有写锁，且不是当前线程 if (w == 0 || current != getExclusiveOwnerThread()) //加锁失败 return false; //判断是否超过最大值 if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); // Reentrant acquire //CAS更新持锁线程数量 setState(c + acquires); //加锁成功 return true; &#125; //没有线程持有写锁，判断是否应该阻塞该线程并尝试更新持锁线程数量 if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) //应该阻塞，或者更新持锁线程数量失败 return false; //成功，设置运行线程为当前线程 setExclusiveOwnerThread(current); //加锁成功 return true;&#125; writerShouldBlock方法分公平锁与非公平锁实现； 先来看下非公平锁实现： 123final boolean writerShouldBlock() &#123; return false; // writers can always barge&#125; 公平锁writerShouldBlock实现： 1234final boolean writerShouldBlock() &#123; //调用AQS实现，hasQueuedPredecessors方法在前面已经讲述 return hasQueuedPredecessors();&#125; unLock123456789101112131415161718public void unlock() &#123; //调用AQS的release方法实现 sync.release(1);&#125;//AQS中release实现public final boolean release(int arg) &#123; //调用子类tryRelease方法 if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) //将头节点解锁，并释放头节点 unparkSuccessor(h); //解锁成功 return true; &#125; return false;&#125; tryRelease在AQS子类Sync中实现： 1234567891011121314protected final boolean tryRelease(int releases) &#123; //判断是否是当前线程执行unLock if (!isHeldExclusively()) throw new IllegalMonitorStateException(); int nextc = getState() - releases; //判断读锁数量是否应该为0 boolean free = exclusiveCount(nextc) == 0; if (free) //为0，置空当前执行线程 setExclusiveOwnerThread(null); //更新线程持有写锁数量 setState(nextc); return free;&#125; 锁降级锁降级指的是写锁降级成为读锁，如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这个过程是不能被称为锁降级的。锁降级是指把当前拥有的写锁，再获取到读锁，随后释放写锁的过程。 ReentrantReadWriteLock不支持锁升级（持有读锁，获取写锁，最后释放读锁的过程），目的也是为了数据可见性，如果读锁已经被多个线程获取，其中任意线程成功获取了写锁并且更新了数据，这个更新对其他已经获取到读锁的线程是不可见的。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"七种常用排序算法介绍","slug":"七种常用排序算法介绍","date":"2018-02-07T07:11:35.000Z","updated":"2018-03-06T05:51:27.592Z","comments":true,"path":"七种常用排序算法介绍/","link":"","permalink":"https://satradj.github.io/七种常用排序算法介绍/","excerpt":"介绍排序算法是指将一串乱序数据按照一定规则进行排列的算法；虽然排序是一个很简单的问题，但是对于排序算法的研究已经进行很多年；排序研究至今已经诞生了很多种排序算法了，而最常用常见的排序算法有七种，分别是：选择排序、插入排序、希尔排序、冒泡排序、归并排序、快速排序和堆排序。 很多其他的算法思想都源自基本排序算法，通过学习研究基本的排序算法，能有助于我们理解掌握基本排序算法衍生出来的其他算法。","text":"介绍排序算法是指将一串乱序数据按照一定规则进行排列的算法；虽然排序是一个很简单的问题，但是对于排序算法的研究已经进行很多年；排序研究至今已经诞生了很多种排序算法了，而最常用常见的排序算法有七种，分别是：选择排序、插入排序、希尔排序、冒泡排序、归并排序、快速排序和堆排序。 很多其他的算法思想都源自基本排序算法，通过学习研究基本的排序算法，能有助于我们理解掌握基本排序算法衍生出来的其他算法。 选择排序选择排序思想：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 图解(图片来自维基百科)： Java实现选择排序： 123456789101112131415161718public static void sort(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; for (int i = 0, l = array.length; i &lt; l; i++) &#123; int min = array[i]; int index = i; for (int j = i; j &lt; l; j++) &#123; if (min &gt; array[j]) &#123; min = array[j]; index = j; &#125; &#125; array[index] = array[i]; array[i] = min; &#125;&#125; 插入排序插入排序思想： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 图解(图片来自维基百科)： Java实现插入排序： 1234567891011121314public static void sort(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; for (int i = 1, l = array.length; i &lt; l; i++) &#123; int j = i; int insert = array[i]; while (j &gt; 0 &amp;&amp; insert &lt; array[j - 1]) &#123; array[j] = array[j - 1]; j--; &#125; array[j] = insert; &#125;&#125; 希尔排序希尔排序思想： 先取一个正整数 d1(d1 &lt; n)，把全部记录分成 d1 个组，所有距离为 d1 的倍数的记录看成一组，然后在各组内进行插入排序； 然后取 d2(d2 &lt; d1)； 重复上述分组和排序操作；直到取 di = 1(i &gt;= 1) 位置，即所有记录成为一个组，最后对这个组进行插入排序。一般选 d1 约为 n/2，d2 为 d1 /2， d3 为 d2/2 ，…， di = 1。 图解(图片来自维基百科)： Java实现希尔排序： 12345678910111213141516public static void sort(int[] array) &#123; int d = array.length; int length = array.length; while (d != 1) &#123; d = d / 2; for (int i = d; i &lt; length; i++) &#123; int tmp = array[i]; int j = i - d; while (j &gt;= 0 &amp;&amp; array[j] &lt; tmp) &#123; array[j + d] = array[j]; j = j - d; &#125; array[j + d] = tmp; &#125; &#125;&#125; 冒泡排序冒泡排序思想： 比较相邻的元素。 如果第一个比第二个大，就交换他们两个； 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。 在这一点，最后的元素应该会是最大的数； 针对所有的元素重复以上的步骤，除了最后一个； 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 图解(图片来自维基百科)： Java实现冒泡排序： 123456789101112131415public static void sort(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; for (int i = 0, l = array.length; i &lt; l; i++) &#123; for (int j = 1; j &lt; l - i; j++) &#123; if (array[j] &lt; array[j - 1]) &#123; int tmp = array[j - 1]; array[j - 1] = array[j]; array[j] = tmp; &#125; &#125; &#125;&#125; 冒泡排序不管数列是否有序，它都要一直循环下去，我们可以给这个算法加一个标志位，标志是否交换过，当没有发生交换时，证明此时数列已经是有序的了，无需再循环； 改进版冒泡排序： 123456789101112131415161718public static void sort(int[] array) &#123; if (array == null || array.length &lt;= 1) &#123; return; &#125; boolean isSwap = true; // 交换标志，当没发生交换时说明数组已经有序，可以跳出循环 for (int i = 0, l = array.length; i &lt; l &amp;&amp; isSwap; i++) &#123; isSwap = false; for (int j = 1; j &lt; l - i; j++) &#123; if (array[j] &lt; array[j - 1]) &#123; int tmp = array[j - 1]; array[j - 1] = array[j]; array[j] = tmp; isSwap = true; &#125; &#125; &#125;&#125; 归并排序归并排序思想： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤3直到某一指针到达序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 图解(图片来自维基百科)： Java实现归并排序： 123456789101112131415161718192021222324252627282930313233public static void sort(int[] array, int l, int m, int r) &#123; if (l == r) &#123; return; &#125; sort(array, l, (m + l) / 2, m); sort(array, m + 1, (r + m + 1) / 2, r); int[] tmp = new int[r - l + 1]; int i = l; int j = m + 1; int k = 0; while (i &lt;= m &amp;&amp; j &lt;= r) &#123; if (array[i] &lt; array[j]) &#123; tmp[k++] = array[i++]; &#125; else &#123; tmp[k++] = array[j++]; &#125; &#125; while (i &lt;= m) &#123; tmp[k++] = array[i++]; &#125; while (j &lt;= r) &#123; tmp[k++] = array[j++]; &#125; for (int x = l, y = 0, len = tmp.length; y &lt; len; x++, y++) &#123; array[x] = tmp[y]; &#125;&#125; 快速排序快速排序思想： 从数列中挑出一个元素，称为”基准”； 重新排序数列，所有比基准值小的元素摆放在基准前面，所有比基准值大的元素摆在基准后面（相同的数可以到任何一边）。在这个分区结束之后，该基准就处于数列的中间位置。这个称为分区操作； 递归地把小于基准值元素的子数列和大于基准值元素的子数列排序。 图解(图片来自维基百科)： Java实现快速排序： 1234567891011121314151617181920212223public static void sort(int[] array, int start, int end) &#123; if (start &gt;= end) &#123; return; &#125; int key = array[start]; int l = start; int h = end; while (l &lt; h) &#123; while (l &lt; h &amp;&amp; array[h] &gt;= key) &#123; h--; &#125; array[l] = array[h]; while (l &lt; h &amp;&amp; array[l] &lt;= key) &#123; l++; &#125; array[h] = array[l]; &#125; array[l] = key; sort(array, start, l - 1); sort(array, l + 1, end);&#125; 堆排序堆排序思想： 最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点； 创建最大堆：将堆所有数据重新排序； 堆排序：移除位在第一个数据的根节点，并做最大堆调整的递归运算。 堆节点关系：父节点i的左子节点在位置：(2i+1);父节点i的右子节点在位置：(2i+2); 图解(图片来自维基百科)： 12345678910111213141516171819202122232425262728293031323334353637383940public static void sort(int[] array) &#123; for (int i = 0, l = array.length; i &lt; l; i++) &#123; createHeap(array, l - i); int tmp = array[l - i - 1]; array[l - i - 1] = array[0]; array[0] = tmp; &#125;&#125;//创建大根堆private static void createHeap(int[] array, int size) &#123; for (int i = size / 2; i &gt;= 0; i--) &#123; adjust(array, i, size); print(array); &#125;&#125;//调整private static void adjust(int[] array, int position, int size) &#123; //左节点位置 int left = 2 * position + 1; //右节点位置 int right = 2 * position + 2; //左子节点大 if (left &lt; size &amp;&amp; array[position] &lt; array[left]) &#123; //交换 int tmp = array[left]; array[left] = array[position]; array[position] = tmp; adjust(array, left, size); &#125; //右子节点大 if (right &lt; size &amp;&amp; array[position] &lt; array[right]) &#123; int tmp = array[right]; array[right] = array[position]; array[position] = tmp; adjust(array, right, size); &#125;&#125; 总结最后总结下这七大排序算法的时间复杂度、空间复杂度和稳定性；以下是维基百科对时间复杂度、空间复杂度和稳定性的定义： 算法的时间复杂度是一个函数，它定性描述了该算法的运行时间。这是一个关于代表算法输入值的字符串的长度的函数。时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数。空间复杂度是指计算机科学领域完成一个算法所需要占用的存储空间，一般是输入参数的函数。它是算法优劣的重要度量指标，一般来说，空间复杂度越小，算法越好。稳定排序算法会让原本有相等键值的纪录维持相对次序。也就是如果一个排序算法是稳定的，当有两个相等键值的纪录R和S，且在原本的列表中R出现在S之前，在排序过的列表中R也将会是在S之前。 排序方法 平均时间复杂度 最好情况 最坏情况 空间复杂度 稳定性 选择排序 O(n^2) O(n^2) O(n^2) O(1) 稳定 插入排序 O(n^2) O(n) O(n^2) O(1) 稳定 希尔排序 O(nlogn)~O(n^2) O(n^1.3) O(n^2) O(1) 不稳定 冒泡排序 O(n^2) O(n) O(n^2) O(1) 稳定 归并排序 O(nlogn) O(nlogn) O(nlogn) O(n) 稳定 快速排序 O(nlogn) O(nlogn) O(n^2) O(logn)~O(n) 不稳定 堆排序 O(nlogn) O(nlogn) O(nlogn) O(1) 不稳定","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://satradj.github.io/categories/数据结构与算法/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://satradj.github.io/tags/数据结构与算法/"}]},{"title":"Java并发之ReentrantLock源码分析","slug":"Java并发之ReentrantLock源码分析","date":"2018-02-05T11:10:26.000Z","updated":"2018-02-05T11:11:20.254Z","comments":true,"path":"Java并发之ReentrantLock源码分析/","link":"","permalink":"https://satradj.github.io/Java并发之ReentrantLock源码分析/","excerpt":"Lock介绍Lock在Java中是一个接口，在这个接口中仅仅定义了6个方法： 1234567891011121314public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125;","text":"Lock介绍Lock在Java中是一个接口，在这个接口中仅仅定义了6个方法： 1234567891011121314public interface Lock &#123; void lock(); void lockInterruptibly() throws InterruptedException; boolean tryLock(); boolean tryLock(long time, TimeUnit unit) throws InterruptedException; void unlock(); Condition newCondition();&#125; 实现了Lock接口的类有：ReentrantLock、ReentrantReadWriteLock(ReentrantReadWriteLock实际上是实现了ReadWriteLock，但是其内部类ReadLock和WriteLock实现了Lock接口) 我们这里讲的是ReentrantLock，ReentrantLock是一个实现了Lock接口的可重入锁，它具有与使用synchronized修饰的语句一样的功能，具有同步的作用；同时ReentrantLock具有可重入的特性。 ReentrantLock源码分析我们来看下ReentrantLock的源码，ReentrantLock实现了Lock接口和Serializable接口： 123public class ReentrantLock implements Lock, java.io.Serializable &#123; ......&#125; 构造方法，ReentrantLock有两个构造方法： 12345678public ReentrantLock() &#123; sync = new NonfairSync(); &#125;public ReentrantLock(boolean fair) &#123; //是否为公平锁 sync = fair ? new FairSync() : new NonfairSync();&#125; 有参数的构造方法参数是标志这个lock的所是否为公平锁，默认情况下ReentrantLock为非公平锁。 ReentrantLock中有三个内部类：Sync、NonfairSync、FairSync；NonfairSync和FairSync类是Sync的子类，而Sync继承自AbstractQueuedSynchronizer抽象类，Java中的两个lock和部分并发容器都是基于AQS实现的。 然后我们来看下ReentrantLock的lock()方法的源代码： 123public void lock() &#123; sync.lock();&#125; Sync中的lock方法是个抽象方法，并没有实现，具体的实现交由子类实现；Sync中的lock方法： 1abstract void lock(); 公平锁lock()方法直接调用sync.lock()实现的，而sync变量在实例化ReentrantLock时实例化了，对于公平锁的lock： 123final void lock() &#123; acquire(1);&#125; 直接调用AbstractQueuedSynchronizer的acquire()方法，AbstractQueuedSynchronizer的acquire()方法的实现如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 公平锁中重了写父类的tryAcquire()： 1234567891011121314151617181920212223242526272829protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); //获取线程状态 int c = getState(); //没有线程处于运行状态 if (c == 0) &#123; //判断是否处于等待队列最前面，并且尝试刷新加锁状态 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; //设置运行线程为当前线程 setExclusiveOwnerThread(current); //加锁成功 return true; &#125; &#125; //有线程在运行，判断运行线程是否为当前线程，为可重入锁准备 else if (current == getExclusiveOwnerThread()) &#123; //加了多少个锁 int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); //更新状态 setState(nextc); //加锁成功 return true; &#125; //加锁失败 return false; &#125; 首先判断当前线程是否在队列队头或者线程队列是否为空并且可以将线程状态设置为acquires的值，则将当前运行线程设置为当前线程并返回true，加锁成功，否则判断当前正在执行的线程是不是当前线程，是的话，将线程持有锁加一(锁的可重入)并返回true，加锁成功，以上情况都不满足，加锁失败。 当加锁失败时，执行acquireQueued(addWaiter(Node.EXCLUSIVE), arg)，addWaiter方法将当前线程使用指定模式添加至等待节点，Node.EXCLUSIVE为独占模式，Node.SHARED为共享模式。 当加锁失败，并且将等待线程添加至等待链表后，执行acquireQueued()方法。 非公平锁对于非公平锁的lock: 123456789final void lock() &#123; //持有0个锁，直接尝试加锁 if (compareAndSetState(0, 1)) //成功设置运行线程为当前线程 setExclusiveOwnerThread(Thread.currentThread()); else //已经有线程持有锁了，加锁失败 acquire(1); &#125; 首先compareAndSetState(0, 1)直接尝试加锁，若加锁成功，设置当前运行线程为当前线程，如果失败的话，运行acquire(1); acquire()方法： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 非公平锁与公平锁一样实现了tryAcquire()方法： 1234protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125; nonfairTryAcquire()方法的实现： 1234567891011121314151617181920212223242526final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); //判断是否有线程持有锁 if (c == 0) &#123; //尝试加锁（比公平锁少了个判断是否处于等待队头） if (compareAndSetState(0, acquires)) &#123; //设置运行线程为当前线程 setExclusiveOwnerThread(current); //加锁成功 return true; &#125; &#125; //判断是否是当前线程持有锁，锁可重入 else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); //设置持有锁数量 setState(nextc); //加锁成功 return true; &#125; //加锁失败 return false; &#125; nonfairTryAcquire()方法实现与公平锁的tryAcquire()类似，不同的是公平锁需要判断当前阻塞的线程队列中当前尝试加锁的线程是否是对头和队列是否为空，而非公平锁所有线程直接尝试加锁，谁能拿到谁就加锁成功。 释放锁unLock()方法源码： 123public void unlock() &#123; sync.release(1);&#125; 直接调用AQS的实现，release源码： 123456789101112131415public final boolean release(int arg) &#123; //尝试解锁，tryRelease交由子类实现 if (tryRelease(arg)) &#123; //获取头节点 Node h = head; //判断头节点是否为空，并且线程状态是否为初始值 if (h != null &amp;&amp; h.waitStatus != 0) //唤醒节点的后置节点 unparkSuccessor(h); //解锁成功 return true; &#125; //失败 return false;&#125; tryRelease方法在Sync子类中实现，源码： 12345678910111213141516protected final boolean tryRelease(int releases) &#123; //线程状态新值，锁可重入，新状态为老状态减releases int c = getState() - releases; //尝试解锁的线程是否为当前执行线程 if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; //为0时，所有的锁都已经释放 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; //更新持有锁数量 setState(c); return free;&#125; ConditionLock可以通过lock.newCondition()来获取一个Condition，Condition是一个接口,接口中定义了await()、awaitNanos()、awaitUninterruptibly()、awaitUntil()、signal()、signalAll()这几个方法，await方法相当于Object中的wait，而signal，signalAll方法相当于Object中的notify和notifyAll方法。Object中的线程同步方法常用于synchronized中；await()、awaitNanos()、awaitUninterruptibly()、awaitUntil()、signal()、signalAll()方法用于lock.lock()代码段中对Lock进行线程之间的同步。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之AQS类介绍","slug":"Java并发之AQS类介绍","date":"2018-02-04T04:23:28.000Z","updated":"2018-02-13T08:52:15.039Z","comments":true,"path":"Java并发之AQS类介绍/","link":"","permalink":"https://satradj.github.io/Java并发之AQS类介绍/","excerpt":"AQS类介绍AQS类全称AbstractQueuedSynchronizer，Java在AQS类中提供了一系列的模板代码，用来实现Java中一系列的同步工具，很多同步工具都是通过内部类继承自AQS类，通过重写AQS类的方法来实现的，如ReentrantLock类、ReentrantReadWriteLock等。 AQS中使用了一个volatile的int类型变量state来表示线程状态，使用Node实现FIFO队列来完成线程的排队执行。","text":"AQS类介绍AQS类全称AbstractQueuedSynchronizer，Java在AQS类中提供了一系列的模板代码，用来实现Java中一系列的同步工具，很多同步工具都是通过内部类继承自AQS类，通过重写AQS类的方法来实现的，如ReentrantLock类、ReentrantReadWriteLock等。 AQS中使用了一个volatile的int类型变量state来表示线程状态，使用Node实现FIFO队列来完成线程的排队执行。 AQS类主要方法介绍AQS中通过state来表示线程状态，自然有线程状态相关的方法： 1234567protected final int getState() &#123; return state;&#125;protected final void setState(int newState) &#123; state = newState;&#125; compareAndSetState方法，compareAndSetState通过调用Unsafe中的方法来确保变量原子性的改变 123protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 一般对于一个同步工具，继承AQS类后，只需调用acquire模板代码加独占锁，调用acquireShared模板代码加共享锁acquire源码： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquireShared源码： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; AQS中还提供了如下其他的模板代码： 1234567public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; acquireInterruptibly(int arg)：以独占模式获取对象，如果被中断则中止； 1234567public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125; acquireSharedInterruptibly(int arg)：以共享模式获取对象，如果被中断则中止； 而AQS类里的tryAcquire方法和tryAcquireShared方法都是交给子类去实现，需要实现判断某线程是否能获得锁的逻辑。AQS类里调用这些个方法是直接抛出异常的，AQS类里需要子类实现的方法及作用有如下几个： tryAcquire(int arg)：尝试在独占模式下获取对象锁； tryAcquireShared(int arg)：尝试在共享模式下获取对象锁； tryRelease(int arg)：尝试释放独占锁； tryReleaseShared(int arg)：尝试释放共享锁； 独占锁acquire加锁与释放加锁acquire源码： 123456public final void acquire(int arg) &#123; //首先交由子类实现的tryAcquire方法去尝试加锁，当加锁失败后将线程放入FIFO等待队列，并再次尝试加锁 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; addWaiter接收一个节点模式的参数，这个参数在AQS内部类Node里面维护，关于Node的FIFO队列将在后面详细介绍。 addWaiter方法源码： 1234567891011121314151617181920private Node addWaiter(Node mode) &#123; //创建一个节点 Node node = new Node(Thread.currentThread(), mode); //获取尾节点 Node pred = tail; //判断是否有尾节点，即判断链表是否初始化了 if (pred != null) &#123; //将尾节点设置为新节点的前置节点 node.prev = pred; //设置尾节点 if (compareAndSetTail(pred, node)) &#123; //将老尾节点的后置节点设置为新节点 pred.next = node; return node; &#125; &#125; //链表未初始化或者设置尾节点失败 enq(node); return node;&#125; enq方法： 12345678910111213141516171819202122private Node enq(final Node node) &#123; //自旋，确保成功 for (;;) &#123; //尾节点 Node t = tail; //无尾节点，即链表未初始化 if (t == null) &#123; //创建链表 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //链表已经初始化，将node节点前置设置为尾节点 node.prev = t; //设置尾节点 if (compareAndSetTail(t, node)) &#123; //将老尾节点的后置节点设置为新节点 t.next = node; return t; &#125; &#125; &#125;&#125; 简而言之，addWaiter方法是将获取锁失败的线程添加至等待链表的尾节点； acquireQueued源码： 1234567891011121314151617181920212223242526272829final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取node前置节点 final Node p = node.predecessor(); //判断是否为头节点并且尝试加锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //获取锁成功设置头节点为当前节点 setHead(node); //释放头节点的下一个节点 p.next = null; // help GC //标志加锁成功 failed = false; return interrupted; &#125; //判断当前线程是否中断并且将线程阻塞放入等待队列 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; //加锁失败 if (failed) //取消竞争 cancelAcquire(node); &#125;&#125; 独占锁的获取流程如图所示： 释放AQS里独占锁释放的模板代码是由release()方法实现； release()方法源码： 123456789101112public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; //首先判断head节点不为空，且节点状态不为初始状态 if (h != null &amp;&amp; h.waitStatus != 0) //唤醒head节点的后继节点 unparkSuccessor(h); //返回成功 return true; &#125; return false;&#125; 共享锁acquireShared的加锁与释放加锁acquireShared源码： 12345public final void acquireShared(int arg) &#123; //交由子类tryAcquireShared方法尝试加锁 if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 子类实现的tryAcquireShared方法加锁失败后，运行AQS的doAcquireShared()方法，doAcquireShared()源码： 12345678910111213141516171819202122232425262728293031323334private void doAcquireShared(int arg) &#123; //首先将线程加入等待队列 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; //自旋 for (;;) &#123; //获取当前线程的上一个节点 final Node p = node.predecessor(); if (p == head) &#123; //当p是头节点时，再次尝试加锁 int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; //加锁成功，设置头节点为当前线程 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; //当p不为头节点，或者加锁失败时 //判断是否应该需要阻塞当前线程，需要的话阻塞当前线程并设置阻塞标志位为true if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 释放释放时通过AQS类的releaseShared()方法实现的，源码： 12345678public final boolean releaseShared(int arg) &#123; //首先由子类的实现去释放锁 if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; doReleaseShared()方法源码： 12345678910111213141516171819202122private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; //判断是否处于等待状态 if (ws == Node.SIGNAL) &#123; //重置状态标志位 if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; //唤醒下一个节点 // loop to recheck cases unparkSuccessor(h); &#125; //处于初始状态且是头节点，则需要将后面的节点设置为传播状态 else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; acquireInterruptibly()acquireInterruptibly(int arg)：以独占模式获取对象，如果被中断则中止；从上面的源码我们可以看出：它首先交由子类尝试加锁，当加锁失败时，会调用AQS类的doAcquireInterruptibly()方法； 而doAcquireInterruptibly()方法与acquireQueued()方法唯一不同的是：acquireQueued()在判断当前线程应该被中断时，将中断标识设置成true并继续运行，而doAcquireInterruptibly()方法则是判断当前线程应该被中断时，抛出异常； 源码对比如下： 123456789//acquireQueued()方法中：if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true;//doAcquireInterruptibly()方法中：if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); acquireSharedInterruptibly()acquireSharedInterruptibly(int arg)：以共享模式获取对象，如果被中断则中止；与doAcquireInterruptibly()方法一样，它与doAcquireShared()方法唯一不同的也是：它调用的doAcquireSharedInterruptibly()方法会在判断当前线程处于中断状态时会抛出异常。 源码对比如下： 123456789//doAcquireShared()方法中：if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true;//doAcquireSharedInterruptibly()方法中：if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); AQS类FIFO队列介绍前面说到AQS类里面维护了一个FIFO队列，这个队列里的每个节点代表着一个需要获取锁的线程，这个队列是个双向链表实现的；节点是定义在AQS类里的一个内部类Node，Node里有两个标志线程模式状态的变量SHARED和EXCLUSIVE，SHARED代表共享模式，EXCLUSIVE代表独占模式； Node中还用了waitStatus变量来表示线程的状态，waitStatus可取值：SIGNAL、CANCELLED、CONDITION、PROPAGATE、0； 其中SIGNAL的值为-1，代表后继结点处于等待状态，如果当前线程释放的同步状态或者被中断，将会通知后继结点，使后继结点线程运行； CANCELLED的值为1，代表同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待； CONDITION的值为-2，代表结点在等待队列中，结点线程等待在这个Condition上，当其他线程对这个Condition对象调用signal()\\signalAll()，则这个结点将进入等待队列中移入同步队列中，准备重试获取同步状态; PROPAGATE的值为-3，代表读写锁中，当读锁最开始没有获取到操作权限，得到后会发起一个doReleaseShared()动作，内部也是一个循环，当判定后续的节点状态为0时，尝试通过CAS自旋方式将状态修改为这个状态，表示节点可以运行。 0代表初始化状态； 123456789101112131415static final class Node &#123; static final Node SHARED = new Node(); static final Node EXCLUSIVE = null; static final int CANCELLED = 1; static final int SIGNAL = -1; static final int CONDITION = -2; static final int PROPAGATE = -3; volatile int waitStatus;&#125; 队列如图所示： 添加等待线程： 在AQS类中通过hasQueuedPredecessors()方法返回当前线程是否是FIFO队列的队头元素，在公平锁中一个线程需要获取锁，首先需要判断其自身是否是阻塞队列的队头元素；hasQueuedPredecessors()方法源码： 1234567public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; LockSupport类当有一个线程持有独占锁时，另一个线程尝试加独占锁就会被阻塞，而LockSupport类就是用于实现阻塞线程和唤醒线程的作用的。unpark类中所有的方法属性都是静态的，LockSupport类的park()方法将一个线程阻塞住，unpark()方法将线程唤醒。 park()方法源码： 123456public static void park(Object blocker) &#123; Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null);&#125; unpark()方法源码： 1234public static void unpark(Thread thread) &#123; if (thread != null) UNSAFE.unpark(thread);&#125; park()方法与unpark()方法均是通过Unsafe类的本地方法实现的。LockSupport除了park()方法和unpark()方法外，还有parkUntil()方法用于超时阻塞。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之CAS算法介绍","slug":"Java并发之CAS算法介绍","date":"2018-02-02T01:47:39.000Z","updated":"2018-02-02T01:51:15.670Z","comments":true,"path":"Java并发之CAS算法介绍/","link":"","permalink":"https://satradj.github.io/Java并发之CAS算法介绍/","excerpt":"CAS算法介绍CAS算法全称为Compare and swap，翻译成中文就是“比较与交换”，是一种有名的无锁算法。无锁编程，就是指在不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步。 在CAS算法中需要理解3个操作数，内存值V，旧的预期值A，要修改的新值B。 当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做，这就是CAS算法。现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰。","text":"CAS算法介绍CAS算法全称为Compare and swap，翻译成中文就是“比较与交换”，是一种有名的无锁算法。无锁编程，就是指在不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步。 在CAS算法中需要理解3个操作数，内存值V，旧的预期值A，要修改的新值B。 当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做，这就是CAS算法。现代的CPU提供了特殊的指令，可以自动更新共享数据，而且能够检测到其他线程的干扰。 Java中CAS算法的实现很多人认为Java没办法直接操作内存，其实不然，sun为Java添加了一个“后门”，可以允许Java简介的操作内存，而这个“后门”就是Unsafe类。 Unsafe类是在sun.misc包下，不属于Java标准。但是很多Java的基础类库，包括一些被广泛使用的高性能开发库都是基于Unsafe类开发的，比如Netty、Cassandra、Hadoop、Kafka等。Unsafe类在提升Java运行效率，增强Java语言底层操作能力方面起了很大的作用。 Unsafe类使Java拥有了像C语言的指针一样操作内存空间的能力，同时也带来了指针的问题。过度的使用Unsafe类会使得出错的几率变大，因此Java官方并不建议使用的，官方文档也几乎没有。Oracle正在计划从Java 9中去掉Unsafe类。 而我们的CAS算法也是在Unsafe类中实现的。 如： 1public final native boolean compareAndSwapInt(Object var1, long var2, int var4, int var5); Unsafe类中绝大部分的方法都是native方法，调用本地方法实现，CAS算法也是。 CAS算法的ABA问题CAS算法有一个经典的ABA问题； ABA问题是指，线程1从内存V中取出值为A，然后期望改成某一值，同一时刻一个线程2从内存V中取出值也为A，然后期望改为B，此时由于某些原因，线程1被阻塞，线程2继续执行，将内存V的值改为了B，然后又一线程将内存V的值改为了A，此时线程1被唤醒，由于内存V的值为A所以导致线程1修改成功。其实此时线程1对比的内存V的值A并不是开始的那个A了，应该要修改失败才对。 ABA问题在Java中的解决要解决ABA问题其实很简单，可以为内存V的值添加一个版本号或者修改次数，当预期值A与内存V值相等时而版本号或修改次数与V的版本号或修改次数不等，则拒绝修改。 Java中AtomicStampedReference类解决了ABA问题，我们来看下它是怎么实现的。 AtomicStampedReference类中有一个内部类Pair，Pair类里reference属性保存了旧的期望值，stamp属性保存了版本号或者是修改次数。 我们来看下AtomicStampedReference类的compareAndSet方法源码： 12345678910111213public boolean compareAndSet(V expectedReference, V newReference, int expectedStamp, int newStamp) &#123; Pair&lt;V&gt; current = pair; //只有当版本号相同的情况下才有可能修改成功 return expectedReference == current.reference &amp;&amp; expectedStamp == current.stamp &amp;&amp; ((newReference == current.reference &amp;&amp; newStamp == current.stamp) || casPair(current, Pair.of(newReference, newStamp)));&#125; 利用CAS算法实现一个tryLock获取Unsafe类实例Unsafe类提供了一个静态方法来获取它： 12345678public static Unsafe getUnsafe() &#123; Class var0 = Reflection.getCallerClass(); if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; throw new SecurityException(\"Unsafe\"); &#125; else &#123; return theUnsafe; &#125;&#125; 虽然Unsafe类提供了静态方法去获取它，但是我们还是拿不到，我们从源码可以看到，在调用getUnsafe方法时，对该方法做了安全限制，会抛出异常； 尽管如此，我们还是可以通过Java万能的反射来获取这个类的实例的，在Unsafe类中，Unsafe使用了theUnsafe属性来存储了自身的实例对象，我们可以通过反射，来获取Unsafe的theUnsafe属性的值，从而获取Unsafe实例。 1234Class&lt;?&gt; clazz = Unsafe.class;Field f = clazz.getDeclaredField(\"theUnsafe\");f.setAccessible(true);UNSAFE = (Unsafe) f.get(null); 构造Unsafe实现的tryLock首先我们创建一个UnsafeLock的类，来完成使用Unsafe完成锁的功能； 这个类里面我们需要一个status属性表示加锁状态，一个unsafe属性来存储Unsafe实例； Unsafe在修改一个内存值时需要传入这个内存值的偏移量，所以我们还需要一个属性来存储status的偏移量； 然后再实现我们的lock方法和unLock方法。 我们自己实现的锁源码如下： 123456789101112131415161718192021222324252627282930313233public class UnsafeLock &#123; private Unsafe unsafe; private int status = 0; private long statusOffset; private Thread localThread; public UnsafeLock() throws NoSuchFieldException, IllegalAccessException &#123; Class&lt;?&gt; clazz = Unsafe.class; Field f = clazz.getDeclaredField(\"theUnsafe\"); f.setAccessible(true); unsafe = (Unsafe) f.get(null); statusOffset = unsafe.objectFieldOffset(UnsafeLock.class.getDeclaredField(\"status\")); &#125; public void tryLock() throws Exception &#123; if (unsafe.compareAndSwapInt(this, statusOffset, 0, 1)) &#123; localThread = Thread.currentThread(); return; &#125; else &#123; throw new Exception(\"获取锁失败\"); &#125; &#125; public void unlock() &#123; if (Thread.currentThread() != localThread) return; if (unsafe.compareAndSwapInt(this, statusOffset, 1, 0)) &#123; localThread = null; &#125; &#125;&#125; 最后我们来写一个测试类来测试下这个tryLock： 12345678910111213141516171819202122public class MyLockTest &#123; private static int code = 0; public static void main(String[] args) throws Exception &#123; UnsafeLock lock = new UnsafeLock(); for (int i = 0; i &lt; 10; i++) &#123; new Thread(() -&gt; &#123; try &#123; lock.tryLock(); System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;线程\"+Thread.currentThread().getName()+\"获取锁成功&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"); for (int j = 0; j &lt; 10; j++) System.out.println(Thread.currentThread().getName() + \":\" + code++); &#125; catch (Exception e) &#123; System.out.println(\"--------线程\"+Thread.currentThread().getName()+\"获取锁失败--------\"); &#125; finally &#123; lock.unlock(); &#125; &#125;, \"t\" + i).start(); &#125; &#125;&#125; 运行的结果如下图：","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之线程安全","slug":"Java并发之线程安全","date":"2018-02-01T05:14:53.000Z","updated":"2018-03-06T05:40:34.467Z","comments":true,"path":"Java并发之线程安全/","link":"","permalink":"https://satradj.github.io/Java并发之线程安全/","excerpt":"线程不安全首先我们来看一段代码：","text":"线程不安全首先我们来看一段代码： 123456789101112131415161718192021public class SynchronizedDemo implements Runnable &#123; private static int data = 0; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; data++; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; SynchronizedDemo demo = new SynchronizedDemo(); for (int i = 0; i &lt; 1000; i++) &#123; new Thread(demo).start(); &#125; Thread.sleep(5000); System.out.println(data); &#125;&#125; 我们想程序输出10000，但是很遗憾实际运行时很多情况下都不是10000而是小于10000，原因是data++并不是原子操作，而是线程从内存中读取data值，完成自增，然后刷新内存值，在单线程的情况下，这并没有什么问题，然而在多线程的情况下，当data值完成自增后还没来得及刷新内存，这个时候另外一个线程将内存中的data完成了读取自增刷新的操作，这个时候前一个线程才将内存的数据刷新，这两个线程的两次自增只自增了一次。这就造成了线程的安全问题，线程安全问题的本质是共享资源被多个线程访问，造成了数据不一致的情况。 实现线程安全的方法要使上面的demo变成线程安全的程序很简单，这里介绍两种方法。 synchronized通过对run方法添加synchronized关键字即可实现线程安全： 123456@Override public synchronized void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; data++; &#125; &#125; synchronized可以修饰方法和代码块，被synchronized修饰的方法和代码块同一时间下只允许一个线程访问相当于给这部分添加了一个锁，任何线程在没拿到这个锁的情况下是不能访问这部分的。 lock我们还可以通过显式lock的方式为代码加锁。 通过lock的方式加锁，上面的代码可改为： 12345678910111213private final Lock lock = new ReentrantLock(true); @Override public void run() &#123; try &#123; lock.lock(); for (int i = 0; i &lt; 10; i++) &#123; data++; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; 实例化一个lock，然后为有共享资源访问的代码显式的加锁。Java中的lock有ReentrantLock和ReentrantReadWriteLock两种。 区别： Lock使用起来比较灵活，但需要手动释放和开启；采用synchronized不需要用户去手动释放锁，当synchronized方法或者synchronized代码块执行完之后，系统会自动让线程释放对锁的占用； Lock不是Java语言内置的，synchronized是Java语言的关键字，因此是内置特性。Lock是一个类，通过这个类可以实现同步访问； 在并发量比较小的情况下，使用synchronized是个不错的选择，但是在并发量比较高的情况下，其性能下降很严重，此时Lock是个不错的方案。 使用Lock的时候，等待/通知 是使用的Condition对象的await()/signal()/signalAll() ，而使用synchronized的时候，则是对象的wait()/notify()/notifyAll();由此可以看出，使用Lock的时候，粒度更细了，一个Lock可以对应多个Condition。 虽然Lock缺少了synchronized隐式获取释放锁的便捷性，但是却拥有了锁获取与是释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized所不具备的同步特性; Java提供的线程工具lock：ReentrantLock、ReentrantReadWriteLock、StampedLock(JDK8新增);原子类：AtomicXXXXXX；信号量：CountDownLatch、CyclicBarrier、Semaphore；其他的还有线程池工具，ForkJoin框架； 我们的多线程系列文章就是围绕这些个类和工具展开分析。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java并发之多线程","slug":"Java并发之多线程","date":"2018-02-01T02:31:49.000Z","updated":"2018-02-01T05:19:45.914Z","comments":true,"path":"Java并发之多线程/","link":"","permalink":"https://satradj.github.io/Java并发之多线程/","excerpt":"写在前面多线程，是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”。","text":"写在前面多线程，是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理或同时多线程处理器。在一个程序中，这些独立运行的程序片段叫作“线程”。 现代编程语言都具有编写多线程程序的能力。就Java而言被大量应用于web后端处理，在处理大量并发访问网站时，多线程技术显得尤为重要。本系列文章将从Java代码及JDK源码介绍的方式全面讲述Java对多线程的支持。 Java如何创建一个线程Java对于线程的实现具有多种方法。 继承Thread类Thread类本质是一个实现了Runnable接口的类，通过继承Thread类，复写Thread类的run()方法，调用start()方法启动一个新的线程。Thread类的定义如下： 123public class Thread implements Runnable &#123; ......&#125; 继承Thread类实现一个新线程： 123456789101112131415public class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(\"Hello Thread.\"); System.out.println(\"This is new thread.\"); &#125; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); myThread.start(); System.out.println(\"This is main thread.\"); &#125;&#125; 我们看下Thread的start()方法源码： 12345678910111213141516171819public synchronized void start() &#123; if (threadStatus != 0) //判断线程是否已经start() throw new IllegalThreadStateException(); group.add(this); //将这个线程添加至线程组 boolean started = false; try &#123; start0(); //start()方法核心逻辑，调用native本地方法来启动线程 started = true; &#125; finally &#123; try &#123; if (!started) &#123; group.threadStartFailed(this); &#125; &#125; catch (Throwable ignore) &#123; &#125; &#125; &#125; 实现Runnable接口实现Runnable接口，新建一个线程： 12345678910111213141516public class MyRunnable implements Runnable &#123; @Override public void run() &#123; System.out.println(\"Hello Thread.\"); System.out.println(\"This is new thread.\"); &#125; public static void main(String[] args) &#123; MyRunnable myRunnable = new MyRunnable(); Thread t = new Thread(myRunnable); t.start(); System.out.println(\"This is main thread.\"); &#125;&#125; 实现Runnable接口后需要复写Runnable的run方法，然后将子类作为参数传入Thread的构造方法中，然后调用Thread的start()方法来启动这个线程。我们可以通过JDK8提供的lambda表达式来简化这个代码。lambda表达式实现： 1234567891011public class MyRunnable &#123; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; System.out.println(\"Hello Thread.\"); System.out.println(\"This is new thread.\"); &#125;).start(); System.out.println(\"This is main thread.\"); &#125;&#125; 实现Callable接口123456789101112131415161718public class MyCallable implements Callable&lt;String&gt; &#123; @Override public String call() throws Exception &#123; System.out.println(\"Hello Thread.\"); System.out.println(\"This is new thread.\"); return null; &#125; public static void main(String[] args) &#123; MyCallable myCallable = new MyCallable(); FutureTask&lt;String&gt; futureTask = new FutureTask&lt;String&gt;(myCallable); Thread t = new Thread(futureTask); t.start(); System.out.println(\"This is main thread.\"); &#125;&#125; 实现Callable接口的方式来实现多线程，首先需要复写Callable的call()方法，然后将子类作为参数传入FutureTask的构造函数，再将FutureTask的实例作为参数传入Thread的构造函数，最后调用Thread方法的start()方法启动新的线程。 实现多线程方式对比细心的读者可能已经发现了，我们在通过实现Callable方法实现多线程的方式中，在复写call()方法时是可以抛出异常和有返回值的。 通过继承Thread类和实现Runnable接口实现的多线程方式是不能有返回值和抛出异常的，如果你需要在新的线程中抛出异常并且带有返回值的话，你需要通过实现Callable接口的方式来实现多线程。 线程生命周期在调用start()方法后，线程并不是立马在执行，而是处于可运行状态，等待cpu分配资源才会运行，当线程没有了cpu资源时线程又会处于可运行状态。当处于运行状态的线程被sleep、wait、join等，线程的状态会变为阻塞状态，当阻塞的线程被唤醒时，线程又处于可运行状态等待cup分配资源进而运行，当线程运行完或者因为异常退出时，此时线程处于死亡状态。线程的生命周期可用图表示： 守护线程什么是守护线程在线程启动前，调用Thread的setDaemon(true)方法可将线程设置为守护线程。 thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常。你不能把正在运行的常规线程设置为守护线程。 在Daemon线程中产生的新线程也是Daemon的。 只要当前JVM实例中尚存在任何一个非守护线程没有结束，守护线程就全部工作；只有当最后一个非守护线程结束时，守护线程随着JVM一同结束工作。Daemon的作用是为其他线程的运行提供便利服务。JVM在启动时，系统就自动生成了一些守护线程，如GC线程就是个守护线程。 守护线程的用途在现在分布式系统架构中，很多组件需要和server维持一个心跳连接发送心跳包，这个时候用守护线程来实现这个心跳包的发送最好不过了。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/categories/Java并发/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"https://satradj.github.io/tags/Java并发/"}]},{"title":"Java虚拟机之JVM启动参数大全","slug":"Java虚拟机之JVM启动参数大全","date":"2018-01-31T02:47:12.000Z","updated":"2018-02-01T05:20:08.251Z","comments":true,"path":"Java虚拟机之JVM启动参数大全/","link":"","permalink":"https://satradj.github.io/Java虚拟机之JVM启动参数大全/","excerpt":"说明本文所有的参数是基于JDK7的HotSpot虚拟机，适用于JDK7及以前版本，JDK7后续版本参数是否有效请自测。 对于启用或关闭功能选项：-XX:+&lt;option&gt;打开某功能；-XX:-&lt;option&gt;关闭某功能； 对于数字型选项：-XX:&lt;option&gt;=&lt;number&gt;，若需要表示大小，可在数字后添加k、m、g； 对于字符串选项：-XX:&lt;option&gt;=&lt;string&gt;，用于指定文件，路径或命令列表；","text":"说明本文所有的参数是基于JDK7的HotSpot虚拟机，适用于JDK7及以前版本，JDK7后续版本参数是否有效请自测。 对于启用或关闭功能选项：-XX:+&lt;option&gt;打开某功能；-XX:-&lt;option&gt;关闭某功能； 对于数字型选项：-XX:&lt;option&gt;=&lt;number&gt;，若需要表示大小，可在数字后添加k、m、g； 对于字符串选项：-XX:&lt;option&gt;=&lt;string&gt;，用于指定文件，路径或命令列表； 参数列表功能选项 参数与默认值 描述 -XX:-AllowUserSignalHandlers 允许使用用户自定义的信号处理器 (只对应Solaris和Linux) -XX:AltStackSize=16384 修改栈容量 (单位 Kb) (对应Solaris, JDK 5.0以后弃用) -XX:-DisableExplicitGC 禁止手动调用System.gc() -XX:+FailOverToOldVerifier 如果新的类型校验器验证失败使用旧版本的类型校验器 (开始于JDK6.) -XX:+HandlePromotionFailure 关闭新生代收集担保(java5以前是默认不启用，java6默认启用) -XX:+MaxFDLimit 将文件描述符加到最大 (对应Solaris) -XX:PreBlockSpin=10 控制多线程自旋锁优化的自旋次数 -XX:-RelaxAccessControlCheck 放宽类型校验机的准入控制(JDK6) -XX:+ScavengeBeforeFullGC 在full GC之前先做年轻代GC (开始于JDK1.4.1.) -XX:+UseAltSigs 为了防止与其他发送信号的应用程序冲突，允许使用候补信号替代 SIGUSR1和SIGUSR2(限于Solaris) -XX:+UseBoundThreads 绑定所有的用户线程到内核线程, 减少线程进入饥饿状态（得不到任何cpu time）的次数(限于Solaris) -XX:-UseConcMarkSweepGC 使用并发的mark-sweep GC收集年老代 (始于JDK1.4.1) -XX:+UseGCOverheadLimit 使用一种限制VM做GC操作的时间所占比例过高的策略 (始于JDK6.) -XX:+UseLWPSynchronization 使用轻量级进程同步替代线程同步 (始于JDK1.4.0. Solaris相关) -XX:-UseParallelGC 使用并发平行GC(始于JDK1.4.1) -XX:-UseParallelOldGC 使用并发平行GC做 full GC. (始于JDK5.0 update 6.) -XX:-UseSerialGC 使用串行GC (始于JDK5.0.) -XX:-UseSpinning 启用多线程自旋锁优化(java1.4.2和1.5需要手动启用) -XX:+UseTLAB 启用线程本地缓存区(1.4.2以前和使用-client选项时，默认不启用，其余版本默认启用) -XX:+UseSplitVerifier 使用新的Class类型校验器(java5默认不启用, java6默认启用) -XX:+UseThreadPriorities 使用本地线程的优先级 -XX:+UseVMInterruptibleIO 在solaris中，允许运行时中断线程(限于solaris) G1垃圾收集器选项 参数与默认值 描述 -XX:+UseG1GC 使用G1垃圾处理器 -XX:MaxGCPauseMillis=n 设置并行收集最大暂停时间，这是一个理想目标，JVM将尽最大努力来实现它 -XX:InitiatingHeapOccupancyPercent=n 启动一个并发垃圾收集周期所需要达到的整堆占用比例。这个比例是指整个堆的占用比例而不是某一个代（例如G1）,如果这个值是0则代表‘持续做GC’。默认值是45 -XX:NewRatio=n 设置年轻代和年老代的比值。例如:值为3，则表示年轻代与年老代比值为1：3，年轻代占整个年轻代年老代和的1/4 -XX:SurvivorRatio=n 年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如：3，表示Eden：Survivor=3：2，一个Survivor区占整个年轻代的1/5 -XX:MaxTenuringThreshold=n 设置垃圾最大存活阀值。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论 -XX:ParallelGCThreads=n 配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等 -XX:ConcGCThreads=n 并发垃圾收集器线程数 -XX:G1ReservePercent=n 设置保留用来做假天花板以减少晋升（新生代对象晋升到老生代）失败可能性的堆数目 -XX:G1HeapRegionSize=n 使用G1垃圾回收器，java堆被划分成统一大小的区块。这个选项设置每个区块的大小。最小值是1Mb，最大值是32Mb 性能选项 参数与默认值 描述 -XX:+AggressiveOpts 启用JVM开发团队最新的调优成果。例如编译优化，偏向锁，并行年老代收集等(JDK 5 update 6后引入，但需要手动启用, JDK6默认启用) -XX:CompileThreshold=10000 通过JIT编译器，将方法编译成机器码的触发阀值，可以理解为调用方法的次数，例如调1000次，将方法编译为机器码 -XX:LargePageSizeInBytes=4m 设置堆内存的内存页大小 -XX:MaxHeapFreeRatio=70 GC后，如果发现空闲堆内存占到整个预估上限值的70%，则收缩预估上限值 -XX:MaxNewSize=size 新生代占整个堆内存的最大值 -XX:MaxPermSize=64m Perm（俗称方法区）占整个堆内存的最大值 -XX:MinHeapFreeRatio=40 GC后，如果发现空闲堆内存占到整个预估上限值的40%，则增大上限值 -XX:NewRatio=2 新生代和年老代的堆内存占用比例, 例如2表示新生代占年老代的1/2，占整个堆内存的1/3 -XX:NewSize=2m 新生代预估上限的默认值 -XX:ReservedCodeCacheSize=32m 设置代码缓存的最大值，编译时用 -XX:SurvivorRatio=8 Eden与Survivor的占用比例 -XX:TargetSurvivorRatio=50 实际使用的survivor空间大小占比。默认是50%，最高90% -XX:ThreadStackSize=512 线程堆栈大小 -XX:+UseBiasedLocking 启用偏向锁 -XX:+UseFastAccessorMethods 优化原始类型的getter方法性能(get/set:Primitive Type) -XX:-UseISM 启用solaris的ISM -XX:+UseLargePages 启用大内存分页 -XX:+UseMPSS 启用solaris的MPSS，不能与ISM同时使用 -XX:+UseStringCache 启用缓存常用的字符串 -XX:AllocatePrefetchLines=1 在使用JIT生成的预读取指令分配对象后读取的缓存行数。如果上次分配的对象是一个实例则默认值是1，如果是一个数组则是3 -XX:AllocatePrefetchStyle=1 预读取指令的生成代码风格0- 无预读取指令生成 1-在每次分配后执行预读取命令 2-当预读取指令执行后使用TLAB()分配水印指针来找回入口 -XX:+UseCompressedStrings 其中，对于不需要16位字符的字符串，可以使用byte[] 而非char[]。对于许多应用，这可以节省内存，但速度较慢（5％-10％） -XX:+OptimizeStringConcat 优化字符串连接操作在可能的情况下 调试选项 参数与默认值 描述 -XX:-CITime 打印发费在JIT编译上的时间 -XX:ErrorFile=./hs_err_pid&lt;pid&gt;.log 错误文件 -XX:-ExtendedDTraceProbes 启用性能的影响DTrace探测器 -XX:HeapDumpPath=./java_pid&lt;pid&gt;.hprof 指定HeapDump的文件路径或目录 -XX:-HeapDumpOnOutOfMemoryError 当抛出OOM时进行HeapDump -XX:OnError=”&lt;cmd args&gt;;&lt;cmd args&gt;” 当发生错误时执行用户指定的命令 -XX:OnOutOfMemoryError=”&lt;cmd args&gt;; &lt;cmd args&gt;” 当发生OOM时执行用户指定的命令 -XX:-PrintClassHistogram 当Ctrl+Break发生时打印Class实例信息,与jmap -histo相同 -XX:-PrintConcurrentLocks 当Ctrl+Break发生时打印java.util.concurrent的锁信息, 与jstack -l相同 -XX:-PrintCommandLineFlags 打印命令行上的标记 -XX:-PrintCompilation 当方法被编译时打印信息 -XX:-PrintGC 当GC发生时打印信息 -XX:-PrintGCDetails 打印GC详细信息 -XX:-PrintGCTimeStamps 打印GC用时 -XX:-PrintTenuringDistribution 打印Tenuring年龄信息 -XX:-PrintAdaptiveSizePolicy 打印自适应调整 -XX:-TraceClassLoading 跟踪类加载 -XX:-TraceClassLoadingPreorder 跟踪所有加载的引用类 -XX:-TraceClassResolution 跟踪常量池的变化 -XX:-TraceClassUnloading 跟踪类的卸载 -XX:-TraceLoaderConstraints 打印class的装载策略变化信息到stdout。 -XX:+PerfDataSaveToFile 退出时保存jvmstat二进制文件 -XX:ParallelGCThreads=n 设置新生代与老年代并行垃圾回收器的线程数 -XX:+UseCompressedOops 使用compressed pointers。这个参数默认在64bit的环境下默认启动，但是如果JVM的内存达到32G后，这个参数就会默认为不启动，因为32G内存后，压缩就没有多大必要了，要管理那么大的内存指针也需要很大的宽度了 -XX:+AlwaysPreTouch 在JVM 初始化时预先对Java堆进行摸底 -XX:AllocatePrefetchDistance=n 为对象分配设置预取距离 -XX:InlineSmallCode=n 当编译的代码小于指定的值时,内联编译的代码 -XX:MaxInlineSize=35 内联方法的最大字节数 -XX:FreqInlineSize=n 内联频繁执行的方法的最大字节码大小 -XX:LoopUnrollLimit=n 代表节点数目小于给定值时打开循环体 -XX:InitialTenuringThreshold=7 设置初始的对象在新生代中最大存活次数 -XX:MaxTenuringThreshold=n 设置对象在新生代中最大的存活次数,最大值15,并行回收机制默认为15,CMS默认为4 -Xloggc:&lt;filename&gt; 输出GC详细日志信息至指定文件 -XX:-UseGCLogFileRotation 开启GC日志文件切分功能，前置选项 -Xloggc -XX:NumberOfGClogFiles=1 设置切分GC日志文件数量，文件命名格式：.0, .1, …, .n-1 -XX:GCLogFileSize=8K GC日志文件切分大小 参考文献HotSpot官方文档","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/tags/Java虚拟机/"}]},{"title":"Java虚拟机之内存模型与volatile","slug":"Java虚拟机之内存模型与volatile","date":"2018-01-30T06:47:23.000Z","updated":"2018-02-01T05:20:11.697Z","comments":true,"path":"Java虚拟机之内存模型与volatile/","link":"","permalink":"https://satradj.github.io/Java虚拟机之内存模型与volatile/","excerpt":"硬件效率与一致性尽管现代内存的速度在不断提高，但是内存的速度与cpu比起来还不在一个量级，为了提升计算速度，在内存和处理器之间加上一个高速缓存来作为内存和处理器之间的缓冲。基于高速缓存的方法很好的解决了处理器与内存的矛盾，但是也引入了一个新的问题：缓存一致性。每个处理器都有自己的高速缓存，而他们又共享一个主内存。当处理多个处理器的运算任务都涉及同一个主内存区域时，将可能导致各自的缓存数据不一致，如果真发生这种情况，将同步到主内存的数据到底以谁的缓存数据为准。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。","text":"硬件效率与一致性尽管现代内存的速度在不断提高，但是内存的速度与cpu比起来还不在一个量级，为了提升计算速度，在内存和处理器之间加上一个高速缓存来作为内存和处理器之间的缓冲。基于高速缓存的方法很好的解决了处理器与内存的矛盾，但是也引入了一个新的问题：缓存一致性。每个处理器都有自己的高速缓存，而他们又共享一个主内存。当处理多个处理器的运算任务都涉及同一个主内存区域时，将可能导致各自的缓存数据不一致，如果真发生这种情况，将同步到主内存的数据到底以谁的缓存数据为准。为了解决一致性问题，需要各个处理器访问缓存时都遵循一些协议。 除了增加高速缓存之外，为了使得处理器内部的运算单元尽可能被充分利用，处理器可能会对输入代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与代码中的顺序一致。因此，如果某个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。Java虚拟机的即时编译器中也有类似的指令重排序优化。 Java内存模型Jvava虚拟机规范中通过定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存差异，来实现Java程序在各种平台下都能达到一致的内存访问效果。 主内存与工作内存Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量与Java中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量和方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。 Java内存模型规定了所有的变量都存储在主内存中。每个线程还有自己的工作内存，线程的工作内存中保存了被该线程中使用到的变量的主内存拷贝副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。 内存间交互操作关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之类的同步细节，Java内存模型中定义了8种操作来完成。 Lock（锁定）：作用于主内存的变量，他把变量标识为一个线程独占的状态。 unlock(解锁) ：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。 read（读取）：作用于主内存的变量，它把一个变量的值从主内存中读取到线程工作内存中，以便随后的load动作使用。 load（载入）：作用于工作内存中的变量，它把read操作从主内存中得到的变量值放入工作内存中的变量副本中。 use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令将会执行这个操作。 assign（赋值）：作用于工作内存的变量，它把执行引擎接收到的值付给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 store（存储）：作用于工作内存的变量，它把工作内存中的一个变量的值传递到主内存中，以便随后的write操作使用。 write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。 如果要把一个变量从主内存复制到工作内存，就要顺序地执行read和load操作，如果把变量从工作内存同步回主内存，就要顺序地执行store和write操作。Java内存模型还规定了在执行上述8种基本操作必须满足如下规则： 不允许read和load。store和write操作之一单独出现。 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。 不允许一个线程无原因的把数据从线程的工作内存同步回主内存。 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用了一个未被初始化的变量，换句话说，就是一个变量实施use、store操作之前，必须先执行过了assign和load操作。 一个变量在同一个时刻只允许一个线程对其进行lock操作，但lock操作可以被同一条操作重复执行多次，多次执行lock之后，只有执行相同次数的unlock操作，变量才会被解锁。 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新load和assign操作初始化变量的值。 如果一个变量实现没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去lock一个被其他线程锁定住的变量。 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中。 volatile首先介绍一下volatile所修饰的变量的特性： 第一是保证此变量对所有线程的可见性，这里的“可见性”是指当一个线程修改了这个变量的值，新值对于其他线程来说是可以立即得到的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成。 volatile的第二个作用是禁止指令重排序优化，普通的变量仅能保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码执行的顺序一致。 long和double型变量的特殊规则Java内存中对于lock、unlock、read、load、use、assign、store、write八种操作都是具有原子性的，但是对于64位的数据类型，在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile关键字修饰的64位数据的读写操作划分为两次32位的操作来进行。即虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性。 如果多个线程共享一个并未被声明为volatile的long和double类型的变量，并且同时对它们进行了读取和修改操作，那么某些线程可能读取到一个并非原值，也不是被其他线程修改的代表了“半个变量的数值”。 为避免这种情况，现在的各种商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待。因此我们在编写代码时一般不需把long和double变量专门声明为volatile。 原子性、可见性和有序性原子性：由Java内存模型来直接保证的原子性操作包括read,load,assign.use,store,和write。应用到更大的场景中时，Java内存模型还提供了lock和unlock操作来满足这个需求，尽管虚拟机未把lock和unlock操作直接开放给用户使用，但是却提供了更高层次的字节码指令monitorenter和monitorexit来隐式的使用这两个操作，这两个字节码反映到Java代码中就是同步块：synchronized关键字。因此在synchronized块之间的操作也具有原子性。 可见性：可见性是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取之前从主内存刷新左边两只这种依赖主内存作为传递媒介的方式来实现可见性，无论是普通变量还是volatile变量都是如此。普通变量和volatile变量的区别在于volatile变量的特殊规则保证了新值能够立即同步到主内存，以及每次使用前能够立即从主内存刷新。因此可以说volatile关键字保证了多线程操作时变量的可见性，而不同变量不能保证这一点。 Java还有两个关键字来保证可见性：即synchronized和final。synchronized的可见性是由“一个变量执行unlock操作之前，必须先把变量同步回主内存中”这条规则获得的。final关键字的可见性是指:被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”引用传递出去，那么其他线程就能看见final关键字的值。 有序性：如果在本线程中观察其他线程，所有操作都是无序的。Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。而volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则来获得的。这个规则决定了拥有同一个锁的两个同步块只能串行的进入。 先行发生原则(happen-before原则)如果Java内存中所有的有序性都是依靠volatile和synchronized来完成，那么有一些操作将会变得很繁琐。但是Java语言中有一个“先行发生”的原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的重要依据。 先行发生原则：在Java内存模型中定义了两项操作顺序之间的偏序关系，如果操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”包括修改了内存中共享变量的值，发送了消息，调用了方法等。 Java内存模型中包括下列一些天生发生的先行发生关系，如果两个操作之间不在此列，虚拟机可以对它们随意地进行重排序： 程序次序执行规则：在一个线程内，按照代码顺序执行，前面的操作先行发生于书写在后面的操作。 管程锁定规则：一个unlock操作先行发生于后面（时间上的先后）对同一个锁的lock操作。 volatile变量规则：对于一个volatile变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。 线程终止规则：线程的所有操作都先行发生于对此线程的终止操作 线程中断规则：对线程interrupt（）方法的调用先行发生于被中断线程的代码检测到中断时间的发生。 对象终结规则：一个对象的初始化完成先行发生于它的finalize（）方法的开始。 传递性：若A先行于B发生，B先行于C，那么得出A先行于C 我们衡量并发安全问题的时候不要受到时间顺序地干扰，必须以先行发生原则为准。 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/tags/Java虚拟机/"}]},{"title":"Java虚拟机之类加载器","slug":"Java虚拟机之类加载器","date":"2018-01-29T08:17:23.000Z","updated":"2018-02-01T05:20:22.386Z","comments":true,"path":"Java虚拟机之类加载器/","link":"","permalink":"https://satradj.github.io/Java虚拟机之类加载器/","excerpt":"类加载器介绍类加载器负责将class文件加载到内存中，并为之生成对应的java.lang.Class对象。对于任意一个类，都需要加载它的类加载器和这个类本身来确定该类在JVM中唯一性，也就是说，同一个class文件用两个不同的类加载器加载并创建两个java.lang.Class对象，即使两个对象来源自同一个class文件，它们也是不相等的，这里“相等”包括Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法，也包括使用instanceof关键字做对象所属关系判定情况。","text":"类加载器介绍类加载器负责将class文件加载到内存中，并为之生成对应的java.lang.Class对象。对于任意一个类，都需要加载它的类加载器和这个类本身来确定该类在JVM中唯一性，也就是说，同一个class文件用两个不同的类加载器加载并创建两个java.lang.Class对象，即使两个对象来源自同一个class文件，它们也是不相等的，这里“相等”包括Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法，也包括使用instanceof关键字做对象所属关系判定情况。 类加载器分类虚拟机提供了3种类加载器，启动（Bootstrap）类加载器、扩展（Extension）类加载器、应用程序（Application）类加载器（也称应用类加载器） Bootstrap ClassLoader该类加载器没有父类加载器，它负责加载虚拟机的核心类库。Bootstrap ClassLoader加载器用于在启动JVM时加载类，以使JVM能正常工作，因而它是用Native（c++）代码实现的，最早被创建出来，处于最底层。它并没有继承java.lang.ClassLoader类。 我们可以来看下Bootstrap ClassLoader加载了哪些类，查看Bootstrap ClassLoader加载的类可以通过System.getProperty(“sun.boot.class.path”)看到： 123456public class ClassLoaderTest &#123; public static void main(String[] args) &#123; String path = System.getProperty(\"sun.boot.class.path\"); Arrays.asList(path.split(\";\")).forEach(System.out::println); &#125;&#125; 结果： Extension ClassLoader该类加载器的父类加载器是根类加载器。它从java.ext.dirs系统属性所指定的目录获取加载类库或从JDK的安装目录的jre\\lib\\ext子目录下加载类库。如果把jar放到这个目录下，也会自动用扩展类加载器加载。扩展类加载器是java类，是java.lang.ClassLoader类的子类。 Application ClassLoader应用类加载器它的父类加载器是扩展类加载器，它将加载CLASSPATH中配置的目录和jar文件，它是用户自定义类加载器的默认父类加载器，系统类加载器是java类，是java.lang.ClassLoader类的子类。 类加载器之间的关系可用如图表示： 自定义类加载器用户可以自定义类加载器，自定义类加载器只需要继承java.lang.ClassLoader，重写父类的findClass方法即可完成自定义类加载器的编写。 我们自己动手写一个类加载器，加载位于D盘根目录下的类： 1234567891011121314151617181920212223242526272829303132333435363738public class MyClassLoader extends ClassLoader &#123; private final String dir = \"D:/\"; //重写父类findClass方法 @Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; //Java包是以目录形式存在在磁盘中，所以我们需要将.替换成/ String className = name.replace(\".\", \"/\"); File classFile = new File(dir, className + \".class\"); if (!classFile.exists()) &#123; throw new ClassNotFoundException(); &#125; //将类读成字节数组 byte[] classBytes = loadClassBytes(classFile); if (classBytes == null || classBytes.length == 0) &#123; throw new ClassNotFoundException(); &#125; return this.defineClass(name, classBytes, 0, classBytes.length); &#125; private byte[] loadClassBytes(File classFile) &#123; //JDK7语法糖，try with resource语法，可以不用手动的关闭资源 try (ByteArrayOutputStream bout = new ByteArrayOutputStream(); FileInputStream fin = new FileInputStream(classFile)) &#123; byte[] buffer = new byte[1024]; int len; while ((len = fin.read(buffer)) != -1) &#123; bout.write(buffer, 0, len); &#125; bout.flush(); return bout.toByteArray(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return null; &#125;&#125; 新建一个HelloWorld类编译后放在D盘下： 12345public class HelloWorld &#123; public String hello() &#123; return \"Hello World!\"; &#125;&#125; 测试我们的类加载器： 12345678910111213public class ClassLoaderTest &#123; public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException &#123; MyClassLoader classLoader = new MyClassLoader(); Class&lt;?&gt; clazz = classLoader.loadClass(\"com.satra.classloader.HelloWorld\"); System.out.println(clazz); System.out.println(clazz.getClassLoader()); Object obj = clazz.newInstance(); Method method = clazz.getMethod(\"hello\", null); Object o = method.invoke(obj, null); System.out.println(o); &#125;&#125; 输出结果： 类加载器双亲委派模型前面我们说过，同一个class文件用两个不同的类加载器加载并创建两个java.lang.Class对象，即使两个对象来源自同一个class文件，它们也是不相等的。例如当我们自定义的类加载器加载了java.lang包中的String类，这样会造成内存中存在两个String的Class对象，而这两个Class对象的实例对象的eques会不相等，对虚拟机的稳定运行造成危害。所以虚拟机定义了双亲委派模型来解决这个问题。 双亲委派模型是指：某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成类加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。 我们可以看下JDK类加载器源码的实现： 123456789101112131415161718192021222324252627282930313233protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; //首先看这个类加载器是否有父类 if (parent != null) &#123; //有父类交由父类去加载 c = parent.loadClass(name, false); &#125; else &#123; //没有父类说明这个类加载器是Bootstrap类加载器调用本地方法去加载 c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; &#125; //有父类且父类不能完成加载或者没有父类时，调用findClass完成加载 if (c == null) &#123; long t1 = System.nanoTime(); c = findClass(name); sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/tags/Java虚拟机/"}]},{"title":"Java虚拟机之类加载机制","slug":"Java虚拟机之类加载机制","date":"2018-01-28T05:39:09.000Z","updated":"2018-02-01T05:20:28.870Z","comments":true,"path":"Java虚拟机之类加载机制/","link":"","permalink":"https://satradj.github.io/Java虚拟机之类加载机制/","excerpt":"概述Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 与其他语言不同的是在Java语言里，类的加载、连接和初始化过程都是在程序运行期间完成的，Java里可动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。","text":"概述Java虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 与其他语言不同的是在Java语言里，类的加载、连接和初始化过程都是在程序运行期间完成的，Java里可动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。 类加载的三个阶段Java类加载分为三个阶段，分别是：加载、连接、初始化；其中连接阶段又可以分为三个阶段，这三个阶段分别是：验证、准备、解析。类加载的三个阶段可如下图所示： Java虚拟机规范中并没有规定什么时候开始进行加载，这点交由虚拟机自己实现，但是对于初始化阶段，虚拟机规范则进行了严格的规定。 Java虚拟机规范中规定以下六种情况必须立即对类进行初始化： 遇到new、getstatic、putstatic、invokestatic这四条字节码时，如果类没有进行过初始化，则需先触发其初始化； 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类还没有进行初始化，则需要先触发其初始化； 当初始化一个类时，其父类还没有进行过初始化，则需要先触发其父类的初始化； 对一个类或接口的静态变量进行访问或者赋值操作时，这个类或者接口还没有进行过初始化，则需要先触发其初始化； 当虚拟机启动时，用户指定一个需要执行的主类，虚拟机会先初始化这个主类； 当调用一个类的静态方法时，这个类还没有进行过初始化，则需要先触发其初始化； Java虚拟机规范中规定的这六种情况触发的初始化情景称为对一个类的主动引用。除此之外，所有引用类的方式都不会触发初始化，称之为被动引用。 被动引用的几个个例子： 通过子类引用父类的静态字段，不会导致子类初始化 12345678910111213141516class Father&#123; static int count = 1; static&#123; System.out.println(\"Initialize class Dfather\"); &#125; &#125; class Son extends Father&#123; static&#123; System.out.println(\"Initialize class Dson\"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; int x = Son.count; &#125; &#125; 通过数组定义类引用类，不会触发此类的初始化 12345678910class A&#123; static&#123; System.out.println(\"Initialize class E\"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; A[] e = new A[10]; &#125; &#125; 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 1234567891011class A&#123; static final int count = 1; static&#123; System.out.println(\"Initialize class F\"); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; int x = A.count; &#125; &#125; 类加载过程加载阶段加载是类加载过程的一个阶段，类加载阶段需要完成以下三件事情： 通过一个类的全限定名来获取定义此类的二进制字节流； 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构； 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口； 加载阶段生成的Class对象是一个Java对象，在Java虚拟机规范中并没有规定这个Class对象存放在哪个内存区域，对于HotSpot虚拟机而言，它将Class对象存放在了方法区中。 虚拟机规范中也没有规定被加载类的来源，类可以从本地磁盘中加载也可以从内存中加载还可以从网络中加载，总之规范中没有规定加载类的来源，只要被加载的类符合虚拟机规范的类文件结构，那么这个类就可以被加载。 连接阶段在加载阶段完成后，虚拟机外部的二进制数据就会按照虚拟机所需要的格式存储在虚拟机的方法区中，接着开始连接阶段，连接阶段分为验证、准备、解析三个阶段； 验证阶段验证阶段是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会对虚拟机自身安全造成危害。当验证不通过时，虚拟机应当抛出一个java.lang.VerifyError异常。 虚拟机首先会进行文件格式验证，文件格式验证会对以下几个方面进行验证： 是否以魔数0xCAFEBABE开头； 类的主次版本号是否在当前虚拟机处理范围之内； 常量池的常量是否含有不被支持的常量类型； 指向常量的各种索引值中是否有指向不存在的常量或者不符合类型的常量； 其他二进制字节流的验证。 文件格式验证完后，然后开始元数据验证，元数据验证是对字节码描述的信息进行语义分析，保证不存在不符合Java语言规定的元数据信息，包括： 这个类是否有父类； 这个类的父类是否继承了不允许继承的类； 如果这个类不是抽象类，是否实现了父类或者接口之中要求实现的所有方法； 类中的字段、方法是否与父类产生矛盾； 其他语义验证。 元数据验证后，开始进行字节码验证，字节码验证主要是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。这阶段会对类的方法进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件。 字节码验证后，进行验证阶段最后一个验证：符号引用验证，符号引用验证可以看作是对自身以外的信息（常量池中的各种符号引用）进行匹配性校验。符号引用验证的目的是确保解析动作能正常执行。 准备阶段准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所需要的内存都将在方法区中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。这里说的初始值通常情况下是数据类型的零值，假设定义了一个变量： 1public static int value = 123； 变量value在准备阶段初始化值为0，而不是123，将变量赋值为123是在初始化阶段才会执行。 基本数据类型的零值： 数据类型 零值 int 0 long 0L short 0 char ‘\\u0000’ byte 0 boolean false float 0.0f double 0.0d reference null 如果这个变量是个常量，那么这个变量在准备阶段就会被赋值，如： 1public static final int value = 123； 变量value在准备阶段就会被赋值为123。 解析阶段解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用：符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用于虚拟机实现内存布局无关，引用的目标不一一定已经加载到内存中。 直接引用：直接引用可以使直接指向目标的指针、相对偏移量是一个能简介定位到目标的句柄。 解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。 类或接口的解析判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。 字段解析在对字段进行解析前，会先查看该字段所属的类或接口的符号引用是否已经解析过，没有就先对字段所属的接口或类进行解析。在对字段进行解析的时候，先查找本类或接口中是否有该字段，有就直接返回；否则，再对实现的接口进行遍历，会按照继承关系从下往上递归（也就是说，每个父接口都会走一遍）搜索各个接口和它的父接口，返回最近一个接口的直接引用；再对继承的父类进行遍历，会按照继承关系从下往上递归（也就是说，每个父类都会走一遍）搜索各个父类，返回最近一个父类的直接引用。 类方法解析和字段解析搜索步骤差不多，只不过是先搜索父类，再搜索接口。 接口方法解析和类方法解析差不多，只不过接口中不会有父类，因此只需要对父接口进行搜索即可。 初始化阶段类加载阶段的最后一个阶段就是初始化阶段，初始化阶段是执行类构造器&lt;clinit&gt;()方法的过程。 &lt;clinit&gt;()方法是由编译器自动收集类中的所有变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但是不能访问。 &lt;clinit&gt;()方法与类构造函数不一样，它不需要显示的调用父类的构造器，虚拟机会保证子类的&lt;clinit&gt;()方法执行之前，父类的&lt;clinit&gt;()已经执行完毕。 由于父类的&lt;clinit&gt;()方法先执行，所以父类的静态语句块优于子类的变量赋值操作。 &lt;clinit&gt;()对类或者接口来说并不是必须的，如果一个类没有静态语句块，也就没有对变量的赋值操作，那么编译器不会为这个类生成&lt;clinit&gt;()方法。 接口中无静态语句块但是有赋值操作，因此接口也会有&lt;clinit&gt;()方法，但是接口的&lt;clinit&gt;()方法只用当子类和实现类中定义的变量有使用时才会执行&lt;clinit&gt;()方法。 &lt;clinit&gt;()方法是线程安全的。 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/tags/Java虚拟机/"}]},{"title":"Java虚拟机之垃圾回收机制","slug":"Java虚拟机之垃圾回收机制","date":"2018-01-25T07:14:22.000Z","updated":"2018-02-01T05:20:16.818Z","comments":true,"path":"Java虚拟机之垃圾回收机制/","link":"","permalink":"https://satradj.github.io/Java虚拟机之垃圾回收机制/","excerpt":"概述在Java堆中，同一个接口中的多个实现类需要的内存是不一样的，一个方法中的多个分支需要的内存也不一样，Java程序只有在处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。本文将讲述Java自动内存管理中，Java虚拟机对内存的回收机制。","text":"概述在Java堆中，同一个接口中的多个实现类需要的内存是不一样的，一个方法中的多个分支需要的内存也不一样，Java程序只有在处于运行期间才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。本文将讲述Java自动内存管理中，Java虚拟机对内存的回收机制。 判断对象能否回收JVM虚拟机只有在对象已经“死亡”后，才会将这个对象所占用的内存回收释放，而判断对象是否“死亡”的算法有：引用计数算法和可达性分析算法。 引用计数算法引用计数算法很通俗易懂，给每个对象添加一个应用计数器，每当有一个地方引用它的时候，计数器加一；当引用失效时，计数器减一；当对象的引用计数器为零时，证明对象已经没有任何地方引用它了，此时可以判断对象所占用的内存可回收了。 引用计数算法不能解决对象之间相互循环引用的问题；例如，对象A中引用了对象B，对象B中引用了对象A，但是对象A和对象B都没有其他引用并且对象A和B都不可被访问到了，此时，由于对象A持有B的引用，所以对象B引用计数器不为0，对象B不会被回收，而对象B持有对象A的引用，对象A的引用计数器不为0；所以对象A同样不会被回收。 可达性分析算法在目前主流的虚拟机中，判断对象是否死亡的算法为可达性分析算法。这个算法的基本思路是通过一系列称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到“GC Roots”没有任何引用链相连时，证明此对象是不可用的，如图所示：object5、object6、object7之间虽然互相关联，但是它们到“GC Roots”是不可达的，所以它们会被判为可回收的对象。在Java中“GC Roots”可以是： 虚拟机栈中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量池引用的对象； 本地方法栈中JNI引用的对象； Java引用类型强引用Object obj = new Object()这种对象的引用为强引用，只要引用还在对象就不会被回收。 软引用软引用对象创建：1SoftReference&lt;Object&gt; sobj = new SoftReference(new Object()) 对于软引用对象，在系统将要发生内存溢出时，会将这些对象回收，如果回收后内存还不够，才会抛出内存溢出异常。 弱引用弱引用对象创建：1WeakReference&lt;Object&gt; wobj = new WeakReference(new Object()) 对于弱引用，当垃圾收集器工作时，被弱引用引用的对象都会被回收。 虚引用虚引用对象创建：12ReferenceQueue queue = new ReferenceQueue();PhantomReference ref = new PhantomReference(new Object(), queue); 虚引用对象的创建需要配合队列使用； 被虚引用引用的对象无法通过该引用来获取一个实例，在下一次GC时，该对象也会被回收，虚引用唯一的目的是在GC时收到一个系统通知。 垃圾回收算法标记—清除算法标记—清除算法如同它的名字一样，需要经过两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有标记的对象。 标记清除算法有两个不足：一是效率不高，二是会产生大量空间碎片。 复制算法复制算法将可用内存分为大小相等的两块，每次只使用其中一块，当这一块内存用完了，就将存活的对象复制到另一块上，然后再将已经使用过的内存一次清理掉。 这种算法有个缺点，内存缩小为了原来的一半，这样代价太高了。现在的商用虚拟机都采用这种算法来回收新生代，不过研究表明1:1的比例非常不科学，因此新生代的内存被划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。每次回收时，将Eden和Survivor中还存活着的对象一次性复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden区和两块Survivor区的比例为8:1:1。 标记—整理算法标记-整理算法过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。 分代收集算法现代商用虚拟机基本都采用分代收集算法来进行垃圾回收。大批对象死去、少量对象存活的新生代，使用复制算法，复制成本低；对象存活率高、没有额外空间进行分配担保的老年代，采用标记-清理算法或者标记-整理算法。 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/tags/Java虚拟机/"}]},{"title":"Java虚拟机之JVM内存区域与Java对象","slug":"Java虚拟机之JVM内存区域与Java对象","date":"2018-01-10T10:33:18.000Z","updated":"2018-02-01T05:20:01.883Z","comments":true,"path":"Java虚拟机之JVM内存区域与Java对象/","link":"","permalink":"https://satradj.github.io/Java虚拟机之JVM内存区域与Java对象/","excerpt":"前言最近第七次拜读《深入理解Java虚拟机:JVM高级特性与最佳实践》，每次读都有不同的收获，为了以防自己读后忘记，同时为了加深理解，准备写一系列JVM相关文章。能力有限，文中大部分内容均由本人整理总结自《深入理解Java虚拟机:JVM高级特性与最佳实践》，文中出现错误的地方请见谅。","text":"前言最近第七次拜读《深入理解Java虚拟机:JVM高级特性与最佳实践》，每次读都有不同的收获，为了以防自己读后忘记，同时为了加深理解，准备写一系列JVM相关文章。能力有限，文中大部分内容均由本人整理总结自《深入理解Java虚拟机:JVM高级特性与最佳实践》，文中出现错误的地方请见谅。 JVM内存区域对于c、c++程序员而言，需要手动去管理自己创建对象所占用内存的销毁。而对于Java程序员而言，虚拟机帮你完成了这部分工作。Java虚拟机在运行时会将它所管理的内存划分为若干个不同的数据区域，我们一般把这叫做JVM的内存模型。 JVM运行时内存区域可分为：虚拟机栈、本地方法栈、程序计数器、方法区、堆；其中虚拟机栈、本地方法栈和程序计数器为线程安全区域，而方法区和堆为线程不安全区域；如下图所示： 虚拟机栈顾名思义，虚拟机栈是用于供程序使用的栈内存，它的生命周期与线程相同，虚拟机栈会在每个方法执行时创建一个栈帧，栈帧中存储着局部变量表、操作数栈、动态连接、方法出口等。当程序运行所需栈内存超过栈的大小虚拟机会抛出StackOverflowError异常，此时可通过JVM虚拟机参数—Xss调整栈大小；当机器可用物理内存小于JVM虚拟机栈所需内存时会抛出OutOfMemoryError异常。笔者在Linux上基于HotSpot虚拟机测得虚拟机栈默认大小为1024kb 其中局部变量表存放着编译期间可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象的引用、返回地址；局部变量表的大小在编译期间就已经知道了，除64位long和double占用两个局部变量空间（Slot）外，其余均只占用一个局部变量表。方法在运行期间不会改变局部变量表大小。 操作数栈：方法执行中进行算术运算或者是调用其他的方法进行参数传递的时候是通过操作数栈进行的。 动态连接：Class 文件中存放了大量的符号引用，字节码中的方法调用指令就是以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化称为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。 返回地址中存放的是方法执行完之后返回地址。 本地方法栈本地方法栈与虚拟机栈的作用是类似的，不同的是：虚拟机栈是为执行Java方法服务而本地方法栈是为虚拟机使用到的Native方法服务。值得注意的是在sun公司的HotSpot虚拟机上，本地方法栈与虚拟机栈是合并在一起的。 程序计数器程序计数器可以看作是当前线程所执行的字节码的行号指示器，每个线程都有一个独立的程序计数器，各线程之间互不影响。若线程正在执行一个Native方法，则此时该线程的程序计数器为空。 方法区方法区用于存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。方法区也称之为“永久代”。 值得一说的是，在方法区中有一个运行时常量池（注意我说的是运行时的常量池），对于Java class文件也有一个常量池。运行时常量池是class文件常量池中编译期间生成的各种已知的字面量和符号引用，在class文件首次被虚拟机加载时载入方法区的运行时常量池。运行时常量池具备动态特性，不止只有class文件中常量池才能进入方法区运行时常量池，运行期间也可能将新的常量放入其中，例如String类的intern()方法。另外值得注意的是在JDK1.7之后的HotSpot虚拟机，字符串常量池已不在方法区，而在堆内存之中。 堆Java虚拟机规范中描述：所有的对象实例以及数组都要在堆上分配内存。也就是说堆主要是存放对象实例的。 堆内存大小可通过-Xms、-Xmx控制大小。JVM虚拟机的垃圾收集器主要活动的区域也是这块区域。对于堆内存还可分为新生代和老年代，其中默认情况下新生代占堆内存大小的三分之一，老年代占堆内存大小的三分之二，可通过参数-XX:NewRatio控制这个比例的大小。对于新生代还可分为Eden区和两个Survivor区其大小比为8：1：1。大内存对象直接分配在老年代，小内存对象分配在新生代Eden中GC一次后“搬移”到Survivor区，在Survivor区存活若干次GC后将会被“搬移”至老年代。关于GC相关的我会在后续文章中详细说明。 Java对象对象的创建在Java程序运行时，运行至对象创建指令（new、克隆、反序列化等）时，首先将检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，必须先执行相应的类加载过程。 类加载检查后虚拟机将为类分配内存，对象所需内存大小在类加载完后即可确定。为类分配内存有两种方式：一是若Java堆中内存是绝对规整的，所有使用中的内存放一边，空闲内存放另一边，中间放着一个指针作为分界点的指示器，分配内存时只需将指针向空闲空间那边移动一段与对象大小相等的距离，这种分配方式称之为“指针碰撞”。另一种是Java堆不是规整的，虚拟机维护了一个队列，队列记录了哪些内存块是可用的，在分配内存时从列表中找一块足够大的空间划分给对象实例，并更新记录，这种分配方式称之为“空闲列表”。 在并发情况下，对象创建的原子性是靠虚拟机通过CAS与失败重试保证的。另外可通过参数-XX:+/-UseTLAB来保证对象创建的原子性，TLAB是每个线程在Java堆中预先分配一块小的内存，称之为本地线程分配缓冲（TLAB）,对象首先在各自线程的TLAB中分配内存，只有当TLAB不够用需要重新分配TLAB时，才会同步锁定。 对象内存布局对象在内存中存储可分为三块区：对象头、实例数据、对齐填充。 对象头一部分存储对象自身运行时数据（HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等），另一部分是类型指针，即对象指向它的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 对象在堆内存的访问定位Java程序通过栈上reference数据来操作堆上对象实例，reference可能指向堆中的一个句柄池，句柄池中存放着堆中对象实例的地址和方法区中对象类型数据的地址； reference中也有可能直接存放着堆中实例对象地址，在对象头中存放着方法区对象类型数据地址。对象类型数据笔者认为是虚拟机从磁盘中class文件加载进方法区的对象类型数据。 参考文献《深入理解Java虚拟机:JVM高级特性与最佳实践》 周志明著","categories":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/categories/Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://satradj.github.io/tags/Java虚拟机/"}]},{"title":"爬虫爬取了某大学阳光平台几千条信件后做了个有趣的分析","slug":"爬虫爬取了某大学阳光平台几千条信件后做了个有趣的分析","date":"2017-12-12T11:48:52.000Z","updated":"2018-02-01T05:20:48.408Z","comments":true,"path":"爬虫爬取了某大学阳光平台几千条信件后做了个有趣的分析/","link":"","permalink":"https://satradj.github.io/爬虫爬取了某大学阳光平台几千条信件后做了个有趣的分析/","excerpt":"最近在家准备写毕业论文，在家里查文献的时候特别不方便，知网的文献不能下载，只能看到摘要。但是我校购买了知网数据库，使用学校ip可以直接下载知网文献，遂上阳光服务平台准备咨询是否提供vpn连接到校内网供学生查询文献。然后突发奇想，使用python编写了个爬虫把阳光服务平台数据爬下来做数据分析。爬虫部分代码就不帖出来了，让我们一起来看下数据分析。","text":"最近在家准备写毕业论文，在家里查文献的时候特别不方便，知网的文献不能下载，只能看到摘要。但是我校购买了知网数据库，使用学校ip可以直接下载知网文献，遂上阳光服务平台准备咨询是否提供vpn连接到校内网供学生查询文献。然后突发奇想，使用python编写了个爬虫把阳光服务平台数据爬下来做数据分析。爬虫部分代码就不帖出来了，让我们一起来看下数据分析。 爬虫爬取的所有数据均保存在MySQL中，首先导入必要的包。 12345import numpy as npimport pandas as pdimport matplotlib.pyplot as pltimport pymysqlimport jieba 将数据从数据库导入进来。 12conn = pymysql.Connect(host='127.0.0.1', user='root', password='root', port=3306, db='ygfw', charset='utf8')df = pd.read_sql('select * from qa', conn) 让我们看下前面5条数据。 1df.head() 这里对字段说明下 字段 说明 title 标题 accept 受理单位 type 类型 submit_time 提交时间 finish_time 回复时间 click_num 点击次数 context 内容 status 状态 replay 回复 url 原链接地址 首先我们看下点击率。 12df.set_index('submit_time')['click_num'].plot()plt.show() 点击率最高数量的在2017年8月左右达到了6000多，让我们看下点击率第一的是哪条。 1(df.sort_values(by=['click_num'], ascending=False)).head() 可以看到点记录排第一的是来自城乡资源与规划学院的一封表扬唐老师的信件，点击有6500多次。 按照月份看下从14年到17年每个月提交信件的数量将submit_time提取出来作为一个Series的index，将Series的值设置为1作为统计计数，然后用lambda表达式按照月份统计信件和。 123s = pd.Series(1, index=df['submit_time'])s.groupby(lambda x: x.month).sum().plot()plt.show() 可以看到在十一月份左右信件数量最多，达到了450左右，而二月份和八月份可能是由于寒暑假的原因达到了年度最低量。 12s.groupby(lambda x: x.year).sum().plot(kind='bar')plt.show() 由于17年还没过完，所以17年比16年要少点。按照年份来看，阳光服务平台的信件数量呈现逐年上升趋势。 12345plt.rcParams['font.sans-serif'] = ['SimHei']plt.figure(figsize=(10, 6))s2 = pd.Series(1, index=df['accept'])s2.groupby('accept').sum().plot(kind='bar')plt.show() 其中各部门中管理处的信件是最多的，可能是大多数人不知道要发往那个部门，就往管理处投吧，233333~ 然后我们看下各部门对信件的处理速度吧。我们将信件处理完成的时间减去提交时间得到的时间差转换成秒数，然后对各部门的时间差求平均，得到各部门处理每封信件的速度。 12345678df['time'] = df['finish_time'] - df['submit_time']df['time'] = df['time'].apply(lambda x: x.total_seconds())df['num'] = 1df2 = df.set_index('accept').groupby('accept').sum()df2['mean'] = df2['time'] / df2['num']plt.figure(figsize=(10, 10))df2['mean'].plot(kind='barh')plt.show() 其中张家界校区财务办处理信件的速度最慢，历史与文化学院处理信件的速度最快，从上面各部门信件数量上来看历史与文化学院与张家界校区财务办信件数量上是差不多的，都比较少。 1234plt.figure(figsize=(11, 6))df3 = df.set_index('type').groupby('type').sum()df3['num'].plot(kind='barh')plt.show() 看下信件的类型，其中最多的是反映，第二是投诉，最少的是表扬，看样子学校做的不好的地方还是有点多啊。 好了，我们的数据分析先暂时到这。","categories":[{"name":"数据分析","slug":"数据分析","permalink":"https://satradj.github.io/categories/数据分析/"}],"tags":[{"name":"数据分析","slug":"数据分析","permalink":"https://satradj.github.io/tags/数据分析/"}]}]}